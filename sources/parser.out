Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    DEFINED
    EXPONENT_AND
    FALSE
    NEXT
    NIL
    PUTS
    REDO
    RETRY
    SELF
    TRUE
    VAR_SYSTEM
    _FILE_
    _LINE_

Grammar

Rule 0     S' -> program
Rule 1     program -> compstmt
Rule 2     compstmt -> stmt
Rule 3     compstmt -> stmt term
Rule 4     compstmt -> stmt term expr term
Rule 5     stmt -> call do LBRACKET RBRACKET
Rule 6     stmt -> LBRACKET block_var RBRACKET
Rule 7     stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
Rule 8     stmt -> UNDEF fname
Rule 9     stmt -> ALIAS fname fname
Rule 10    stmt -> stmt IF expr
Rule 11    stmt -> stmt WHILE expr
Rule 12    stmt -> stmt UNLESS expr
Rule 13    stmt -> stmt UNTIL expr
Rule 14    stmt -> BEGIN LKEY compstmt RKEY
Rule 15    stmt -> END LKEY compstmt RKEY
Rule 16    stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
Rule 17    stmt -> expr
Rule 18    expr -> mlhs = mrhs
Rule 19    expr -> RETURN call_args
Rule 20    expr -> YIELD call_args
Rule 21    expr -> expr AND expr
Rule 22    expr -> expr OR expr
Rule 23    expr -> NOT expr
Rule 24    expr -> command
Rule 25    expr -> NOT_SYMBOL command
Rule 26    expr -> arg
Rule 27    call -> function
Rule 28    call -> command
Rule 29    command -> operation call_args
Rule 30    command -> primary DOT operation call_args
Rule 31    command -> primary UNARY_OP operation call_args
Rule 32    command -> SUPER call_args
Rule 33    function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
Rule 34    function -> primary DOT operation LPAREN call_args RPAREN
Rule 35    function -> primary UNARY_OP operation LPAREN call_args RPAREN
Rule 36    function -> primary DOT operation
Rule 37    function -> primary UNARY_OP operation
Rule 38    function -> SUPER LPAREN call_args RPAREN
Rule 39    function -> SUPER
Rule 40    arg -> lhs = arg
Rule 41    arg -> lhs op_asgn arg
Rule 42    arg -> arg RANGE_INCLUSIVE arg
Rule 43    arg -> arg RANGE_EXCLUSIVE arg
Rule 44    arg -> math_operations
Rule 45    arg -> PLUS arg
Rule 46    arg -> MINUS arg
Rule 47    arg -> arg OR_SYMBOL arg
Rule 48    arg -> arg BINARY_XOR_OP arg
Rule 49    arg -> arg BINARY_AND_OP arg
Rule 50    arg -> arg COMBINED_COMPARISON_OP arg
Rule 51    arg -> arg GREATERTHAN arg
Rule 52    arg -> arg GREATERTHANEQUAL arg
Rule 53    arg -> arg LESSERTHAN arg
Rule 54    arg -> arg LESSERTHANEQUAL arg
Rule 55    arg -> arg EQUAL arg
Rule 56    arg -> arg CASE_EQUALITY arg
Rule 57    arg -> arg NOTEQUAL arg
Rule 58    arg -> arg MATCHED_STRINGS_OP arg
Rule 59    arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg
Rule 60    arg -> NOT_SYMBOL arg
Rule 61    arg -> COMPLEMENT_OP arg
Rule 62    arg -> arg BINARY_LEFT_SHIFT_OP arg
Rule 63    arg -> arg BINARY_RIGHT_SHIFT_OP arg
Rule 64    arg -> arg AND arg
Rule 65    arg -> arg OR arg
Rule 66    arg -> DEFINED_OP arg
Rule 67    arg -> primary
Rule 68    variable -> VAR_GLOBAL
Rule 69    variable -> VAR_LOCAL
Rule 70    variable -> VAR_INSTANCE
Rule 71    variable -> VAR_CLASS
Rule 72    primary -> LPAREN compstmt RPAREN
Rule 73    primary -> literal
Rule 74    primary -> variable
Rule 75    primary -> primary UNARY_OP IDENTIFIER
Rule 76    primary -> UNARY_OP IDENTIFIER
Rule 77    primary -> primary LBRACKET RBRACKET
Rule 78    primary -> primary LBRACKET args RBRACKET
Rule 79    primary -> LBRACKET RBRACKET
Rule 80    primary -> LBRACKET args RBRACKET
Rule 81    primary -> LBRACKET args COMMA RBRACKET
Rule 82    primary -> LKEY RKEY
Rule 83    primary -> LKEY args RKEY
Rule 84    primary -> LKEY assocs RKEY
Rule 85    primary -> LKEY args COMMA RKEY
Rule 86    primary -> LKEY assocs COMMA RKEY
Rule 87    primary -> RETURN
Rule 88    primary -> RETURN LPAREN RPAREN
Rule 89    primary -> RETURN LPAREN call_args RPAREN
Rule 90    primary -> YIELD
Rule 91    primary -> YIELD LPAREN RPAREN
Rule 92    primary -> YIELD LPAREN call_args RPAREN
Rule 93    primary -> DEFINED_OP LPAREN arg LPAREN
Rule 94    primary -> function
Rule 95    primary -> function LKEY compstmt LKEY
Rule 96    primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
Rule 97    primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
Rule 98    primary -> IF expr then compstmt END
Rule 99    primary -> IF expr then compstmt elsif END
Rule 100   primary -> IF expr then compstmt elsif ELSE compstmt END
Rule 101   primary -> UNLESS expr then compstmt END
Rule 102   primary -> UNLESS expr then compstmt ELSE compstmt END
Rule 103   primary -> WHILE expr do compstmt END
Rule 104   primary -> UNTIL expr do compstmt END
Rule 105   primary -> CASE compstmt when END
Rule 106   primary -> CASE compstmt when ELSE compstmt END
Rule 107   primary -> FOR block_var IN expr do compstmt END
Rule 108   primary -> BEGIN compstmt rescue END
Rule 109   primary -> BEGIN compstmt rescue ELSE compstmt END
Rule 110   primary -> BEGIN compstmt rescue ENSURE compstmt END
Rule 111   primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
Rule 112   primary -> CLASS IDENTIFIER compstmt END
Rule 113   primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
Rule 114   primary -> MODULE IDENTIFIER compstmt END
Rule 115   primary -> DEF fname argdecl compstmt END
Rule 116   primary -> DEF singleton DOT fname argdecl compstmt END
Rule 117   primary -> DEF singleton UNARY_OP fname argdecl compstmt END
Rule 118   elsif -> ELSIF expr then compstmt
Rule 119   elsif -> ELSIF expr then compstmt elsif
Rule 120   when -> WHEN when_args then compstmt
Rule 121   when -> when WHEN when_args then compstmt
Rule 122   rescue -> RESCUE args do compstmt
Rule 123   rescue -> RESCUE do compstmt
Rule 124   rescue -> rescue RESCUE args do compstmt
Rule 125   rescue -> rescue RESCUE do compstmt
Rule 126   when_args -> args
Rule 127   when_args -> args COMMA TIMES arg
Rule 128   when_args -> TIMES arg
Rule 129   then -> TERM
Rule 130   then -> THEN
Rule 131   then -> TERM THEN
Rule 132   do -> term
Rule 133   do -> DO
Rule 134   do -> term DO
Rule 135   term -> TERM
Rule 136   mrhs -> args
Rule 137   mrhs -> args COMMA
Rule 138   mrhs -> args TIMES
Rule 139   mrhs -> args arg
Rule 140   mrhs -> TIMES arg
Rule 141   lhs -> variable
Rule 142   lhs -> primary LBRACKET RBRACKET
Rule 143   lhs -> primary LBRACKET args RBRACKET
Rule 144   lhs -> primary DOT IDENTIFIER
Rule 145   block_var -> lhs
Rule 146   block_var -> mlhs
Rule 147   mlhs -> mlhs_item COMMA mlhs_item TIMES
Rule 148   mlhs -> mlhs_item COMMA mlhs_item lhs
Rule 149   mlhs -> mlhs_item COMMA mult_mlhs_item TIMES
Rule 150   mlhs -> mlhs_item COMMA mult_mlhs_item lhs
Rule 151   mlhs -> TIMES lhs
Rule 152   mult_mlhs_item -> COMMA mlhs_item
Rule 153   mlhs_item -> lhs
Rule 154   mlhs_item -> LPAREN mlhs RPAREN
Rule 155   args -> arg
Rule 156   args -> arg COMMA arg
Rule 157   argdecl -> LPAREN arglist RPAREN
Rule 158   argdecl -> arglist term
Rule 159   arglist -> IDENTIFIER
Rule 160   arglist -> IDENTIFIER COMMA IDENTIFIER
Rule 161   arglist -> IDENTIFIER COMMA & IDENTIFIER
Rule 162   singleton -> variable
Rule 163   singleton -> LPAREN expr RPAREN
Rule 164   assocs -> assoc
Rule 165   assocs -> assoc COMMA assoc
Rule 166   assoc -> arg HASH_ROCKET arg
Rule 167   call_args -> args
Rule 168   call_args -> args COMMA assocs
Rule 169   call_args -> args COMMA TIMES arg
Rule 170   call_args -> args COMMA BINARY_AND_OP arg
Rule 171   call_args -> args COMMA assocs COMMA TIMES arg
Rule 172   call_args -> args COMMA assocs COMMA BINARY_AND_OP arg
Rule 173   call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg
Rule 174   call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
Rule 175   call_args -> assocs
Rule 176   call_args -> assocs COMMA TIMES arg
Rule 177   call_args -> assocs COMMA BINARY_AND_OP arg
Rule 178   call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
Rule 179   call_args -> TIMES arg
Rule 180   call_args -> TIMES arg COMMA BINARY_AND_OP arg
Rule 181   call_args -> BINARY_AND_OP arg
Rule 182   call_args -> command
Rule 183   literal -> NUMBER
Rule 184   literal -> SYMBOL
Rule 185   literal -> STRING
Rule 186   literal -> IDENTIFIER
Rule 187   fname -> IDENTIFIER
Rule 188   fname -> RANGE_INCLUSIVE
Rule 189   fname -> OR_SYMBOL
Rule 190   fname -> BINARY_AND_OP
Rule 191   fname -> BINARY_XOR_OP
Rule 192   fname -> COMBINED_COMPARISON_OP
Rule 193   fname -> EQUAL
Rule 194   fname -> CASE_EQUALITY
Rule 195   fname -> MATCHED_STRINGS_OP
Rule 196   fname -> GREATERTHAN
Rule 197   fname -> GREATERTHANEQUAL
Rule 198   fname -> LESSERTHAN
Rule 199   fname -> LESSERTHANEQUAL
Rule 200   fname -> PLUS
Rule 201   fname -> MINUS
Rule 202   fname -> TIMES
Rule 203   fname -> DIVIDE
Rule 204   fname -> MOD
Rule 205   fname -> POW
Rule 206   fname -> BINARY_RIGHT_SHIFT_OP
Rule 207   fname -> BINARY_LEFT_SHIFT_OP
Rule 208   fname -> COMPLEMENT_OP
Rule 209   fname -> OVERLOAD_PLUS
Rule 210   fname -> OVERLOAD_MINUS
Rule 211   fname -> LBRACKET RBRACKET
Rule 212   fname -> LBRACKET RBRACKET EQUAL_SYMBOL
Rule 213   operation -> IDENTIFIER
Rule 214   operation -> IDENTIFIER NOT_SYMBOL
Rule 215   operation -> IDENTIFIER OPTIONAL_SYMBOL
Rule 216   op_asgn -> PLUS_EQUAL
Rule 217   op_asgn -> MINUS_EQUAL
Rule 218   op_asgn -> TIMES_EQUAL
Rule 219   op_asgn -> DIVIDE_EQUAL
Rule 220   op_asgn -> MOD_EQUAL
Rule 221   op_asgn -> POW_EQUAL
Rule 222   op_asgn -> SINGLE_AND_EQUAL
Rule 223   op_asgn -> SINGLE_OR_EQUAL
Rule 224   op_asgn -> XOR_EQUAL
Rule 225   op_asgn -> BINARY_LEFT_EQUAL
Rule 226   op_asgn -> BINARY_RIGHT_EQUAL
Rule 227   op_asgn -> AND_EQUAL
Rule 228   op_asgn -> OR_EQUAL
Rule 229   math_operations -> arg PLUS arg
Rule 230   math_operations -> arg MINUS arg
Rule 231   math_operations -> arg TIMES arg
Rule 232   math_operations -> arg DIVIDE arg
Rule 233   math_operations -> arg MOD arg
Rule 234   math_operations -> arg POW arg
Rule 235   math_operations -> NUMBER PLUS NUMBER
Rule 236   math_operations -> NUMBER MINUS NUMBER
Rule 237   math_operations -> NUMBER TIMES NUMBER
Rule 238   math_operations -> NUMBER DIVIDE NUMBER
Rule 239   math_operations -> NUMBER MOD NUMBER
Rule 240   math_operations -> NUMBER POW NUMBER

Terminals, with rules where they appear

&                    : 161
=                    : 16 18 40
ALIAS                : 9
AND                  : 21 64
AND_EQUAL            : 227
BEGIN                : 14 108 109 110 111
BINARY_AND_OP        : 49 170 172 173 174 177 178 180 181 190
BINARY_LEFT_EQUAL    : 225
BINARY_LEFT_SHIFT_OP : 62 207
BINARY_RIGHT_EQUAL   : 226
BINARY_RIGHT_SHIFT_OP : 63 206
BINARY_XOR_OP        : 48 191
BREAK                : 
CASE                 : 105 106
CASE_EQUALITY        : 56 194
CLASS                : 112 113
COMBINED_COMPARISON_OP : 50 192
COMMA                : 81 85 86 127 137 147 148 149 150 152 156 160 161 165 168 169 170 171 171 172 172 173 173 174 174 174 176 177 178 178 180
COMPLEMENT_OP        : 61 208
DEF                  : 115 116 117
DEFINED              : 
DEFINED_OP           : 66 93
DIVIDE               : 203 232 238
DIVIDE_EQUAL         : 219
DO                   : 133 134
DOT                  : 30 34 36 116 144
ELSE                 : 100 102 106 109 111
ELSIF                : 118 119
END                  : 7 15 16 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117
ENSURE               : 110 111
EQUAL                : 55 193
EQUAL_SYMBOL         : 212
EXPONENT_AND         : 
FALSE                : 
FOR                  : 107
GREATERTHAN          : 51 196
GREATERTHANEQUAL     : 52 197
HASH_ROCKET          : 166
IDENTIFIER           : 75 76 112 113 113 114 144 159 160 160 161 161 186 187 213 214 215
IF                   : 10 98 99 100
IN                   : 107
LBRACKET             : 5 6 7 16 16 33 33 77 78 79 80 81 142 143 211 212
LESSERTHAN           : 53 113 198
LESSERTHANEQUAL      : 54 199
LKEY                 : 14 15 82 83 84 85 86 95 95 96 96 97 97
LPAREN               : 33 34 35 38 72 88 89 91 92 93 93 154 157 163
MATCHED_STRINGS_OP   : 58 195
MINUS                : 46 201 230 236
MINUS_EQUAL          : 217
MOD                  : 204 233 239
MODULE               : 114
MOD_EQUAL            : 220
NEXT                 : 
NIL                  : 
NOT                  : 23
NOTEQUAL             : 57
NOT_SYMBOL           : 25 60 214
NUMBER               : 183 235 235 236 236 237 237 238 238 239 239 240 240
OPPOSITE_MATCHED_STRINGS_OP : 59
OPTIONAL_SYMBOL      : 215
OR                   : 22 65
OR_EQUAL             : 228
OR_SYMBOL            : 7 7 16 16 47 96 96 97 97 189
OVERLOAD_MINUS       : 210
OVERLOAD_PLUS        : 209
PLUS                 : 45 200 229 235
PLUS_EQUAL           : 216
POW                  : 205 234 240
POW_EQUAL            : 221
PUTS                 : 
RANGE_EXCLUSIVE      : 43
RANGE_INCLUSIVE      : 42 188
RBRACKET             : 5 6 7 16 16 33 33 77 78 79 80 81 142 143 211 212
REDO                 : 
RESCUE               : 122 123 124 125
RETRY                : 
RETURN               : 19 87 88 89
RKEY                 : 14 15 82 83 84 85 86
RPAREN               : 33 34 35 38 72 88 89 91 92 154 157 163
SELF                 : 
SINGLE_AND_EQUAL     : 222
SINGLE_OR_EQUAL      : 223
STRING               : 185
SUPER                : 32 38 39
SYMBOL               : 184
TERM                 : 129 131 135
THEN                 : 130 131
TIMES                : 127 128 138 140 147 149 151 169 171 173 174 176 178 179 180 202 231 237
TIMES_EQUAL          : 218
TRUE                 : 
UNARY_OP             : 31 35 37 75 76 117
UNDEF                : 8
UNLESS               : 12 101 102
UNTIL                : 13 104
VAR_CLASS            : 71
VAR_GLOBAL           : 68
VAR_INSTANCE         : 70
VAR_LOCAL            : 69
VAR_SYSTEM           : 
WHEN                 : 120 121
WHILE                : 11 103
XOR_EQUAL            : 224
YIELD                : 20 90 91 92
_FILE_               : 
_LINE_               : 
error                : 

Nonterminals, with rules where they appear

arg                  : 26 40 41 42 42 43 43 45 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 61 62 62 63 63 64 64 65 65 66 93 127 128 139 140 155 156 156 166 166 169 170 171 172 173 173 174 174 176 177 178 178 179 180 180 181 229 229 230 230 231 231 232 232 233 233 234 234
argdecl              : 115 116 117
arglist              : 157 158
args                 : 78 80 81 83 85 122 124 126 127 136 137 138 139 143 167 168 169 170 171 172 173 174
assoc                : 164 165 165
assocs               : 84 86 168 171 172 174 175 176 177 178
block_var            : 6 7 16 97 107
call                 : 5
call_args            : 19 20 29 30 31 32 33 34 35 38 89 92
command              : 16 24 25 28 182
compstmt             : 1 7 14 15 16 72 95 96 97 98 99 100 100 101 102 102 103 104 105 106 106 107 108 109 109 110 110 111 111 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125
do                   : 5 16 103 104 107 122 123 124 125
elsif                : 99 100 119
expr                 : 4 10 11 12 13 17 21 21 22 22 23 98 99 100 101 102 103 104 107 118 119 163
fname                : 8 9 9 115 116 117
function             : 27 94 95 96 97
lhs                  : 16 40 41 145 148 150 151 153
literal              : 73
math_operations      : 44
mlhs                 : 18 146 154
mlhs_item            : 147 147 148 148 149 150 152
mrhs                 : 18
mult_mlhs_item       : 149 150
op_asgn              : 41
operation            : 29 30 31 33 34 35 36 37
primary              : 30 31 34 35 36 37 67 75 77 78 142 143 144
program              : 0
rescue               : 108 109 110 111 124 125
singleton            : 116 117
stmt                 : 2 3 4 10 11 12 13
term                 : 3 4 4 132 134 158
then                 : 98 99 100 101 102 118 119 120 121
variable             : 74 141 162
when                 : 105 106 121
when_args            : 120 121

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    program                        shift and go to state 1
    compstmt                       shift and go to state 2
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 1

    (0) S' -> program .



state 2

    (1) program -> compstmt .

    $end            reduce using rule 1 (program -> compstmt .)


state 3

    (2) compstmt -> stmt .
    (3) compstmt -> stmt . term
    (4) compstmt -> stmt . term expr term
    (10) stmt -> stmt . IF expr
    (11) stmt -> stmt . WHILE expr
    (12) stmt -> stmt . UNLESS expr
    (13) stmt -> stmt . UNTIL expr
    (135) term -> . TERM

    $end            reduce using rule 2 (compstmt -> stmt .)
    RESCUE          reduce using rule 2 (compstmt -> stmt .)
    RPAREN          reduce using rule 2 (compstmt -> stmt .)
    WHEN            reduce using rule 2 (compstmt -> stmt .)
    RKEY            reduce using rule 2 (compstmt -> stmt .)
    LKEY            reduce using rule 2 (compstmt -> stmt .)
    END             reduce using rule 2 (compstmt -> stmt .)
    ELSIF           reduce using rule 2 (compstmt -> stmt .)
    ELSE            reduce using rule 2 (compstmt -> stmt .)
    ENSURE          reduce using rule 2 (compstmt -> stmt .)
    IF              shift and go to state 53
    WHILE           shift and go to state 54
    UNLESS          shift and go to state 55
    UNTIL           shift and go to state 56
    TERM            shift and go to state 57

    term                           shift and go to state 52

state 4

    (17) stmt -> expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

    IF              reduce using rule 17 (stmt -> expr .)
    WHILE           reduce using rule 17 (stmt -> expr .)
    UNLESS          reduce using rule 17 (stmt -> expr .)
    UNTIL           reduce using rule 17 (stmt -> expr .)
    TERM            reduce using rule 17 (stmt -> expr .)
    $end            reduce using rule 17 (stmt -> expr .)
    RESCUE          reduce using rule 17 (stmt -> expr .)
    RPAREN          reduce using rule 17 (stmt -> expr .)
    WHEN            reduce using rule 17 (stmt -> expr .)
    RKEY            reduce using rule 17 (stmt -> expr .)
    LKEY            reduce using rule 17 (stmt -> expr .)
    END             reduce using rule 17 (stmt -> expr .)
    ELSIF           reduce using rule 17 (stmt -> expr .)
    ELSE            reduce using rule 17 (stmt -> expr .)
    ENSURE          reduce using rule 17 (stmt -> expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59


state 5

    (5) stmt -> call . do LBRACKET RBRACKET
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 60
    term                           shift and go to state 61

state 6

    (6) stmt -> LBRACKET . block_var RBRACKET
    (7) stmt -> LBRACKET . OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (79) primary -> LBRACKET . RBRACKET
    (80) primary -> LBRACKET . args RBRACKET
    (81) primary -> LBRACKET . args COMMA RBRACKET
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    OR_SYMBOL       shift and go to state 66
    RBRACKET        shift and go to state 65
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    block_var                      shift and go to state 64
    args                           shift and go to state 67
    lhs                            shift and go to state 68
    mlhs                           shift and go to state 69
    arg                            shift and go to state 70
    variable                       shift and go to state 19
    primary                        shift and go to state 71
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 7

    (15) stmt -> END . LKEY compstmt RKEY

    LKEY            shift and go to state 82


state 8

    (8) stmt -> UNDEF . fname
    (187) fname -> . IDENTIFIER
    (188) fname -> . RANGE_INCLUSIVE
    (189) fname -> . OR_SYMBOL
    (190) fname -> . BINARY_AND_OP
    (191) fname -> . BINARY_XOR_OP
    (192) fname -> . COMBINED_COMPARISON_OP
    (193) fname -> . EQUAL
    (194) fname -> . CASE_EQUALITY
    (195) fname -> . MATCHED_STRINGS_OP
    (196) fname -> . GREATERTHAN
    (197) fname -> . GREATERTHANEQUAL
    (198) fname -> . LESSERTHAN
    (199) fname -> . LESSERTHANEQUAL
    (200) fname -> . PLUS
    (201) fname -> . MINUS
    (202) fname -> . TIMES
    (203) fname -> . DIVIDE
    (204) fname -> . MOD
    (205) fname -> . POW
    (206) fname -> . BINARY_RIGHT_SHIFT_OP
    (207) fname -> . BINARY_LEFT_SHIFT_OP
    (208) fname -> . COMPLEMENT_OP
    (209) fname -> . OVERLOAD_PLUS
    (210) fname -> . OVERLOAD_MINUS
    (211) fname -> . LBRACKET RBRACKET
    (212) fname -> . LBRACKET RBRACKET EQUAL_SYMBOL

    IDENTIFIER      shift and go to state 84
    RANGE_INCLUSIVE shift and go to state 85
    OR_SYMBOL       shift and go to state 86
    BINARY_AND_OP   shift and go to state 87
    BINARY_XOR_OP   shift and go to state 88
    COMBINED_COMPARISON_OP shift and go to state 89
    EQUAL           shift and go to state 90
    CASE_EQUALITY   shift and go to state 91
    MATCHED_STRINGS_OP shift and go to state 92
    GREATERTHAN     shift and go to state 93
    GREATERTHANEQUAL shift and go to state 94
    LESSERTHAN      shift and go to state 95
    LESSERTHANEQUAL shift and go to state 96
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 100
    MOD             shift and go to state 101
    POW             shift and go to state 102
    BINARY_RIGHT_SHIFT_OP shift and go to state 103
    BINARY_LEFT_SHIFT_OP shift and go to state 104
    COMPLEMENT_OP   shift and go to state 105
    OVERLOAD_PLUS   shift and go to state 106
    OVERLOAD_MINUS  shift and go to state 107
    LBRACKET        shift and go to state 108

    fname                          shift and go to state 83

state 9

    (9) stmt -> ALIAS . fname fname
    (187) fname -> . IDENTIFIER
    (188) fname -> . RANGE_INCLUSIVE
    (189) fname -> . OR_SYMBOL
    (190) fname -> . BINARY_AND_OP
    (191) fname -> . BINARY_XOR_OP
    (192) fname -> . COMBINED_COMPARISON_OP
    (193) fname -> . EQUAL
    (194) fname -> . CASE_EQUALITY
    (195) fname -> . MATCHED_STRINGS_OP
    (196) fname -> . GREATERTHAN
    (197) fname -> . GREATERTHANEQUAL
    (198) fname -> . LESSERTHAN
    (199) fname -> . LESSERTHANEQUAL
    (200) fname -> . PLUS
    (201) fname -> . MINUS
    (202) fname -> . TIMES
    (203) fname -> . DIVIDE
    (204) fname -> . MOD
    (205) fname -> . POW
    (206) fname -> . BINARY_RIGHT_SHIFT_OP
    (207) fname -> . BINARY_LEFT_SHIFT_OP
    (208) fname -> . COMPLEMENT_OP
    (209) fname -> . OVERLOAD_PLUS
    (210) fname -> . OVERLOAD_MINUS
    (211) fname -> . LBRACKET RBRACKET
    (212) fname -> . LBRACKET RBRACKET EQUAL_SYMBOL

    IDENTIFIER      shift and go to state 84
    RANGE_INCLUSIVE shift and go to state 85
    OR_SYMBOL       shift and go to state 86
    BINARY_AND_OP   shift and go to state 87
    BINARY_XOR_OP   shift and go to state 88
    COMBINED_COMPARISON_OP shift and go to state 89
    EQUAL           shift and go to state 90
    CASE_EQUALITY   shift and go to state 91
    MATCHED_STRINGS_OP shift and go to state 92
    GREATERTHAN     shift and go to state 93
    GREATERTHANEQUAL shift and go to state 94
    LESSERTHAN      shift and go to state 95
    LESSERTHANEQUAL shift and go to state 96
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 100
    MOD             shift and go to state 101
    POW             shift and go to state 102
    BINARY_RIGHT_SHIFT_OP shift and go to state 103
    BINARY_LEFT_SHIFT_OP shift and go to state 104
    COMPLEMENT_OP   shift and go to state 105
    OVERLOAD_PLUS   shift and go to state 106
    OVERLOAD_MINUS  shift and go to state 107
    LBRACKET        shift and go to state 108

    fname                          shift and go to state 109

state 10

    (98) primary -> IF . expr then compstmt END
    (99) primary -> IF . expr then compstmt elsif END
    (100) primary -> IF . expr then compstmt elsif ELSE compstmt END
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 110
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 11

    (103) primary -> WHILE . expr do compstmt END
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 118
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 12

    (101) primary -> UNLESS . expr then compstmt END
    (102) primary -> UNLESS . expr then compstmt ELSE compstmt END
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 119
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 13

    (104) primary -> UNTIL . expr do compstmt END
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 120
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 14

    (14) stmt -> BEGIN . LKEY compstmt RKEY
    (108) primary -> BEGIN . compstmt rescue END
    (109) primary -> BEGIN . compstmt rescue ELSE compstmt END
    (110) primary -> BEGIN . compstmt rescue ENSURE compstmt END
    (111) primary -> BEGIN . compstmt rescue ELSE compstmt ENSURE compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LKEY            shift and go to state 121
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 122
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 15

    (82) primary -> LKEY . RKEY
    (83) primary -> LKEY . args RKEY
    (84) primary -> LKEY . assocs RKEY
    (85) primary -> LKEY . args COMMA RKEY
    (86) primary -> LKEY . assocs COMMA RKEY
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    RKEY            shift and go to state 123
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    args                           shift and go to state 124
    assocs                         shift and go to state 125
    arg                            shift and go to state 126
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 16

    (16) stmt -> lhs . = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (153) mlhs_item -> lhs .
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    =               shift and go to state 131
    COMMA           reduce using rule 153 (mlhs_item -> lhs .)
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 17

    (28) call -> command .
    (24) expr -> command .

  ! reduce/reduce conflict for TERM resolved using rule 24 (expr -> command .)
    DO              reduce using rule 28 (call -> command .)
    AND             reduce using rule 24 (expr -> command .)
    OR              reduce using rule 24 (expr -> command .)
    IF              reduce using rule 24 (expr -> command .)
    WHILE           reduce using rule 24 (expr -> command .)
    UNLESS          reduce using rule 24 (expr -> command .)
    UNTIL           reduce using rule 24 (expr -> command .)
    TERM            reduce using rule 24 (expr -> command .)
    $end            reduce using rule 24 (expr -> command .)
    RESCUE          reduce using rule 24 (expr -> command .)
    RPAREN          reduce using rule 24 (expr -> command .)
    WHEN            reduce using rule 24 (expr -> command .)
    RKEY            reduce using rule 24 (expr -> command .)
    LKEY            reduce using rule 24 (expr -> command .)
    END             reduce using rule 24 (expr -> command .)
    ELSIF           reduce using rule 24 (expr -> command .)
    ELSE            reduce using rule 24 (expr -> command .)
    ENSURE          reduce using rule 24 (expr -> command .)

  ! TERM            [ reduce using rule 28 (call -> command .) ]


state 18

    (27) call -> function .
    (94) primary -> function .
    (95) primary -> function . LKEY compstmt LKEY
    (96) primary -> function . LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> function . LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY

  ! reduce/reduce conflict for TERM resolved using rule 27 (call -> function .)
  ! shift/reduce conflict for LKEY resolved as shift
    DO              reduce using rule 27 (call -> function .)
    TERM            reduce using rule 27 (call -> function .)
    LBRACKET        reduce using rule 94 (primary -> function .)
    DOT             reduce using rule 94 (primary -> function .)
    UNARY_OP        reduce using rule 94 (primary -> function .)
    RANGE_INCLUSIVE reduce using rule 94 (primary -> function .)
    RANGE_EXCLUSIVE reduce using rule 94 (primary -> function .)
    OR_SYMBOL       reduce using rule 94 (primary -> function .)
    BINARY_XOR_OP   reduce using rule 94 (primary -> function .)
    BINARY_AND_OP   reduce using rule 94 (primary -> function .)
    COMBINED_COMPARISON_OP reduce using rule 94 (primary -> function .)
    GREATERTHAN     reduce using rule 94 (primary -> function .)
    GREATERTHANEQUAL reduce using rule 94 (primary -> function .)
    LESSERTHAN      reduce using rule 94 (primary -> function .)
    LESSERTHANEQUAL reduce using rule 94 (primary -> function .)
    EQUAL           reduce using rule 94 (primary -> function .)
    CASE_EQUALITY   reduce using rule 94 (primary -> function .)
    NOTEQUAL        reduce using rule 94 (primary -> function .)
    MATCHED_STRINGS_OP reduce using rule 94 (primary -> function .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 94 (primary -> function .)
    BINARY_LEFT_SHIFT_OP reduce using rule 94 (primary -> function .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 94 (primary -> function .)
    AND             reduce using rule 94 (primary -> function .)
    OR              reduce using rule 94 (primary -> function .)
    PLUS            reduce using rule 94 (primary -> function .)
    MINUS           reduce using rule 94 (primary -> function .)
    TIMES           reduce using rule 94 (primary -> function .)
    DIVIDE          reduce using rule 94 (primary -> function .)
    MOD             reduce using rule 94 (primary -> function .)
    POW             reduce using rule 94 (primary -> function .)
    IF              reduce using rule 94 (primary -> function .)
    WHILE           reduce using rule 94 (primary -> function .)
    UNLESS          reduce using rule 94 (primary -> function .)
    UNTIL           reduce using rule 94 (primary -> function .)
    $end            reduce using rule 94 (primary -> function .)
    RESCUE          reduce using rule 94 (primary -> function .)
    RPAREN          reduce using rule 94 (primary -> function .)
    WHEN            reduce using rule 94 (primary -> function .)
    RKEY            reduce using rule 94 (primary -> function .)
    COMMA           reduce using rule 94 (primary -> function .)
    HASH_ROCKET     reduce using rule 94 (primary -> function .)
    END             reduce using rule 94 (primary -> function .)
    ELSIF           reduce using rule 94 (primary -> function .)
    ELSE            reduce using rule 94 (primary -> function .)
    ENSURE          reduce using rule 94 (primary -> function .)
    LKEY            shift and go to state 146

  ! TERM            [ reduce using rule 94 (primary -> function .) ]
  ! LKEY            [ reduce using rule 94 (primary -> function .) ]


state 19

    (141) lhs -> variable .
    (74) primary -> variable .

  ! reduce/reduce conflict for LBRACKET resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for OR_SYMBOL resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for TIMES resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for IF resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for WHILE resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for UNLESS resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for UNTIL resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for COMMA resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for RPAREN resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for LKEY resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for DEFINED_OP resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for NUMBER resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for LPAREN resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for RETURN resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for YIELD resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for CASE resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for FOR resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for BEGIN resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for CLASS resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for MODULE resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for DEF resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for VAR_GLOBAL resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for VAR_LOCAL resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for VAR_INSTANCE resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for VAR_CLASS resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for STRING resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 74 (primary -> variable .)
  ! reduce/reduce conflict for SUPER resolved using rule 74 (primary -> variable .)
    =               reduce using rule 141 (lhs -> variable .)
    PLUS_EQUAL      reduce using rule 141 (lhs -> variable .)
    MINUS_EQUAL     reduce using rule 141 (lhs -> variable .)
    TIMES_EQUAL     reduce using rule 141 (lhs -> variable .)
    DIVIDE_EQUAL    reduce using rule 141 (lhs -> variable .)
    MOD_EQUAL       reduce using rule 141 (lhs -> variable .)
    POW_EQUAL       reduce using rule 141 (lhs -> variable .)
    SINGLE_AND_EQUAL reduce using rule 141 (lhs -> variable .)
    SINGLE_OR_EQUAL reduce using rule 141 (lhs -> variable .)
    XOR_EQUAL       reduce using rule 141 (lhs -> variable .)
    BINARY_LEFT_EQUAL reduce using rule 141 (lhs -> variable .)
    BINARY_RIGHT_EQUAL reduce using rule 141 (lhs -> variable .)
    AND_EQUAL       reduce using rule 141 (lhs -> variable .)
    OR_EQUAL        reduce using rule 141 (lhs -> variable .)
    IN              reduce using rule 141 (lhs -> variable .)
    LBRACKET        reduce using rule 74 (primary -> variable .)
    DOT             reduce using rule 74 (primary -> variable .)
    UNARY_OP        reduce using rule 74 (primary -> variable .)
    RANGE_INCLUSIVE reduce using rule 74 (primary -> variable .)
    RANGE_EXCLUSIVE reduce using rule 74 (primary -> variable .)
    OR_SYMBOL       reduce using rule 74 (primary -> variable .)
    BINARY_XOR_OP   reduce using rule 74 (primary -> variable .)
    BINARY_AND_OP   reduce using rule 74 (primary -> variable .)
    COMBINED_COMPARISON_OP reduce using rule 74 (primary -> variable .)
    GREATERTHAN     reduce using rule 74 (primary -> variable .)
    GREATERTHANEQUAL reduce using rule 74 (primary -> variable .)
    LESSERTHAN      reduce using rule 74 (primary -> variable .)
    LESSERTHANEQUAL reduce using rule 74 (primary -> variable .)
    EQUAL           reduce using rule 74 (primary -> variable .)
    CASE_EQUALITY   reduce using rule 74 (primary -> variable .)
    NOTEQUAL        reduce using rule 74 (primary -> variable .)
    MATCHED_STRINGS_OP reduce using rule 74 (primary -> variable .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 74 (primary -> variable .)
    BINARY_LEFT_SHIFT_OP reduce using rule 74 (primary -> variable .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 74 (primary -> variable .)
    AND             reduce using rule 74 (primary -> variable .)
    OR              reduce using rule 74 (primary -> variable .)
    PLUS            reduce using rule 74 (primary -> variable .)
    MINUS           reduce using rule 74 (primary -> variable .)
    TIMES           reduce using rule 74 (primary -> variable .)
    DIVIDE          reduce using rule 74 (primary -> variable .)
    MOD             reduce using rule 74 (primary -> variable .)
    POW             reduce using rule 74 (primary -> variable .)
    IF              reduce using rule 74 (primary -> variable .)
    WHILE           reduce using rule 74 (primary -> variable .)
    UNLESS          reduce using rule 74 (primary -> variable .)
    UNTIL           reduce using rule 74 (primary -> variable .)
    TERM            reduce using rule 74 (primary -> variable .)
    $end            reduce using rule 74 (primary -> variable .)
    COMMA           reduce using rule 74 (primary -> variable .)
    RBRACKET        reduce using rule 74 (primary -> variable .)
    RESCUE          reduce using rule 74 (primary -> variable .)
    HASH_ROCKET     reduce using rule 74 (primary -> variable .)
    RKEY            reduce using rule 74 (primary -> variable .)
    RPAREN          reduce using rule 74 (primary -> variable .)
    WHEN            reduce using rule 74 (primary -> variable .)
    LKEY            reduce using rule 74 (primary -> variable .)
    END             reduce using rule 74 (primary -> variable .)
    ELSIF           reduce using rule 74 (primary -> variable .)
    ELSE            reduce using rule 74 (primary -> variable .)
    ENSURE          reduce using rule 74 (primary -> variable .)
    THEN            reduce using rule 74 (primary -> variable .)
    DO              reduce using rule 74 (primary -> variable .)
    NOT_SYMBOL      reduce using rule 74 (primary -> variable .)
    COMPLEMENT_OP   reduce using rule 74 (primary -> variable .)
    DEFINED_OP      reduce using rule 74 (primary -> variable .)
    NUMBER          reduce using rule 74 (primary -> variable .)
    LPAREN          reduce using rule 74 (primary -> variable .)
    RETURN          reduce using rule 74 (primary -> variable .)
    YIELD           reduce using rule 74 (primary -> variable .)
    CASE            reduce using rule 74 (primary -> variable .)
    FOR             reduce using rule 74 (primary -> variable .)
    BEGIN           reduce using rule 74 (primary -> variable .)
    CLASS           reduce using rule 74 (primary -> variable .)
    MODULE          reduce using rule 74 (primary -> variable .)
    DEF             reduce using rule 74 (primary -> variable .)
    VAR_GLOBAL      reduce using rule 74 (primary -> variable .)
    VAR_LOCAL       reduce using rule 74 (primary -> variable .)
    VAR_INSTANCE    reduce using rule 74 (primary -> variable .)
    VAR_CLASS       reduce using rule 74 (primary -> variable .)
    SYMBOL          reduce using rule 74 (primary -> variable .)
    STRING          reduce using rule 74 (primary -> variable .)
    IDENTIFIER      reduce using rule 74 (primary -> variable .)
    SUPER           reduce using rule 74 (primary -> variable .)

  ! COMMA           [ reduce using rule 141 (lhs -> variable .) ]
  ! RBRACKET        [ reduce using rule 141 (lhs -> variable .) ]
  ! RPAREN          [ reduce using rule 141 (lhs -> variable .) ]
  ! OR_SYMBOL       [ reduce using rule 141 (lhs -> variable .) ]
  ! TIMES           [ reduce using rule 141 (lhs -> variable .) ]
  ! VAR_GLOBAL      [ reduce using rule 141 (lhs -> variable .) ]
  ! VAR_LOCAL       [ reduce using rule 141 (lhs -> variable .) ]
  ! VAR_INSTANCE    [ reduce using rule 141 (lhs -> variable .) ]
  ! VAR_CLASS       [ reduce using rule 141 (lhs -> variable .) ]
  ! LPAREN          [ reduce using rule 141 (lhs -> variable .) ]
  ! UNARY_OP        [ reduce using rule 141 (lhs -> variable .) ]
  ! LBRACKET        [ reduce using rule 141 (lhs -> variable .) ]
  ! LKEY            [ reduce using rule 141 (lhs -> variable .) ]
  ! RETURN          [ reduce using rule 141 (lhs -> variable .) ]
  ! YIELD           [ reduce using rule 141 (lhs -> variable .) ]
  ! DEFINED_OP      [ reduce using rule 141 (lhs -> variable .) ]
  ! IF              [ reduce using rule 141 (lhs -> variable .) ]
  ! UNLESS          [ reduce using rule 141 (lhs -> variable .) ]
  ! WHILE           [ reduce using rule 141 (lhs -> variable .) ]
  ! UNTIL           [ reduce using rule 141 (lhs -> variable .) ]
  ! CASE            [ reduce using rule 141 (lhs -> variable .) ]
  ! FOR             [ reduce using rule 141 (lhs -> variable .) ]
  ! BEGIN           [ reduce using rule 141 (lhs -> variable .) ]
  ! CLASS           [ reduce using rule 141 (lhs -> variable .) ]
  ! MODULE          [ reduce using rule 141 (lhs -> variable .) ]
  ! DEF             [ reduce using rule 141 (lhs -> variable .) ]
  ! NUMBER          [ reduce using rule 141 (lhs -> variable .) ]
  ! SYMBOL          [ reduce using rule 141 (lhs -> variable .) ]
  ! STRING          [ reduce using rule 141 (lhs -> variable .) ]
  ! IDENTIFIER      [ reduce using rule 141 (lhs -> variable .) ]
  ! SUPER           [ reduce using rule 141 (lhs -> variable .) ]


state 20

    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation
    (30) command -> primary . DOT operation call_args
    (31) command -> primary . UNARY_OP operation call_args
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (67) arg -> primary .

    LBRACKET        shift and go to state 147
    DOT             shift and go to state 148
    UNARY_OP        shift and go to state 149
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    IF              reduce using rule 67 (arg -> primary .)
    WHILE           reduce using rule 67 (arg -> primary .)
    UNLESS          reduce using rule 67 (arg -> primary .)
    UNTIL           reduce using rule 67 (arg -> primary .)
    TERM            reduce using rule 67 (arg -> primary .)
    $end            reduce using rule 67 (arg -> primary .)
    RESCUE          reduce using rule 67 (arg -> primary .)
    RPAREN          reduce using rule 67 (arg -> primary .)
    WHEN            reduce using rule 67 (arg -> primary .)
    RKEY            reduce using rule 67 (arg -> primary .)
    LKEY            reduce using rule 67 (arg -> primary .)
    END             reduce using rule 67 (arg -> primary .)
    ELSIF           reduce using rule 67 (arg -> primary .)
    ELSE            reduce using rule 67 (arg -> primary .)
    ENSURE          reduce using rule 67 (arg -> primary .)


state 21

    (213) operation -> IDENTIFIER .
    (214) operation -> IDENTIFIER . NOT_SYMBOL
    (215) operation -> IDENTIFIER . OPTIONAL_SYMBOL
    (186) literal -> IDENTIFIER .

  ! shift/reduce conflict for NOT_SYMBOL resolved as shift
  ! reduce/reduce conflict for LBRACKET resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for BINARY_AND_OP resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for UNLESS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for UNTIL resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for LKEY resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 186 (literal -> IDENTIFIER .)
    SUPER           reduce using rule 213 (operation -> IDENTIFIER .)
    COMPLEMENT_OP   reduce using rule 213 (operation -> IDENTIFIER .)
    DEFINED_OP      reduce using rule 213 (operation -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 213 (operation -> IDENTIFIER .)
    RETURN          reduce using rule 213 (operation -> IDENTIFIER .)
    YIELD           reduce using rule 213 (operation -> IDENTIFIER .)
    CASE            reduce using rule 213 (operation -> IDENTIFIER .)
    FOR             reduce using rule 213 (operation -> IDENTIFIER .)
    BEGIN           reduce using rule 213 (operation -> IDENTIFIER .)
    CLASS           reduce using rule 213 (operation -> IDENTIFIER .)
    MODULE          reduce using rule 213 (operation -> IDENTIFIER .)
    DEF             reduce using rule 213 (operation -> IDENTIFIER .)
    NUMBER          reduce using rule 213 (operation -> IDENTIFIER .)
    SYMBOL          reduce using rule 213 (operation -> IDENTIFIER .)
    STRING          reduce using rule 213 (operation -> IDENTIFIER .)
    VAR_GLOBAL      reduce using rule 213 (operation -> IDENTIFIER .)
    VAR_LOCAL       reduce using rule 213 (operation -> IDENTIFIER .)
    VAR_INSTANCE    reduce using rule 213 (operation -> IDENTIFIER .)
    VAR_CLASS       reduce using rule 213 (operation -> IDENTIFIER .)
    NOT_SYMBOL      shift and go to state 150
    OPTIONAL_SYMBOL shift and go to state 151
    LBRACKET        reduce using rule 186 (literal -> IDENTIFIER .)
    DOT             reduce using rule 186 (literal -> IDENTIFIER .)
    UNARY_OP        reduce using rule 186 (literal -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 186 (literal -> IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 186 (literal -> IDENTIFIER .)
    OR_SYMBOL       reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_XOR_OP   reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_AND_OP   reduce using rule 186 (literal -> IDENTIFIER .)
    COMBINED_COMPARISON_OP reduce using rule 186 (literal -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 186 (literal -> IDENTIFIER .)
    GREATERTHANEQUAL reduce using rule 186 (literal -> IDENTIFIER .)
    LESSERTHAN      reduce using rule 186 (literal -> IDENTIFIER .)
    LESSERTHANEQUAL reduce using rule 186 (literal -> IDENTIFIER .)
    EQUAL           reduce using rule 186 (literal -> IDENTIFIER .)
    CASE_EQUALITY   reduce using rule 186 (literal -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 186 (literal -> IDENTIFIER .)
    MATCHED_STRINGS_OP reduce using rule 186 (literal -> IDENTIFIER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 186 (literal -> IDENTIFIER .)
    AND             reduce using rule 186 (literal -> IDENTIFIER .)
    OR              reduce using rule 186 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 186 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 186 (literal -> IDENTIFIER .)
    TIMES           reduce using rule 186 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 186 (literal -> IDENTIFIER .)
    MOD             reduce using rule 186 (literal -> IDENTIFIER .)
    POW             reduce using rule 186 (literal -> IDENTIFIER .)
    IF              reduce using rule 186 (literal -> IDENTIFIER .)
    WHILE           reduce using rule 186 (literal -> IDENTIFIER .)
    UNLESS          reduce using rule 186 (literal -> IDENTIFIER .)
    UNTIL           reduce using rule 186 (literal -> IDENTIFIER .)
    TERM            reduce using rule 186 (literal -> IDENTIFIER .)
    $end            reduce using rule 186 (literal -> IDENTIFIER .)
    THEN            reduce using rule 186 (literal -> IDENTIFIER .)
    DO              reduce using rule 186 (literal -> IDENTIFIER .)
    RESCUE          reduce using rule 186 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 186 (literal -> IDENTIFIER .)
    HASH_ROCKET     reduce using rule 186 (literal -> IDENTIFIER .)
    RPAREN          reduce using rule 186 (literal -> IDENTIFIER .)
    WHEN            reduce using rule 186 (literal -> IDENTIFIER .)
    RKEY            reduce using rule 186 (literal -> IDENTIFIER .)
    LKEY            reduce using rule 186 (literal -> IDENTIFIER .)
    END             reduce using rule 186 (literal -> IDENTIFIER .)
    ELSIF           reduce using rule 186 (literal -> IDENTIFIER .)
    ELSE            reduce using rule 186 (literal -> IDENTIFIER .)
    ENSURE          reduce using rule 186 (literal -> IDENTIFIER .)
    RBRACKET        reduce using rule 186 (literal -> IDENTIFIER .)
    LPAREN          reduce using rule 186 (literal -> IDENTIFIER .)

  ! LBRACKET        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BINARY_AND_OP   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NOT_SYMBOL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNARY_OP        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LKEY            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNLESS          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNTIL           [ reduce using rule 213 (operation -> IDENTIFIER .) ]


state 22

    (18) expr -> mlhs . = mrhs

    =               shift and go to state 152


state 23

    (19) expr -> RETURN . call_args
    (87) primary -> RETURN .
    (88) primary -> RETURN . LPAREN RPAREN
    (89) primary -> RETURN . LPAREN call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    DOT             reduce using rule 87 (primary -> RETURN .)
    RANGE_INCLUSIVE reduce using rule 87 (primary -> RETURN .)
    RANGE_EXCLUSIVE reduce using rule 87 (primary -> RETURN .)
    OR_SYMBOL       reduce using rule 87 (primary -> RETURN .)
    BINARY_XOR_OP   reduce using rule 87 (primary -> RETURN .)
    COMBINED_COMPARISON_OP reduce using rule 87 (primary -> RETURN .)
    GREATERTHAN     reduce using rule 87 (primary -> RETURN .)
    GREATERTHANEQUAL reduce using rule 87 (primary -> RETURN .)
    LESSERTHAN      reduce using rule 87 (primary -> RETURN .)
    LESSERTHANEQUAL reduce using rule 87 (primary -> RETURN .)
    EQUAL           reduce using rule 87 (primary -> RETURN .)
    CASE_EQUALITY   reduce using rule 87 (primary -> RETURN .)
    NOTEQUAL        reduce using rule 87 (primary -> RETURN .)
    MATCHED_STRINGS_OP reduce using rule 87 (primary -> RETURN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 87 (primary -> RETURN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 87 (primary -> RETURN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 87 (primary -> RETURN .)
    AND             reduce using rule 87 (primary -> RETURN .)
    OR              reduce using rule 87 (primary -> RETURN .)
    DIVIDE          reduce using rule 87 (primary -> RETURN .)
    MOD             reduce using rule 87 (primary -> RETURN .)
    POW             reduce using rule 87 (primary -> RETURN .)
    TERM            reduce using rule 87 (primary -> RETURN .)
    $end            reduce using rule 87 (primary -> RETURN .)
    THEN            reduce using rule 87 (primary -> RETURN .)
    DO              reduce using rule 87 (primary -> RETURN .)
    RESCUE          reduce using rule 87 (primary -> RETURN .)
    RPAREN          reduce using rule 87 (primary -> RETURN .)
    WHEN            reduce using rule 87 (primary -> RETURN .)
    RKEY            reduce using rule 87 (primary -> RETURN .)
    END             reduce using rule 87 (primary -> RETURN .)
    ELSIF           reduce using rule 87 (primary -> RETURN .)
    ELSE            reduce using rule 87 (primary -> RETURN .)
    ENSURE          reduce using rule 87 (primary -> RETURN .)
    COMMA           reduce using rule 87 (primary -> RETURN .)
    HASH_ROCKET     reduce using rule 87 (primary -> RETURN .)
    LPAREN          shift and go to state 154
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LBRACKET        [ reduce using rule 87 (primary -> RETURN .) ]
  ! UNARY_OP        [ reduce using rule 87 (primary -> RETURN .) ]
  ! BINARY_AND_OP   [ reduce using rule 87 (primary -> RETURN .) ]
  ! PLUS            [ reduce using rule 87 (primary -> RETURN .) ]
  ! MINUS           [ reduce using rule 87 (primary -> RETURN .) ]
  ! TIMES           [ reduce using rule 87 (primary -> RETURN .) ]
  ! IF              [ reduce using rule 87 (primary -> RETURN .) ]
  ! WHILE           [ reduce using rule 87 (primary -> RETURN .) ]
  ! UNLESS          [ reduce using rule 87 (primary -> RETURN .) ]
  ! UNTIL           [ reduce using rule 87 (primary -> RETURN .) ]
  ! LKEY            [ reduce using rule 87 (primary -> RETURN .) ]

    call_args                      shift and go to state 153
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 24

    (20) expr -> YIELD . call_args
    (90) primary -> YIELD .
    (91) primary -> YIELD . LPAREN RPAREN
    (92) primary -> YIELD . LPAREN call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    DOT             reduce using rule 90 (primary -> YIELD .)
    RANGE_INCLUSIVE reduce using rule 90 (primary -> YIELD .)
    RANGE_EXCLUSIVE reduce using rule 90 (primary -> YIELD .)
    OR_SYMBOL       reduce using rule 90 (primary -> YIELD .)
    BINARY_XOR_OP   reduce using rule 90 (primary -> YIELD .)
    COMBINED_COMPARISON_OP reduce using rule 90 (primary -> YIELD .)
    GREATERTHAN     reduce using rule 90 (primary -> YIELD .)
    GREATERTHANEQUAL reduce using rule 90 (primary -> YIELD .)
    LESSERTHAN      reduce using rule 90 (primary -> YIELD .)
    LESSERTHANEQUAL reduce using rule 90 (primary -> YIELD .)
    EQUAL           reduce using rule 90 (primary -> YIELD .)
    CASE_EQUALITY   reduce using rule 90 (primary -> YIELD .)
    NOTEQUAL        reduce using rule 90 (primary -> YIELD .)
    MATCHED_STRINGS_OP reduce using rule 90 (primary -> YIELD .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 90 (primary -> YIELD .)
    BINARY_LEFT_SHIFT_OP reduce using rule 90 (primary -> YIELD .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 90 (primary -> YIELD .)
    AND             reduce using rule 90 (primary -> YIELD .)
    OR              reduce using rule 90 (primary -> YIELD .)
    DIVIDE          reduce using rule 90 (primary -> YIELD .)
    MOD             reduce using rule 90 (primary -> YIELD .)
    POW             reduce using rule 90 (primary -> YIELD .)
    TERM            reduce using rule 90 (primary -> YIELD .)
    $end            reduce using rule 90 (primary -> YIELD .)
    THEN            reduce using rule 90 (primary -> YIELD .)
    DO              reduce using rule 90 (primary -> YIELD .)
    RESCUE          reduce using rule 90 (primary -> YIELD .)
    RPAREN          reduce using rule 90 (primary -> YIELD .)
    WHEN            reduce using rule 90 (primary -> YIELD .)
    RKEY            reduce using rule 90 (primary -> YIELD .)
    END             reduce using rule 90 (primary -> YIELD .)
    ELSIF           reduce using rule 90 (primary -> YIELD .)
    ELSE            reduce using rule 90 (primary -> YIELD .)
    ENSURE          reduce using rule 90 (primary -> YIELD .)
    COMMA           reduce using rule 90 (primary -> YIELD .)
    HASH_ROCKET     reduce using rule 90 (primary -> YIELD .)
    LPAREN          shift and go to state 161
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LBRACKET        [ reduce using rule 90 (primary -> YIELD .) ]
  ! UNARY_OP        [ reduce using rule 90 (primary -> YIELD .) ]
  ! BINARY_AND_OP   [ reduce using rule 90 (primary -> YIELD .) ]
  ! PLUS            [ reduce using rule 90 (primary -> YIELD .) ]
  ! MINUS           [ reduce using rule 90 (primary -> YIELD .) ]
  ! TIMES           [ reduce using rule 90 (primary -> YIELD .) ]
  ! IF              [ reduce using rule 90 (primary -> YIELD .) ]
  ! WHILE           [ reduce using rule 90 (primary -> YIELD .) ]
  ! UNLESS          [ reduce using rule 90 (primary -> YIELD .) ]
  ! UNTIL           [ reduce using rule 90 (primary -> YIELD .) ]
  ! LKEY            [ reduce using rule 90 (primary -> YIELD .) ]

    call_args                      shift and go to state 160
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 25

    (23) expr -> NOT . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 162
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 26

    (25) expr -> NOT_SYMBOL . command
    (60) arg -> NOT_SYMBOL . arg
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    command                        shift and go to state 163
    arg                            shift and go to state 164
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 27

    (26) expr -> arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 26 (expr -> arg .)
    WHILE           reduce using rule 26 (expr -> arg .)
    UNLESS          reduce using rule 26 (expr -> arg .)
    UNTIL           reduce using rule 26 (expr -> arg .)
    TERM            reduce using rule 26 (expr -> arg .)
    $end            reduce using rule 26 (expr -> arg .)
    THEN            reduce using rule 26 (expr -> arg .)
    DO              reduce using rule 26 (expr -> arg .)
    RESCUE          reduce using rule 26 (expr -> arg .)
    RPAREN          reduce using rule 26 (expr -> arg .)
    WHEN            reduce using rule 26 (expr -> arg .)
    RKEY            reduce using rule 26 (expr -> arg .)
    LKEY            reduce using rule 26 (expr -> arg .)
    END             reduce using rule 26 (expr -> arg .)
    ELSIF           reduce using rule 26 (expr -> arg .)
    ELSE            reduce using rule 26 (expr -> arg .)
    ENSURE          reduce using rule 26 (expr -> arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 26 (expr -> arg .) ]
  ! OR              [ reduce using rule 26 (expr -> arg .) ]


state 28

    (33) function -> operation . LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (29) command -> operation . call_args
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    LBRACKET        shift and go to state 190
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    operation                      shift and go to state 113
    call_args                      shift and go to state 191
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 29

    (72) primary -> LPAREN . compstmt RPAREN
    (154) mlhs_item -> LPAREN . mlhs RPAREN
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    TIMES           shift and go to state 44
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    LPAREN          shift and go to state 116
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 192
    mlhs                           shift and go to state 193
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 194
    call                           shift and go to state 5
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    math_operations                shift and go to state 45

state 30

    (76) primary -> UNARY_OP . IDENTIFIER

    IDENTIFIER      shift and go to state 195


state 31

    (38) function -> SUPER . LPAREN call_args RPAREN
    (39) function -> SUPER .
    (32) command -> SUPER . call_args
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    LPAREN          shift and go to state 196
    DO              reduce using rule 39 (function -> SUPER .)
    TERM            reduce using rule 39 (function -> SUPER .)
    DOT             reduce using rule 39 (function -> SUPER .)
    RANGE_INCLUSIVE reduce using rule 39 (function -> SUPER .)
    RANGE_EXCLUSIVE reduce using rule 39 (function -> SUPER .)
    OR_SYMBOL       reduce using rule 39 (function -> SUPER .)
    BINARY_XOR_OP   reduce using rule 39 (function -> SUPER .)
    COMBINED_COMPARISON_OP reduce using rule 39 (function -> SUPER .)
    GREATERTHAN     reduce using rule 39 (function -> SUPER .)
    GREATERTHANEQUAL reduce using rule 39 (function -> SUPER .)
    LESSERTHAN      reduce using rule 39 (function -> SUPER .)
    LESSERTHANEQUAL reduce using rule 39 (function -> SUPER .)
    EQUAL           reduce using rule 39 (function -> SUPER .)
    CASE_EQUALITY   reduce using rule 39 (function -> SUPER .)
    NOTEQUAL        reduce using rule 39 (function -> SUPER .)
    MATCHED_STRINGS_OP reduce using rule 39 (function -> SUPER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 39 (function -> SUPER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 39 (function -> SUPER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 39 (function -> SUPER .)
    AND             reduce using rule 39 (function -> SUPER .)
    OR              reduce using rule 39 (function -> SUPER .)
    DIVIDE          reduce using rule 39 (function -> SUPER .)
    MOD             reduce using rule 39 (function -> SUPER .)
    POW             reduce using rule 39 (function -> SUPER .)
    $end            reduce using rule 39 (function -> SUPER .)
    RESCUE          reduce using rule 39 (function -> SUPER .)
    RPAREN          reduce using rule 39 (function -> SUPER .)
    WHEN            reduce using rule 39 (function -> SUPER .)
    RKEY            reduce using rule 39 (function -> SUPER .)
    COMMA           reduce using rule 39 (function -> SUPER .)
    HASH_ROCKET     reduce using rule 39 (function -> SUPER .)
    END             reduce using rule 39 (function -> SUPER .)
    ELSIF           reduce using rule 39 (function -> SUPER .)
    ELSE            reduce using rule 39 (function -> SUPER .)
    ENSURE          reduce using rule 39 (function -> SUPER .)
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 39 (function -> SUPER .) ]
  ! LBRACKET        [ reduce using rule 39 (function -> SUPER .) ]
  ! UNARY_OP        [ reduce using rule 39 (function -> SUPER .) ]
  ! BINARY_AND_OP   [ reduce using rule 39 (function -> SUPER .) ]
  ! PLUS            [ reduce using rule 39 (function -> SUPER .) ]
  ! MINUS           [ reduce using rule 39 (function -> SUPER .) ]
  ! TIMES           [ reduce using rule 39 (function -> SUPER .) ]
  ! IF              [ reduce using rule 39 (function -> SUPER .) ]
  ! WHILE           [ reduce using rule 39 (function -> SUPER .) ]
  ! UNLESS          [ reduce using rule 39 (function -> SUPER .) ]
  ! UNTIL           [ reduce using rule 39 (function -> SUPER .) ]
  ! LPAREN          [ reduce using rule 39 (function -> SUPER .) ]

    call_args                      shift and go to state 197
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 32

    (68) variable -> VAR_GLOBAL .

    =               reduce using rule 68 (variable -> VAR_GLOBAL .)
    PLUS_EQUAL      reduce using rule 68 (variable -> VAR_GLOBAL .)
    MINUS_EQUAL     reduce using rule 68 (variable -> VAR_GLOBAL .)
    TIMES_EQUAL     reduce using rule 68 (variable -> VAR_GLOBAL .)
    DIVIDE_EQUAL    reduce using rule 68 (variable -> VAR_GLOBAL .)
    MOD_EQUAL       reduce using rule 68 (variable -> VAR_GLOBAL .)
    POW_EQUAL       reduce using rule 68 (variable -> VAR_GLOBAL .)
    SINGLE_AND_EQUAL reduce using rule 68 (variable -> VAR_GLOBAL .)
    SINGLE_OR_EQUAL reduce using rule 68 (variable -> VAR_GLOBAL .)
    XOR_EQUAL       reduce using rule 68 (variable -> VAR_GLOBAL .)
    BINARY_LEFT_EQUAL reduce using rule 68 (variable -> VAR_GLOBAL .)
    BINARY_RIGHT_EQUAL reduce using rule 68 (variable -> VAR_GLOBAL .)
    AND_EQUAL       reduce using rule 68 (variable -> VAR_GLOBAL .)
    OR_EQUAL        reduce using rule 68 (variable -> VAR_GLOBAL .)
    COMMA           reduce using rule 68 (variable -> VAR_GLOBAL .)
    LBRACKET        reduce using rule 68 (variable -> VAR_GLOBAL .)
    DOT             reduce using rule 68 (variable -> VAR_GLOBAL .)
    UNARY_OP        reduce using rule 68 (variable -> VAR_GLOBAL .)
    RANGE_INCLUSIVE reduce using rule 68 (variable -> VAR_GLOBAL .)
    RANGE_EXCLUSIVE reduce using rule 68 (variable -> VAR_GLOBAL .)
    OR_SYMBOL       reduce using rule 68 (variable -> VAR_GLOBAL .)
    BINARY_XOR_OP   reduce using rule 68 (variable -> VAR_GLOBAL .)
    BINARY_AND_OP   reduce using rule 68 (variable -> VAR_GLOBAL .)
    COMBINED_COMPARISON_OP reduce using rule 68 (variable -> VAR_GLOBAL .)
    GREATERTHAN     reduce using rule 68 (variable -> VAR_GLOBAL .)
    GREATERTHANEQUAL reduce using rule 68 (variable -> VAR_GLOBAL .)
    LESSERTHAN      reduce using rule 68 (variable -> VAR_GLOBAL .)
    LESSERTHANEQUAL reduce using rule 68 (variable -> VAR_GLOBAL .)
    EQUAL           reduce using rule 68 (variable -> VAR_GLOBAL .)
    CASE_EQUALITY   reduce using rule 68 (variable -> VAR_GLOBAL .)
    NOTEQUAL        reduce using rule 68 (variable -> VAR_GLOBAL .)
    MATCHED_STRINGS_OP reduce using rule 68 (variable -> VAR_GLOBAL .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 68 (variable -> VAR_GLOBAL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 68 (variable -> VAR_GLOBAL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 68 (variable -> VAR_GLOBAL .)
    AND             reduce using rule 68 (variable -> VAR_GLOBAL .)
    OR              reduce using rule 68 (variable -> VAR_GLOBAL .)
    PLUS            reduce using rule 68 (variable -> VAR_GLOBAL .)
    MINUS           reduce using rule 68 (variable -> VAR_GLOBAL .)
    TIMES           reduce using rule 68 (variable -> VAR_GLOBAL .)
    DIVIDE          reduce using rule 68 (variable -> VAR_GLOBAL .)
    MOD             reduce using rule 68 (variable -> VAR_GLOBAL .)
    POW             reduce using rule 68 (variable -> VAR_GLOBAL .)
    IF              reduce using rule 68 (variable -> VAR_GLOBAL .)
    WHILE           reduce using rule 68 (variable -> VAR_GLOBAL .)
    UNLESS          reduce using rule 68 (variable -> VAR_GLOBAL .)
    UNTIL           reduce using rule 68 (variable -> VAR_GLOBAL .)
    TERM            reduce using rule 68 (variable -> VAR_GLOBAL .)
    $end            reduce using rule 68 (variable -> VAR_GLOBAL .)
    RBRACKET        reduce using rule 68 (variable -> VAR_GLOBAL .)
    THEN            reduce using rule 68 (variable -> VAR_GLOBAL .)
    DO              reduce using rule 68 (variable -> VAR_GLOBAL .)
    RESCUE          reduce using rule 68 (variable -> VAR_GLOBAL .)
    HASH_ROCKET     reduce using rule 68 (variable -> VAR_GLOBAL .)
    RKEY            reduce using rule 68 (variable -> VAR_GLOBAL .)
    RPAREN          reduce using rule 68 (variable -> VAR_GLOBAL .)
    WHEN            reduce using rule 68 (variable -> VAR_GLOBAL .)
    LKEY            reduce using rule 68 (variable -> VAR_GLOBAL .)
    END             reduce using rule 68 (variable -> VAR_GLOBAL .)
    ELSIF           reduce using rule 68 (variable -> VAR_GLOBAL .)
    ELSE            reduce using rule 68 (variable -> VAR_GLOBAL .)
    ENSURE          reduce using rule 68 (variable -> VAR_GLOBAL .)
    IN              reduce using rule 68 (variable -> VAR_GLOBAL .)
    NOT_SYMBOL      reduce using rule 68 (variable -> VAR_GLOBAL .)
    COMPLEMENT_OP   reduce using rule 68 (variable -> VAR_GLOBAL .)
    DEFINED_OP      reduce using rule 68 (variable -> VAR_GLOBAL .)
    NUMBER          reduce using rule 68 (variable -> VAR_GLOBAL .)
    LPAREN          reduce using rule 68 (variable -> VAR_GLOBAL .)
    RETURN          reduce using rule 68 (variable -> VAR_GLOBAL .)
    YIELD           reduce using rule 68 (variable -> VAR_GLOBAL .)
    CASE            reduce using rule 68 (variable -> VAR_GLOBAL .)
    FOR             reduce using rule 68 (variable -> VAR_GLOBAL .)
    BEGIN           reduce using rule 68 (variable -> VAR_GLOBAL .)
    CLASS           reduce using rule 68 (variable -> VAR_GLOBAL .)
    MODULE          reduce using rule 68 (variable -> VAR_GLOBAL .)
    DEF             reduce using rule 68 (variable -> VAR_GLOBAL .)
    VAR_GLOBAL      reduce using rule 68 (variable -> VAR_GLOBAL .)
    VAR_LOCAL       reduce using rule 68 (variable -> VAR_GLOBAL .)
    VAR_INSTANCE    reduce using rule 68 (variable -> VAR_GLOBAL .)
    VAR_CLASS       reduce using rule 68 (variable -> VAR_GLOBAL .)
    SYMBOL          reduce using rule 68 (variable -> VAR_GLOBAL .)
    STRING          reduce using rule 68 (variable -> VAR_GLOBAL .)
    IDENTIFIER      reduce using rule 68 (variable -> VAR_GLOBAL .)
    SUPER           reduce using rule 68 (variable -> VAR_GLOBAL .)


state 33

    (69) variable -> VAR_LOCAL .

    =               reduce using rule 69 (variable -> VAR_LOCAL .)
    PLUS_EQUAL      reduce using rule 69 (variable -> VAR_LOCAL .)
    MINUS_EQUAL     reduce using rule 69 (variable -> VAR_LOCAL .)
    TIMES_EQUAL     reduce using rule 69 (variable -> VAR_LOCAL .)
    DIVIDE_EQUAL    reduce using rule 69 (variable -> VAR_LOCAL .)
    MOD_EQUAL       reduce using rule 69 (variable -> VAR_LOCAL .)
    POW_EQUAL       reduce using rule 69 (variable -> VAR_LOCAL .)
    SINGLE_AND_EQUAL reduce using rule 69 (variable -> VAR_LOCAL .)
    SINGLE_OR_EQUAL reduce using rule 69 (variable -> VAR_LOCAL .)
    XOR_EQUAL       reduce using rule 69 (variable -> VAR_LOCAL .)
    BINARY_LEFT_EQUAL reduce using rule 69 (variable -> VAR_LOCAL .)
    BINARY_RIGHT_EQUAL reduce using rule 69 (variable -> VAR_LOCAL .)
    AND_EQUAL       reduce using rule 69 (variable -> VAR_LOCAL .)
    OR_EQUAL        reduce using rule 69 (variable -> VAR_LOCAL .)
    COMMA           reduce using rule 69 (variable -> VAR_LOCAL .)
    LBRACKET        reduce using rule 69 (variable -> VAR_LOCAL .)
    DOT             reduce using rule 69 (variable -> VAR_LOCAL .)
    UNARY_OP        reduce using rule 69 (variable -> VAR_LOCAL .)
    RANGE_INCLUSIVE reduce using rule 69 (variable -> VAR_LOCAL .)
    RANGE_EXCLUSIVE reduce using rule 69 (variable -> VAR_LOCAL .)
    OR_SYMBOL       reduce using rule 69 (variable -> VAR_LOCAL .)
    BINARY_XOR_OP   reduce using rule 69 (variable -> VAR_LOCAL .)
    BINARY_AND_OP   reduce using rule 69 (variable -> VAR_LOCAL .)
    COMBINED_COMPARISON_OP reduce using rule 69 (variable -> VAR_LOCAL .)
    GREATERTHAN     reduce using rule 69 (variable -> VAR_LOCAL .)
    GREATERTHANEQUAL reduce using rule 69 (variable -> VAR_LOCAL .)
    LESSERTHAN      reduce using rule 69 (variable -> VAR_LOCAL .)
    LESSERTHANEQUAL reduce using rule 69 (variable -> VAR_LOCAL .)
    EQUAL           reduce using rule 69 (variable -> VAR_LOCAL .)
    CASE_EQUALITY   reduce using rule 69 (variable -> VAR_LOCAL .)
    NOTEQUAL        reduce using rule 69 (variable -> VAR_LOCAL .)
    MATCHED_STRINGS_OP reduce using rule 69 (variable -> VAR_LOCAL .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 69 (variable -> VAR_LOCAL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 69 (variable -> VAR_LOCAL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 69 (variable -> VAR_LOCAL .)
    AND             reduce using rule 69 (variable -> VAR_LOCAL .)
    OR              reduce using rule 69 (variable -> VAR_LOCAL .)
    PLUS            reduce using rule 69 (variable -> VAR_LOCAL .)
    MINUS           reduce using rule 69 (variable -> VAR_LOCAL .)
    TIMES           reduce using rule 69 (variable -> VAR_LOCAL .)
    DIVIDE          reduce using rule 69 (variable -> VAR_LOCAL .)
    MOD             reduce using rule 69 (variable -> VAR_LOCAL .)
    POW             reduce using rule 69 (variable -> VAR_LOCAL .)
    IF              reduce using rule 69 (variable -> VAR_LOCAL .)
    WHILE           reduce using rule 69 (variable -> VAR_LOCAL .)
    UNLESS          reduce using rule 69 (variable -> VAR_LOCAL .)
    UNTIL           reduce using rule 69 (variable -> VAR_LOCAL .)
    TERM            reduce using rule 69 (variable -> VAR_LOCAL .)
    $end            reduce using rule 69 (variable -> VAR_LOCAL .)
    RBRACKET        reduce using rule 69 (variable -> VAR_LOCAL .)
    THEN            reduce using rule 69 (variable -> VAR_LOCAL .)
    DO              reduce using rule 69 (variable -> VAR_LOCAL .)
    RESCUE          reduce using rule 69 (variable -> VAR_LOCAL .)
    HASH_ROCKET     reduce using rule 69 (variable -> VAR_LOCAL .)
    RKEY            reduce using rule 69 (variable -> VAR_LOCAL .)
    RPAREN          reduce using rule 69 (variable -> VAR_LOCAL .)
    WHEN            reduce using rule 69 (variable -> VAR_LOCAL .)
    LKEY            reduce using rule 69 (variable -> VAR_LOCAL .)
    END             reduce using rule 69 (variable -> VAR_LOCAL .)
    ELSIF           reduce using rule 69 (variable -> VAR_LOCAL .)
    ELSE            reduce using rule 69 (variable -> VAR_LOCAL .)
    ENSURE          reduce using rule 69 (variable -> VAR_LOCAL .)
    IN              reduce using rule 69 (variable -> VAR_LOCAL .)
    NOT_SYMBOL      reduce using rule 69 (variable -> VAR_LOCAL .)
    COMPLEMENT_OP   reduce using rule 69 (variable -> VAR_LOCAL .)
    DEFINED_OP      reduce using rule 69 (variable -> VAR_LOCAL .)
    NUMBER          reduce using rule 69 (variable -> VAR_LOCAL .)
    LPAREN          reduce using rule 69 (variable -> VAR_LOCAL .)
    RETURN          reduce using rule 69 (variable -> VAR_LOCAL .)
    YIELD           reduce using rule 69 (variable -> VAR_LOCAL .)
    CASE            reduce using rule 69 (variable -> VAR_LOCAL .)
    FOR             reduce using rule 69 (variable -> VAR_LOCAL .)
    BEGIN           reduce using rule 69 (variable -> VAR_LOCAL .)
    CLASS           reduce using rule 69 (variable -> VAR_LOCAL .)
    MODULE          reduce using rule 69 (variable -> VAR_LOCAL .)
    DEF             reduce using rule 69 (variable -> VAR_LOCAL .)
    VAR_GLOBAL      reduce using rule 69 (variable -> VAR_LOCAL .)
    VAR_LOCAL       reduce using rule 69 (variable -> VAR_LOCAL .)
    VAR_INSTANCE    reduce using rule 69 (variable -> VAR_LOCAL .)
    VAR_CLASS       reduce using rule 69 (variable -> VAR_LOCAL .)
    SYMBOL          reduce using rule 69 (variable -> VAR_LOCAL .)
    STRING          reduce using rule 69 (variable -> VAR_LOCAL .)
    IDENTIFIER      reduce using rule 69 (variable -> VAR_LOCAL .)
    SUPER           reduce using rule 69 (variable -> VAR_LOCAL .)


state 34

    (70) variable -> VAR_INSTANCE .

    =               reduce using rule 70 (variable -> VAR_INSTANCE .)
    PLUS_EQUAL      reduce using rule 70 (variable -> VAR_INSTANCE .)
    MINUS_EQUAL     reduce using rule 70 (variable -> VAR_INSTANCE .)
    TIMES_EQUAL     reduce using rule 70 (variable -> VAR_INSTANCE .)
    DIVIDE_EQUAL    reduce using rule 70 (variable -> VAR_INSTANCE .)
    MOD_EQUAL       reduce using rule 70 (variable -> VAR_INSTANCE .)
    POW_EQUAL       reduce using rule 70 (variable -> VAR_INSTANCE .)
    SINGLE_AND_EQUAL reduce using rule 70 (variable -> VAR_INSTANCE .)
    SINGLE_OR_EQUAL reduce using rule 70 (variable -> VAR_INSTANCE .)
    XOR_EQUAL       reduce using rule 70 (variable -> VAR_INSTANCE .)
    BINARY_LEFT_EQUAL reduce using rule 70 (variable -> VAR_INSTANCE .)
    BINARY_RIGHT_EQUAL reduce using rule 70 (variable -> VAR_INSTANCE .)
    AND_EQUAL       reduce using rule 70 (variable -> VAR_INSTANCE .)
    OR_EQUAL        reduce using rule 70 (variable -> VAR_INSTANCE .)
    COMMA           reduce using rule 70 (variable -> VAR_INSTANCE .)
    LBRACKET        reduce using rule 70 (variable -> VAR_INSTANCE .)
    DOT             reduce using rule 70 (variable -> VAR_INSTANCE .)
    UNARY_OP        reduce using rule 70 (variable -> VAR_INSTANCE .)
    RANGE_INCLUSIVE reduce using rule 70 (variable -> VAR_INSTANCE .)
    RANGE_EXCLUSIVE reduce using rule 70 (variable -> VAR_INSTANCE .)
    OR_SYMBOL       reduce using rule 70 (variable -> VAR_INSTANCE .)
    BINARY_XOR_OP   reduce using rule 70 (variable -> VAR_INSTANCE .)
    BINARY_AND_OP   reduce using rule 70 (variable -> VAR_INSTANCE .)
    COMBINED_COMPARISON_OP reduce using rule 70 (variable -> VAR_INSTANCE .)
    GREATERTHAN     reduce using rule 70 (variable -> VAR_INSTANCE .)
    GREATERTHANEQUAL reduce using rule 70 (variable -> VAR_INSTANCE .)
    LESSERTHAN      reduce using rule 70 (variable -> VAR_INSTANCE .)
    LESSERTHANEQUAL reduce using rule 70 (variable -> VAR_INSTANCE .)
    EQUAL           reduce using rule 70 (variable -> VAR_INSTANCE .)
    CASE_EQUALITY   reduce using rule 70 (variable -> VAR_INSTANCE .)
    NOTEQUAL        reduce using rule 70 (variable -> VAR_INSTANCE .)
    MATCHED_STRINGS_OP reduce using rule 70 (variable -> VAR_INSTANCE .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 70 (variable -> VAR_INSTANCE .)
    BINARY_LEFT_SHIFT_OP reduce using rule 70 (variable -> VAR_INSTANCE .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 70 (variable -> VAR_INSTANCE .)
    AND             reduce using rule 70 (variable -> VAR_INSTANCE .)
    OR              reduce using rule 70 (variable -> VAR_INSTANCE .)
    PLUS            reduce using rule 70 (variable -> VAR_INSTANCE .)
    MINUS           reduce using rule 70 (variable -> VAR_INSTANCE .)
    TIMES           reduce using rule 70 (variable -> VAR_INSTANCE .)
    DIVIDE          reduce using rule 70 (variable -> VAR_INSTANCE .)
    MOD             reduce using rule 70 (variable -> VAR_INSTANCE .)
    POW             reduce using rule 70 (variable -> VAR_INSTANCE .)
    IF              reduce using rule 70 (variable -> VAR_INSTANCE .)
    WHILE           reduce using rule 70 (variable -> VAR_INSTANCE .)
    UNLESS          reduce using rule 70 (variable -> VAR_INSTANCE .)
    UNTIL           reduce using rule 70 (variable -> VAR_INSTANCE .)
    TERM            reduce using rule 70 (variable -> VAR_INSTANCE .)
    $end            reduce using rule 70 (variable -> VAR_INSTANCE .)
    RBRACKET        reduce using rule 70 (variable -> VAR_INSTANCE .)
    THEN            reduce using rule 70 (variable -> VAR_INSTANCE .)
    DO              reduce using rule 70 (variable -> VAR_INSTANCE .)
    RESCUE          reduce using rule 70 (variable -> VAR_INSTANCE .)
    HASH_ROCKET     reduce using rule 70 (variable -> VAR_INSTANCE .)
    RKEY            reduce using rule 70 (variable -> VAR_INSTANCE .)
    RPAREN          reduce using rule 70 (variable -> VAR_INSTANCE .)
    WHEN            reduce using rule 70 (variable -> VAR_INSTANCE .)
    LKEY            reduce using rule 70 (variable -> VAR_INSTANCE .)
    END             reduce using rule 70 (variable -> VAR_INSTANCE .)
    ELSIF           reduce using rule 70 (variable -> VAR_INSTANCE .)
    ELSE            reduce using rule 70 (variable -> VAR_INSTANCE .)
    ENSURE          reduce using rule 70 (variable -> VAR_INSTANCE .)
    IN              reduce using rule 70 (variable -> VAR_INSTANCE .)
    NOT_SYMBOL      reduce using rule 70 (variable -> VAR_INSTANCE .)
    COMPLEMENT_OP   reduce using rule 70 (variable -> VAR_INSTANCE .)
    DEFINED_OP      reduce using rule 70 (variable -> VAR_INSTANCE .)
    NUMBER          reduce using rule 70 (variable -> VAR_INSTANCE .)
    LPAREN          reduce using rule 70 (variable -> VAR_INSTANCE .)
    RETURN          reduce using rule 70 (variable -> VAR_INSTANCE .)
    YIELD           reduce using rule 70 (variable -> VAR_INSTANCE .)
    CASE            reduce using rule 70 (variable -> VAR_INSTANCE .)
    FOR             reduce using rule 70 (variable -> VAR_INSTANCE .)
    BEGIN           reduce using rule 70 (variable -> VAR_INSTANCE .)
    CLASS           reduce using rule 70 (variable -> VAR_INSTANCE .)
    MODULE          reduce using rule 70 (variable -> VAR_INSTANCE .)
    DEF             reduce using rule 70 (variable -> VAR_INSTANCE .)
    VAR_GLOBAL      reduce using rule 70 (variable -> VAR_INSTANCE .)
    VAR_LOCAL       reduce using rule 70 (variable -> VAR_INSTANCE .)
    VAR_INSTANCE    reduce using rule 70 (variable -> VAR_INSTANCE .)
    VAR_CLASS       reduce using rule 70 (variable -> VAR_INSTANCE .)
    SYMBOL          reduce using rule 70 (variable -> VAR_INSTANCE .)
    STRING          reduce using rule 70 (variable -> VAR_INSTANCE .)
    IDENTIFIER      reduce using rule 70 (variable -> VAR_INSTANCE .)
    SUPER           reduce using rule 70 (variable -> VAR_INSTANCE .)


state 35

    (71) variable -> VAR_CLASS .

    =               reduce using rule 71 (variable -> VAR_CLASS .)
    PLUS_EQUAL      reduce using rule 71 (variable -> VAR_CLASS .)
    MINUS_EQUAL     reduce using rule 71 (variable -> VAR_CLASS .)
    TIMES_EQUAL     reduce using rule 71 (variable -> VAR_CLASS .)
    DIVIDE_EQUAL    reduce using rule 71 (variable -> VAR_CLASS .)
    MOD_EQUAL       reduce using rule 71 (variable -> VAR_CLASS .)
    POW_EQUAL       reduce using rule 71 (variable -> VAR_CLASS .)
    SINGLE_AND_EQUAL reduce using rule 71 (variable -> VAR_CLASS .)
    SINGLE_OR_EQUAL reduce using rule 71 (variable -> VAR_CLASS .)
    XOR_EQUAL       reduce using rule 71 (variable -> VAR_CLASS .)
    BINARY_LEFT_EQUAL reduce using rule 71 (variable -> VAR_CLASS .)
    BINARY_RIGHT_EQUAL reduce using rule 71 (variable -> VAR_CLASS .)
    AND_EQUAL       reduce using rule 71 (variable -> VAR_CLASS .)
    OR_EQUAL        reduce using rule 71 (variable -> VAR_CLASS .)
    COMMA           reduce using rule 71 (variable -> VAR_CLASS .)
    LBRACKET        reduce using rule 71 (variable -> VAR_CLASS .)
    DOT             reduce using rule 71 (variable -> VAR_CLASS .)
    UNARY_OP        reduce using rule 71 (variable -> VAR_CLASS .)
    RANGE_INCLUSIVE reduce using rule 71 (variable -> VAR_CLASS .)
    RANGE_EXCLUSIVE reduce using rule 71 (variable -> VAR_CLASS .)
    OR_SYMBOL       reduce using rule 71 (variable -> VAR_CLASS .)
    BINARY_XOR_OP   reduce using rule 71 (variable -> VAR_CLASS .)
    BINARY_AND_OP   reduce using rule 71 (variable -> VAR_CLASS .)
    COMBINED_COMPARISON_OP reduce using rule 71 (variable -> VAR_CLASS .)
    GREATERTHAN     reduce using rule 71 (variable -> VAR_CLASS .)
    GREATERTHANEQUAL reduce using rule 71 (variable -> VAR_CLASS .)
    LESSERTHAN      reduce using rule 71 (variable -> VAR_CLASS .)
    LESSERTHANEQUAL reduce using rule 71 (variable -> VAR_CLASS .)
    EQUAL           reduce using rule 71 (variable -> VAR_CLASS .)
    CASE_EQUALITY   reduce using rule 71 (variable -> VAR_CLASS .)
    NOTEQUAL        reduce using rule 71 (variable -> VAR_CLASS .)
    MATCHED_STRINGS_OP reduce using rule 71 (variable -> VAR_CLASS .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 71 (variable -> VAR_CLASS .)
    BINARY_LEFT_SHIFT_OP reduce using rule 71 (variable -> VAR_CLASS .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 71 (variable -> VAR_CLASS .)
    AND             reduce using rule 71 (variable -> VAR_CLASS .)
    OR              reduce using rule 71 (variable -> VAR_CLASS .)
    PLUS            reduce using rule 71 (variable -> VAR_CLASS .)
    MINUS           reduce using rule 71 (variable -> VAR_CLASS .)
    TIMES           reduce using rule 71 (variable -> VAR_CLASS .)
    DIVIDE          reduce using rule 71 (variable -> VAR_CLASS .)
    MOD             reduce using rule 71 (variable -> VAR_CLASS .)
    POW             reduce using rule 71 (variable -> VAR_CLASS .)
    IF              reduce using rule 71 (variable -> VAR_CLASS .)
    WHILE           reduce using rule 71 (variable -> VAR_CLASS .)
    UNLESS          reduce using rule 71 (variable -> VAR_CLASS .)
    UNTIL           reduce using rule 71 (variable -> VAR_CLASS .)
    TERM            reduce using rule 71 (variable -> VAR_CLASS .)
    $end            reduce using rule 71 (variable -> VAR_CLASS .)
    RBRACKET        reduce using rule 71 (variable -> VAR_CLASS .)
    THEN            reduce using rule 71 (variable -> VAR_CLASS .)
    DO              reduce using rule 71 (variable -> VAR_CLASS .)
    RESCUE          reduce using rule 71 (variable -> VAR_CLASS .)
    HASH_ROCKET     reduce using rule 71 (variable -> VAR_CLASS .)
    RKEY            reduce using rule 71 (variable -> VAR_CLASS .)
    RPAREN          reduce using rule 71 (variable -> VAR_CLASS .)
    WHEN            reduce using rule 71 (variable -> VAR_CLASS .)
    LKEY            reduce using rule 71 (variable -> VAR_CLASS .)
    END             reduce using rule 71 (variable -> VAR_CLASS .)
    ELSIF           reduce using rule 71 (variable -> VAR_CLASS .)
    ELSE            reduce using rule 71 (variable -> VAR_CLASS .)
    ENSURE          reduce using rule 71 (variable -> VAR_CLASS .)
    IN              reduce using rule 71 (variable -> VAR_CLASS .)
    NOT_SYMBOL      reduce using rule 71 (variable -> VAR_CLASS .)
    COMPLEMENT_OP   reduce using rule 71 (variable -> VAR_CLASS .)
    DEFINED_OP      reduce using rule 71 (variable -> VAR_CLASS .)
    NUMBER          reduce using rule 71 (variable -> VAR_CLASS .)
    LPAREN          reduce using rule 71 (variable -> VAR_CLASS .)
    RETURN          reduce using rule 71 (variable -> VAR_CLASS .)
    YIELD           reduce using rule 71 (variable -> VAR_CLASS .)
    CASE            reduce using rule 71 (variable -> VAR_CLASS .)
    FOR             reduce using rule 71 (variable -> VAR_CLASS .)
    BEGIN           reduce using rule 71 (variable -> VAR_CLASS .)
    CLASS           reduce using rule 71 (variable -> VAR_CLASS .)
    MODULE          reduce using rule 71 (variable -> VAR_CLASS .)
    DEF             reduce using rule 71 (variable -> VAR_CLASS .)
    VAR_GLOBAL      reduce using rule 71 (variable -> VAR_CLASS .)
    VAR_LOCAL       reduce using rule 71 (variable -> VAR_CLASS .)
    VAR_INSTANCE    reduce using rule 71 (variable -> VAR_CLASS .)
    VAR_CLASS       reduce using rule 71 (variable -> VAR_CLASS .)
    SYMBOL          reduce using rule 71 (variable -> VAR_CLASS .)
    STRING          reduce using rule 71 (variable -> VAR_CLASS .)
    IDENTIFIER      reduce using rule 71 (variable -> VAR_CLASS .)
    SUPER           reduce using rule 71 (variable -> VAR_CLASS .)


state 36

    (73) primary -> literal .

    LBRACKET        reduce using rule 73 (primary -> literal .)
    DOT             reduce using rule 73 (primary -> literal .)
    UNARY_OP        reduce using rule 73 (primary -> literal .)
    RANGE_INCLUSIVE reduce using rule 73 (primary -> literal .)
    RANGE_EXCLUSIVE reduce using rule 73 (primary -> literal .)
    OR_SYMBOL       reduce using rule 73 (primary -> literal .)
    BINARY_XOR_OP   reduce using rule 73 (primary -> literal .)
    BINARY_AND_OP   reduce using rule 73 (primary -> literal .)
    COMBINED_COMPARISON_OP reduce using rule 73 (primary -> literal .)
    GREATERTHAN     reduce using rule 73 (primary -> literal .)
    GREATERTHANEQUAL reduce using rule 73 (primary -> literal .)
    LESSERTHAN      reduce using rule 73 (primary -> literal .)
    LESSERTHANEQUAL reduce using rule 73 (primary -> literal .)
    EQUAL           reduce using rule 73 (primary -> literal .)
    CASE_EQUALITY   reduce using rule 73 (primary -> literal .)
    NOTEQUAL        reduce using rule 73 (primary -> literal .)
    MATCHED_STRINGS_OP reduce using rule 73 (primary -> literal .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 73 (primary -> literal .)
    BINARY_LEFT_SHIFT_OP reduce using rule 73 (primary -> literal .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 73 (primary -> literal .)
    AND             reduce using rule 73 (primary -> literal .)
    OR              reduce using rule 73 (primary -> literal .)
    PLUS            reduce using rule 73 (primary -> literal .)
    MINUS           reduce using rule 73 (primary -> literal .)
    TIMES           reduce using rule 73 (primary -> literal .)
    DIVIDE          reduce using rule 73 (primary -> literal .)
    MOD             reduce using rule 73 (primary -> literal .)
    POW             reduce using rule 73 (primary -> literal .)
    IF              reduce using rule 73 (primary -> literal .)
    WHILE           reduce using rule 73 (primary -> literal .)
    UNLESS          reduce using rule 73 (primary -> literal .)
    UNTIL           reduce using rule 73 (primary -> literal .)
    TERM            reduce using rule 73 (primary -> literal .)
    $end            reduce using rule 73 (primary -> literal .)
    COMMA           reduce using rule 73 (primary -> literal .)
    RBRACKET        reduce using rule 73 (primary -> literal .)
    THEN            reduce using rule 73 (primary -> literal .)
    DO              reduce using rule 73 (primary -> literal .)
    RESCUE          reduce using rule 73 (primary -> literal .)
    HASH_ROCKET     reduce using rule 73 (primary -> literal .)
    RKEY            reduce using rule 73 (primary -> literal .)
    RPAREN          reduce using rule 73 (primary -> literal .)
    WHEN            reduce using rule 73 (primary -> literal .)
    LKEY            reduce using rule 73 (primary -> literal .)
    END             reduce using rule 73 (primary -> literal .)
    ELSIF           reduce using rule 73 (primary -> literal .)
    ELSE            reduce using rule 73 (primary -> literal .)
    ENSURE          reduce using rule 73 (primary -> literal .)
    NOT_SYMBOL      reduce using rule 73 (primary -> literal .)
    COMPLEMENT_OP   reduce using rule 73 (primary -> literal .)
    DEFINED_OP      reduce using rule 73 (primary -> literal .)
    NUMBER          reduce using rule 73 (primary -> literal .)
    LPAREN          reduce using rule 73 (primary -> literal .)
    RETURN          reduce using rule 73 (primary -> literal .)
    YIELD           reduce using rule 73 (primary -> literal .)
    CASE            reduce using rule 73 (primary -> literal .)
    FOR             reduce using rule 73 (primary -> literal .)
    BEGIN           reduce using rule 73 (primary -> literal .)
    CLASS           reduce using rule 73 (primary -> literal .)
    MODULE          reduce using rule 73 (primary -> literal .)
    DEF             reduce using rule 73 (primary -> literal .)
    VAR_GLOBAL      reduce using rule 73 (primary -> literal .)
    VAR_LOCAL       reduce using rule 73 (primary -> literal .)
    VAR_INSTANCE    reduce using rule 73 (primary -> literal .)
    VAR_CLASS       reduce using rule 73 (primary -> literal .)
    SYMBOL          reduce using rule 73 (primary -> literal .)
    STRING          reduce using rule 73 (primary -> literal .)
    IDENTIFIER      reduce using rule 73 (primary -> literal .)
    SUPER           reduce using rule 73 (primary -> literal .)


state 37

    (93) primary -> DEFINED_OP . LPAREN arg LPAREN
    (66) arg -> DEFINED_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    LPAREN          shift and go to state 198
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 199
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 38

    (105) primary -> CASE . compstmt when END
    (106) primary -> CASE . compstmt when ELSE compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 200
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 39

    (107) primary -> FOR . block_var IN expr do compstmt END
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 44
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    block_var                      shift and go to state 201
    lhs                            shift and go to state 202
    mlhs                           shift and go to state 69
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    mlhs_item                      shift and go to state 43
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 40

    (112) primary -> CLASS . IDENTIFIER compstmt END
    (113) primary -> CLASS . IDENTIFIER LESSERTHAN IDENTIFIER compstmt END

    IDENTIFIER      shift and go to state 206


state 41

    (114) primary -> MODULE . IDENTIFIER compstmt END

    IDENTIFIER      shift and go to state 207


state 42

    (115) primary -> DEF . fname argdecl compstmt END
    (116) primary -> DEF . singleton DOT fname argdecl compstmt END
    (117) primary -> DEF . singleton UNARY_OP fname argdecl compstmt END
    (187) fname -> . IDENTIFIER
    (188) fname -> . RANGE_INCLUSIVE
    (189) fname -> . OR_SYMBOL
    (190) fname -> . BINARY_AND_OP
    (191) fname -> . BINARY_XOR_OP
    (192) fname -> . COMBINED_COMPARISON_OP
    (193) fname -> . EQUAL
    (194) fname -> . CASE_EQUALITY
    (195) fname -> . MATCHED_STRINGS_OP
    (196) fname -> . GREATERTHAN
    (197) fname -> . GREATERTHANEQUAL
    (198) fname -> . LESSERTHAN
    (199) fname -> . LESSERTHANEQUAL
    (200) fname -> . PLUS
    (201) fname -> . MINUS
    (202) fname -> . TIMES
    (203) fname -> . DIVIDE
    (204) fname -> . MOD
    (205) fname -> . POW
    (206) fname -> . BINARY_RIGHT_SHIFT_OP
    (207) fname -> . BINARY_LEFT_SHIFT_OP
    (208) fname -> . COMPLEMENT_OP
    (209) fname -> . OVERLOAD_PLUS
    (210) fname -> . OVERLOAD_MINUS
    (211) fname -> . LBRACKET RBRACKET
    (212) fname -> . LBRACKET RBRACKET EQUAL_SYMBOL
    (162) singleton -> . variable
    (163) singleton -> . LPAREN expr RPAREN
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS

    IDENTIFIER      shift and go to state 84
    RANGE_INCLUSIVE shift and go to state 85
    OR_SYMBOL       shift and go to state 86
    BINARY_AND_OP   shift and go to state 87
    BINARY_XOR_OP   shift and go to state 88
    COMBINED_COMPARISON_OP shift and go to state 89
    EQUAL           shift and go to state 90
    CASE_EQUALITY   shift and go to state 91
    MATCHED_STRINGS_OP shift and go to state 92
    GREATERTHAN     shift and go to state 93
    GREATERTHANEQUAL shift and go to state 94
    LESSERTHAN      shift and go to state 95
    LESSERTHANEQUAL shift and go to state 96
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 100
    MOD             shift and go to state 101
    POW             shift and go to state 102
    BINARY_RIGHT_SHIFT_OP shift and go to state 103
    BINARY_LEFT_SHIFT_OP shift and go to state 104
    COMPLEMENT_OP   shift and go to state 105
    OVERLOAD_PLUS   shift and go to state 106
    OVERLOAD_MINUS  shift and go to state 107
    LBRACKET        shift and go to state 108
    LPAREN          shift and go to state 211
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    fname                          shift and go to state 208
    singleton                      shift and go to state 209
    variable                       shift and go to state 210

state 43

    (147) mlhs -> mlhs_item . COMMA mlhs_item TIMES
    (148) mlhs -> mlhs_item . COMMA mlhs_item lhs
    (149) mlhs -> mlhs_item . COMMA mult_mlhs_item TIMES
    (150) mlhs -> mlhs_item . COMMA mult_mlhs_item lhs

    COMMA           shift and go to state 212


state 44

    (151) mlhs -> TIMES . lhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    lhs                            shift and go to state 213
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 45

    (44) arg -> math_operations .

    RANGE_INCLUSIVE reduce using rule 44 (arg -> math_operations .)
    RANGE_EXCLUSIVE reduce using rule 44 (arg -> math_operations .)
    OR_SYMBOL       reduce using rule 44 (arg -> math_operations .)
    BINARY_XOR_OP   reduce using rule 44 (arg -> math_operations .)
    BINARY_AND_OP   reduce using rule 44 (arg -> math_operations .)
    COMBINED_COMPARISON_OP reduce using rule 44 (arg -> math_operations .)
    GREATERTHAN     reduce using rule 44 (arg -> math_operations .)
    GREATERTHANEQUAL reduce using rule 44 (arg -> math_operations .)
    LESSERTHAN      reduce using rule 44 (arg -> math_operations .)
    LESSERTHANEQUAL reduce using rule 44 (arg -> math_operations .)
    EQUAL           reduce using rule 44 (arg -> math_operations .)
    CASE_EQUALITY   reduce using rule 44 (arg -> math_operations .)
    NOTEQUAL        reduce using rule 44 (arg -> math_operations .)
    MATCHED_STRINGS_OP reduce using rule 44 (arg -> math_operations .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 44 (arg -> math_operations .)
    BINARY_LEFT_SHIFT_OP reduce using rule 44 (arg -> math_operations .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 44 (arg -> math_operations .)
    AND             reduce using rule 44 (arg -> math_operations .)
    OR              reduce using rule 44 (arg -> math_operations .)
    PLUS            reduce using rule 44 (arg -> math_operations .)
    MINUS           reduce using rule 44 (arg -> math_operations .)
    TIMES           reduce using rule 44 (arg -> math_operations .)
    DIVIDE          reduce using rule 44 (arg -> math_operations .)
    MOD             reduce using rule 44 (arg -> math_operations .)
    POW             reduce using rule 44 (arg -> math_operations .)
    IF              reduce using rule 44 (arg -> math_operations .)
    WHILE           reduce using rule 44 (arg -> math_operations .)
    UNLESS          reduce using rule 44 (arg -> math_operations .)
    UNTIL           reduce using rule 44 (arg -> math_operations .)
    TERM            reduce using rule 44 (arg -> math_operations .)
    $end            reduce using rule 44 (arg -> math_operations .)
    COMMA           reduce using rule 44 (arg -> math_operations .)
    RBRACKET        reduce using rule 44 (arg -> math_operations .)
    THEN            reduce using rule 44 (arg -> math_operations .)
    DO              reduce using rule 44 (arg -> math_operations .)
    RESCUE          reduce using rule 44 (arg -> math_operations .)
    HASH_ROCKET     reduce using rule 44 (arg -> math_operations .)
    RKEY            reduce using rule 44 (arg -> math_operations .)
    RPAREN          reduce using rule 44 (arg -> math_operations .)
    WHEN            reduce using rule 44 (arg -> math_operations .)
    LKEY            reduce using rule 44 (arg -> math_operations .)
    END             reduce using rule 44 (arg -> math_operations .)
    ELSIF           reduce using rule 44 (arg -> math_operations .)
    ELSE            reduce using rule 44 (arg -> math_operations .)
    ENSURE          reduce using rule 44 (arg -> math_operations .)
    LBRACKET        reduce using rule 44 (arg -> math_operations .)
    NOT_SYMBOL      reduce using rule 44 (arg -> math_operations .)
    COMPLEMENT_OP   reduce using rule 44 (arg -> math_operations .)
    DEFINED_OP      reduce using rule 44 (arg -> math_operations .)
    NUMBER          reduce using rule 44 (arg -> math_operations .)
    LPAREN          reduce using rule 44 (arg -> math_operations .)
    UNARY_OP        reduce using rule 44 (arg -> math_operations .)
    RETURN          reduce using rule 44 (arg -> math_operations .)
    YIELD           reduce using rule 44 (arg -> math_operations .)
    CASE            reduce using rule 44 (arg -> math_operations .)
    FOR             reduce using rule 44 (arg -> math_operations .)
    BEGIN           reduce using rule 44 (arg -> math_operations .)
    CLASS           reduce using rule 44 (arg -> math_operations .)
    MODULE          reduce using rule 44 (arg -> math_operations .)
    DEF             reduce using rule 44 (arg -> math_operations .)
    VAR_GLOBAL      reduce using rule 44 (arg -> math_operations .)
    VAR_LOCAL       reduce using rule 44 (arg -> math_operations .)
    VAR_INSTANCE    reduce using rule 44 (arg -> math_operations .)
    VAR_CLASS       reduce using rule 44 (arg -> math_operations .)
    SYMBOL          reduce using rule 44 (arg -> math_operations .)
    STRING          reduce using rule 44 (arg -> math_operations .)
    IDENTIFIER      reduce using rule 44 (arg -> math_operations .)
    SUPER           reduce using rule 44 (arg -> math_operations .)


state 46

    (45) arg -> PLUS . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 214
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 47

    (46) arg -> MINUS . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 215
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 48

    (61) arg -> COMPLEMENT_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 216
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 49

    (183) literal -> NUMBER .
    (235) math_operations -> NUMBER . PLUS NUMBER
    (236) math_operations -> NUMBER . MINUS NUMBER
    (237) math_operations -> NUMBER . TIMES NUMBER
    (238) math_operations -> NUMBER . DIVIDE NUMBER
    (239) math_operations -> NUMBER . MOD NUMBER
    (240) math_operations -> NUMBER . POW NUMBER

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    LBRACKET        reduce using rule 183 (literal -> NUMBER .)
    DOT             reduce using rule 183 (literal -> NUMBER .)
    UNARY_OP        reduce using rule 183 (literal -> NUMBER .)
    RANGE_INCLUSIVE reduce using rule 183 (literal -> NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 183 (literal -> NUMBER .)
    OR_SYMBOL       reduce using rule 183 (literal -> NUMBER .)
    BINARY_XOR_OP   reduce using rule 183 (literal -> NUMBER .)
    BINARY_AND_OP   reduce using rule 183 (literal -> NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 183 (literal -> NUMBER .)
    GREATERTHAN     reduce using rule 183 (literal -> NUMBER .)
    GREATERTHANEQUAL reduce using rule 183 (literal -> NUMBER .)
    LESSERTHAN      reduce using rule 183 (literal -> NUMBER .)
    LESSERTHANEQUAL reduce using rule 183 (literal -> NUMBER .)
    EQUAL           reduce using rule 183 (literal -> NUMBER .)
    CASE_EQUALITY   reduce using rule 183 (literal -> NUMBER .)
    NOTEQUAL        reduce using rule 183 (literal -> NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 183 (literal -> NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 183 (literal -> NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 183 (literal -> NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 183 (literal -> NUMBER .)
    AND             reduce using rule 183 (literal -> NUMBER .)
    OR              reduce using rule 183 (literal -> NUMBER .)
    IF              reduce using rule 183 (literal -> NUMBER .)
    WHILE           reduce using rule 183 (literal -> NUMBER .)
    UNLESS          reduce using rule 183 (literal -> NUMBER .)
    UNTIL           reduce using rule 183 (literal -> NUMBER .)
    TERM            reduce using rule 183 (literal -> NUMBER .)
    $end            reduce using rule 183 (literal -> NUMBER .)
    RESCUE          reduce using rule 183 (literal -> NUMBER .)
    RPAREN          reduce using rule 183 (literal -> NUMBER .)
    WHEN            reduce using rule 183 (literal -> NUMBER .)
    RKEY            reduce using rule 183 (literal -> NUMBER .)
    LKEY            reduce using rule 183 (literal -> NUMBER .)
    END             reduce using rule 183 (literal -> NUMBER .)
    ELSIF           reduce using rule 183 (literal -> NUMBER .)
    ELSE            reduce using rule 183 (literal -> NUMBER .)
    ENSURE          reduce using rule 183 (literal -> NUMBER .)
    PLUS            shift and go to state 217
    MINUS           shift and go to state 218
    TIMES           shift and go to state 219
    DIVIDE          shift and go to state 220
    MOD             shift and go to state 221
    POW             shift and go to state 222

  ! PLUS            [ reduce using rule 183 (literal -> NUMBER .) ]
  ! MINUS           [ reduce using rule 183 (literal -> NUMBER .) ]
  ! TIMES           [ reduce using rule 183 (literal -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 183 (literal -> NUMBER .) ]
  ! MOD             [ reduce using rule 183 (literal -> NUMBER .) ]
  ! POW             [ reduce using rule 183 (literal -> NUMBER .) ]


state 50

    (184) literal -> SYMBOL .

    LBRACKET        reduce using rule 184 (literal -> SYMBOL .)
    DOT             reduce using rule 184 (literal -> SYMBOL .)
    UNARY_OP        reduce using rule 184 (literal -> SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 184 (literal -> SYMBOL .)
    RANGE_EXCLUSIVE reduce using rule 184 (literal -> SYMBOL .)
    OR_SYMBOL       reduce using rule 184 (literal -> SYMBOL .)
    BINARY_XOR_OP   reduce using rule 184 (literal -> SYMBOL .)
    BINARY_AND_OP   reduce using rule 184 (literal -> SYMBOL .)
    COMBINED_COMPARISON_OP reduce using rule 184 (literal -> SYMBOL .)
    GREATERTHAN     reduce using rule 184 (literal -> SYMBOL .)
    GREATERTHANEQUAL reduce using rule 184 (literal -> SYMBOL .)
    LESSERTHAN      reduce using rule 184 (literal -> SYMBOL .)
    LESSERTHANEQUAL reduce using rule 184 (literal -> SYMBOL .)
    EQUAL           reduce using rule 184 (literal -> SYMBOL .)
    CASE_EQUALITY   reduce using rule 184 (literal -> SYMBOL .)
    NOTEQUAL        reduce using rule 184 (literal -> SYMBOL .)
    MATCHED_STRINGS_OP reduce using rule 184 (literal -> SYMBOL .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 184 (literal -> SYMBOL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 184 (literal -> SYMBOL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 184 (literal -> SYMBOL .)
    AND             reduce using rule 184 (literal -> SYMBOL .)
    OR              reduce using rule 184 (literal -> SYMBOL .)
    PLUS            reduce using rule 184 (literal -> SYMBOL .)
    MINUS           reduce using rule 184 (literal -> SYMBOL .)
    TIMES           reduce using rule 184 (literal -> SYMBOL .)
    DIVIDE          reduce using rule 184 (literal -> SYMBOL .)
    MOD             reduce using rule 184 (literal -> SYMBOL .)
    POW             reduce using rule 184 (literal -> SYMBOL .)
    IF              reduce using rule 184 (literal -> SYMBOL .)
    WHILE           reduce using rule 184 (literal -> SYMBOL .)
    UNLESS          reduce using rule 184 (literal -> SYMBOL .)
    UNTIL           reduce using rule 184 (literal -> SYMBOL .)
    TERM            reduce using rule 184 (literal -> SYMBOL .)
    $end            reduce using rule 184 (literal -> SYMBOL .)
    COMMA           reduce using rule 184 (literal -> SYMBOL .)
    RBRACKET        reduce using rule 184 (literal -> SYMBOL .)
    THEN            reduce using rule 184 (literal -> SYMBOL .)
    DO              reduce using rule 184 (literal -> SYMBOL .)
    RESCUE          reduce using rule 184 (literal -> SYMBOL .)
    HASH_ROCKET     reduce using rule 184 (literal -> SYMBOL .)
    RKEY            reduce using rule 184 (literal -> SYMBOL .)
    RPAREN          reduce using rule 184 (literal -> SYMBOL .)
    WHEN            reduce using rule 184 (literal -> SYMBOL .)
    LKEY            reduce using rule 184 (literal -> SYMBOL .)
    END             reduce using rule 184 (literal -> SYMBOL .)
    ELSIF           reduce using rule 184 (literal -> SYMBOL .)
    ELSE            reduce using rule 184 (literal -> SYMBOL .)
    ENSURE          reduce using rule 184 (literal -> SYMBOL .)
    NOT_SYMBOL      reduce using rule 184 (literal -> SYMBOL .)
    COMPLEMENT_OP   reduce using rule 184 (literal -> SYMBOL .)
    DEFINED_OP      reduce using rule 184 (literal -> SYMBOL .)
    NUMBER          reduce using rule 184 (literal -> SYMBOL .)
    LPAREN          reduce using rule 184 (literal -> SYMBOL .)
    RETURN          reduce using rule 184 (literal -> SYMBOL .)
    YIELD           reduce using rule 184 (literal -> SYMBOL .)
    CASE            reduce using rule 184 (literal -> SYMBOL .)
    FOR             reduce using rule 184 (literal -> SYMBOL .)
    BEGIN           reduce using rule 184 (literal -> SYMBOL .)
    CLASS           reduce using rule 184 (literal -> SYMBOL .)
    MODULE          reduce using rule 184 (literal -> SYMBOL .)
    DEF             reduce using rule 184 (literal -> SYMBOL .)
    VAR_GLOBAL      reduce using rule 184 (literal -> SYMBOL .)
    VAR_LOCAL       reduce using rule 184 (literal -> SYMBOL .)
    VAR_INSTANCE    reduce using rule 184 (literal -> SYMBOL .)
    VAR_CLASS       reduce using rule 184 (literal -> SYMBOL .)
    SYMBOL          reduce using rule 184 (literal -> SYMBOL .)
    STRING          reduce using rule 184 (literal -> SYMBOL .)
    IDENTIFIER      reduce using rule 184 (literal -> SYMBOL .)
    SUPER           reduce using rule 184 (literal -> SYMBOL .)


state 51

    (185) literal -> STRING .

    LBRACKET        reduce using rule 185 (literal -> STRING .)
    DOT             reduce using rule 185 (literal -> STRING .)
    UNARY_OP        reduce using rule 185 (literal -> STRING .)
    RANGE_INCLUSIVE reduce using rule 185 (literal -> STRING .)
    RANGE_EXCLUSIVE reduce using rule 185 (literal -> STRING .)
    OR_SYMBOL       reduce using rule 185 (literal -> STRING .)
    BINARY_XOR_OP   reduce using rule 185 (literal -> STRING .)
    BINARY_AND_OP   reduce using rule 185 (literal -> STRING .)
    COMBINED_COMPARISON_OP reduce using rule 185 (literal -> STRING .)
    GREATERTHAN     reduce using rule 185 (literal -> STRING .)
    GREATERTHANEQUAL reduce using rule 185 (literal -> STRING .)
    LESSERTHAN      reduce using rule 185 (literal -> STRING .)
    LESSERTHANEQUAL reduce using rule 185 (literal -> STRING .)
    EQUAL           reduce using rule 185 (literal -> STRING .)
    CASE_EQUALITY   reduce using rule 185 (literal -> STRING .)
    NOTEQUAL        reduce using rule 185 (literal -> STRING .)
    MATCHED_STRINGS_OP reduce using rule 185 (literal -> STRING .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 185 (literal -> STRING .)
    BINARY_LEFT_SHIFT_OP reduce using rule 185 (literal -> STRING .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 185 (literal -> STRING .)
    AND             reduce using rule 185 (literal -> STRING .)
    OR              reduce using rule 185 (literal -> STRING .)
    PLUS            reduce using rule 185 (literal -> STRING .)
    MINUS           reduce using rule 185 (literal -> STRING .)
    TIMES           reduce using rule 185 (literal -> STRING .)
    DIVIDE          reduce using rule 185 (literal -> STRING .)
    MOD             reduce using rule 185 (literal -> STRING .)
    POW             reduce using rule 185 (literal -> STRING .)
    IF              reduce using rule 185 (literal -> STRING .)
    WHILE           reduce using rule 185 (literal -> STRING .)
    UNLESS          reduce using rule 185 (literal -> STRING .)
    UNTIL           reduce using rule 185 (literal -> STRING .)
    TERM            reduce using rule 185 (literal -> STRING .)
    $end            reduce using rule 185 (literal -> STRING .)
    COMMA           reduce using rule 185 (literal -> STRING .)
    RBRACKET        reduce using rule 185 (literal -> STRING .)
    THEN            reduce using rule 185 (literal -> STRING .)
    DO              reduce using rule 185 (literal -> STRING .)
    RESCUE          reduce using rule 185 (literal -> STRING .)
    HASH_ROCKET     reduce using rule 185 (literal -> STRING .)
    RKEY            reduce using rule 185 (literal -> STRING .)
    RPAREN          reduce using rule 185 (literal -> STRING .)
    WHEN            reduce using rule 185 (literal -> STRING .)
    LKEY            reduce using rule 185 (literal -> STRING .)
    END             reduce using rule 185 (literal -> STRING .)
    ELSIF           reduce using rule 185 (literal -> STRING .)
    ELSE            reduce using rule 185 (literal -> STRING .)
    ENSURE          reduce using rule 185 (literal -> STRING .)
    NOT_SYMBOL      reduce using rule 185 (literal -> STRING .)
    COMPLEMENT_OP   reduce using rule 185 (literal -> STRING .)
    DEFINED_OP      reduce using rule 185 (literal -> STRING .)
    NUMBER          reduce using rule 185 (literal -> STRING .)
    LPAREN          reduce using rule 185 (literal -> STRING .)
    RETURN          reduce using rule 185 (literal -> STRING .)
    YIELD           reduce using rule 185 (literal -> STRING .)
    CASE            reduce using rule 185 (literal -> STRING .)
    FOR             reduce using rule 185 (literal -> STRING .)
    BEGIN           reduce using rule 185 (literal -> STRING .)
    CLASS           reduce using rule 185 (literal -> STRING .)
    MODULE          reduce using rule 185 (literal -> STRING .)
    DEF             reduce using rule 185 (literal -> STRING .)
    VAR_GLOBAL      reduce using rule 185 (literal -> STRING .)
    VAR_LOCAL       reduce using rule 185 (literal -> STRING .)
    VAR_INSTANCE    reduce using rule 185 (literal -> STRING .)
    VAR_CLASS       reduce using rule 185 (literal -> STRING .)
    SYMBOL          reduce using rule 185 (literal -> STRING .)
    STRING          reduce using rule 185 (literal -> STRING .)
    IDENTIFIER      reduce using rule 185 (literal -> STRING .)
    SUPER           reduce using rule 185 (literal -> STRING .)


state 52

    (3) compstmt -> stmt term .
    (4) compstmt -> stmt term . expr term
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LKEY resolved as shift
    $end            reduce using rule 3 (compstmt -> stmt term .)
    RESCUE          reduce using rule 3 (compstmt -> stmt term .)
    RPAREN          reduce using rule 3 (compstmt -> stmt term .)
    WHEN            reduce using rule 3 (compstmt -> stmt term .)
    RKEY            reduce using rule 3 (compstmt -> stmt term .)
    END             reduce using rule 3 (compstmt -> stmt term .)
    ELSIF           reduce using rule 3 (compstmt -> stmt term .)
    ELSE            reduce using rule 3 (compstmt -> stmt term .)
    ENSURE          reduce using rule 3 (compstmt -> stmt term .)
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 3 (compstmt -> stmt term .) ]

    expr                           shift and go to state 223
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 53

    (10) stmt -> stmt IF . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 224
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 54

    (11) stmt -> stmt WHILE . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 225
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 55

    (12) stmt -> stmt UNLESS . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 226
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 56

    (13) stmt -> stmt UNTIL . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 227
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 57

    (135) term -> TERM .

    RETURN          reduce using rule 135 (term -> TERM .)
    YIELD           reduce using rule 135 (term -> TERM .)
    NOT             reduce using rule 135 (term -> TERM .)
    NOT_SYMBOL      reduce using rule 135 (term -> TERM .)
    TIMES           reduce using rule 135 (term -> TERM .)
    SUPER           reduce using rule 135 (term -> TERM .)
    PLUS            reduce using rule 135 (term -> TERM .)
    MINUS           reduce using rule 135 (term -> TERM .)
    COMPLEMENT_OP   reduce using rule 135 (term -> TERM .)
    DEFINED_OP      reduce using rule 135 (term -> TERM .)
    LPAREN          reduce using rule 135 (term -> TERM .)
    IDENTIFIER      reduce using rule 135 (term -> TERM .)
    UNARY_OP        reduce using rule 135 (term -> TERM .)
    LBRACKET        reduce using rule 135 (term -> TERM .)
    LKEY            reduce using rule 135 (term -> TERM .)
    IF              reduce using rule 135 (term -> TERM .)
    UNLESS          reduce using rule 135 (term -> TERM .)
    WHILE           reduce using rule 135 (term -> TERM .)
    UNTIL           reduce using rule 135 (term -> TERM .)
    CASE            reduce using rule 135 (term -> TERM .)
    FOR             reduce using rule 135 (term -> TERM .)
    BEGIN           reduce using rule 135 (term -> TERM .)
    CLASS           reduce using rule 135 (term -> TERM .)
    MODULE          reduce using rule 135 (term -> TERM .)
    DEF             reduce using rule 135 (term -> TERM .)
    NUMBER          reduce using rule 135 (term -> TERM .)
    SYMBOL          reduce using rule 135 (term -> TERM .)
    STRING          reduce using rule 135 (term -> TERM .)
    VAR_GLOBAL      reduce using rule 135 (term -> TERM .)
    VAR_LOCAL       reduce using rule 135 (term -> TERM .)
    VAR_INSTANCE    reduce using rule 135 (term -> TERM .)
    VAR_CLASS       reduce using rule 135 (term -> TERM .)
    $end            reduce using rule 135 (term -> TERM .)
    RESCUE          reduce using rule 135 (term -> TERM .)
    RPAREN          reduce using rule 135 (term -> TERM .)
    WHEN            reduce using rule 135 (term -> TERM .)
    RKEY            reduce using rule 135 (term -> TERM .)
    END             reduce using rule 135 (term -> TERM .)
    ELSIF           reduce using rule 135 (term -> TERM .)
    ELSE            reduce using rule 135 (term -> TERM .)
    ENSURE          reduce using rule 135 (term -> TERM .)
    DO              reduce using rule 135 (term -> TERM .)
    UNDEF           reduce using rule 135 (term -> TERM .)
    ALIAS           reduce using rule 135 (term -> TERM .)


state 58

    (21) expr -> expr AND . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 228
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 59

    (22) expr -> expr OR . expr
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 229
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 60

    (5) stmt -> call do . LBRACKET RBRACKET

    LBRACKET        shift and go to state 230


state 61

    (132) do -> term .
    (134) do -> term . DO

    LBRACKET        reduce using rule 132 (do -> term .)
    UNDEF           reduce using rule 132 (do -> term .)
    ALIAS           reduce using rule 132 (do -> term .)
    BEGIN           reduce using rule 132 (do -> term .)
    END             reduce using rule 132 (do -> term .)
    RETURN          reduce using rule 132 (do -> term .)
    YIELD           reduce using rule 132 (do -> term .)
    NOT             reduce using rule 132 (do -> term .)
    NOT_SYMBOL      reduce using rule 132 (do -> term .)
    SUPER           reduce using rule 132 (do -> term .)
    VAR_GLOBAL      reduce using rule 132 (do -> term .)
    VAR_LOCAL       reduce using rule 132 (do -> term .)
    VAR_INSTANCE    reduce using rule 132 (do -> term .)
    VAR_CLASS       reduce using rule 132 (do -> term .)
    LPAREN          reduce using rule 132 (do -> term .)
    UNARY_OP        reduce using rule 132 (do -> term .)
    LKEY            reduce using rule 132 (do -> term .)
    DEFINED_OP      reduce using rule 132 (do -> term .)
    IF              reduce using rule 132 (do -> term .)
    UNLESS          reduce using rule 132 (do -> term .)
    WHILE           reduce using rule 132 (do -> term .)
    UNTIL           reduce using rule 132 (do -> term .)
    CASE            reduce using rule 132 (do -> term .)
    FOR             reduce using rule 132 (do -> term .)
    CLASS           reduce using rule 132 (do -> term .)
    MODULE          reduce using rule 132 (do -> term .)
    DEF             reduce using rule 132 (do -> term .)
    TIMES           reduce using rule 132 (do -> term .)
    PLUS            reduce using rule 132 (do -> term .)
    MINUS           reduce using rule 132 (do -> term .)
    COMPLEMENT_OP   reduce using rule 132 (do -> term .)
    IDENTIFIER      reduce using rule 132 (do -> term .)
    NUMBER          reduce using rule 132 (do -> term .)
    SYMBOL          reduce using rule 132 (do -> term .)
    STRING          reduce using rule 132 (do -> term .)
    DO              shift and go to state 231


state 62

    (133) do -> DO .

    LBRACKET        reduce using rule 133 (do -> DO .)
    UNDEF           reduce using rule 133 (do -> DO .)
    ALIAS           reduce using rule 133 (do -> DO .)
    BEGIN           reduce using rule 133 (do -> DO .)
    END             reduce using rule 133 (do -> DO .)
    RETURN          reduce using rule 133 (do -> DO .)
    YIELD           reduce using rule 133 (do -> DO .)
    NOT             reduce using rule 133 (do -> DO .)
    NOT_SYMBOL      reduce using rule 133 (do -> DO .)
    SUPER           reduce using rule 133 (do -> DO .)
    VAR_GLOBAL      reduce using rule 133 (do -> DO .)
    VAR_LOCAL       reduce using rule 133 (do -> DO .)
    VAR_INSTANCE    reduce using rule 133 (do -> DO .)
    VAR_CLASS       reduce using rule 133 (do -> DO .)
    LPAREN          reduce using rule 133 (do -> DO .)
    UNARY_OP        reduce using rule 133 (do -> DO .)
    LKEY            reduce using rule 133 (do -> DO .)
    DEFINED_OP      reduce using rule 133 (do -> DO .)
    IF              reduce using rule 133 (do -> DO .)
    UNLESS          reduce using rule 133 (do -> DO .)
    WHILE           reduce using rule 133 (do -> DO .)
    UNTIL           reduce using rule 133 (do -> DO .)
    CASE            reduce using rule 133 (do -> DO .)
    FOR             reduce using rule 133 (do -> DO .)
    CLASS           reduce using rule 133 (do -> DO .)
    MODULE          reduce using rule 133 (do -> DO .)
    DEF             reduce using rule 133 (do -> DO .)
    TIMES           reduce using rule 133 (do -> DO .)
    PLUS            reduce using rule 133 (do -> DO .)
    MINUS           reduce using rule 133 (do -> DO .)
    COMPLEMENT_OP   reduce using rule 133 (do -> DO .)
    IDENTIFIER      reduce using rule 133 (do -> DO .)
    NUMBER          reduce using rule 133 (do -> DO .)
    SYMBOL          reduce using rule 133 (do -> DO .)
    STRING          reduce using rule 133 (do -> DO .)


state 63

    (79) primary -> LBRACKET . RBRACKET
    (80) primary -> LBRACKET . args RBRACKET
    (81) primary -> LBRACKET . args COMMA RBRACKET
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    RBRACKET        shift and go to state 65
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    args                           shift and go to state 67
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 64

    (6) stmt -> LBRACKET block_var . RBRACKET

    RBRACKET        shift and go to state 232


state 65

    (79) primary -> LBRACKET RBRACKET .

    LBRACKET        reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    DOT             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    UNARY_OP        reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    OR_SYMBOL       reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    BINARY_XOR_OP   reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    BINARY_AND_OP   reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    GREATERTHAN     reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    GREATERTHANEQUAL reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    LESSERTHAN      reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    LESSERTHANEQUAL reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    EQUAL           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    CASE_EQUALITY   reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    NOTEQUAL        reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    AND             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    OR              reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    PLUS            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    TIMES           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    MOD             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    POW             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    IF              reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    UNLESS          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    UNTIL           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    TERM            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    $end            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    COMMA           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    THEN            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    DO              reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RESCUE          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    HASH_ROCKET     reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RKEY            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    WHEN            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    LKEY            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    END             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    ELSIF           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    ELSE            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    ENSURE          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    NOT_SYMBOL      reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    COMPLEMENT_OP   reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    DEFINED_OP      reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    NUMBER          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    RETURN          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    YIELD           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    CASE            reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    FOR             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    BEGIN           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    CLASS           reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    MODULE          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    DEF             reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    VAR_GLOBAL      reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    VAR_LOCAL       reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    VAR_INSTANCE    reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    VAR_CLASS       reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    SYMBOL          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    STRING          reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 79 (primary -> LBRACKET RBRACKET .)
    SUPER           reduce using rule 79 (primary -> LBRACKET RBRACKET .)


state 66

    (7) stmt -> LBRACKET OR_SYMBOL . block_var OR_SYMBOL RBRACKET compstmt END
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 44
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    block_var                      shift and go to state 233
    lhs                            shift and go to state 202
    mlhs                           shift and go to state 69
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    mlhs_item                      shift and go to state 43
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 67

    (80) primary -> LBRACKET args . RBRACKET
    (81) primary -> LBRACKET args . COMMA RBRACKET

    RBRACKET        shift and go to state 234
    COMMA           shift and go to state 235


state 68

    (145) block_var -> lhs .
    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (153) mlhs_item -> lhs .
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    RBRACKET        reduce using rule 145 (block_var -> lhs .)
    =               shift and go to state 236
    COMMA           reduce using rule 153 (mlhs_item -> lhs .)
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 69

    (146) block_var -> mlhs .

    RBRACKET        reduce using rule 146 (block_var -> mlhs .)
    IN              reduce using rule 146 (block_var -> mlhs .)
    OR_SYMBOL       reduce using rule 146 (block_var -> mlhs .)


state 70

    (155) args -> arg .
    (156) args -> arg . COMMA arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RBRACKET        reduce using rule 155 (args -> arg .)
    NOT_SYMBOL      reduce using rule 155 (args -> arg .)
    COMPLEMENT_OP   reduce using rule 155 (args -> arg .)
    DEFINED_OP      reduce using rule 155 (args -> arg .)
    NUMBER          reduce using rule 155 (args -> arg .)
    LPAREN          reduce using rule 155 (args -> arg .)
    UNARY_OP        reduce using rule 155 (args -> arg .)
    LBRACKET        reduce using rule 155 (args -> arg .)
    LKEY            reduce using rule 155 (args -> arg .)
    RETURN          reduce using rule 155 (args -> arg .)
    YIELD           reduce using rule 155 (args -> arg .)
    IF              reduce using rule 155 (args -> arg .)
    UNLESS          reduce using rule 155 (args -> arg .)
    WHILE           reduce using rule 155 (args -> arg .)
    UNTIL           reduce using rule 155 (args -> arg .)
    CASE            reduce using rule 155 (args -> arg .)
    FOR             reduce using rule 155 (args -> arg .)
    BEGIN           reduce using rule 155 (args -> arg .)
    CLASS           reduce using rule 155 (args -> arg .)
    MODULE          reduce using rule 155 (args -> arg .)
    DEF             reduce using rule 155 (args -> arg .)
    VAR_GLOBAL      reduce using rule 155 (args -> arg .)
    VAR_LOCAL       reduce using rule 155 (args -> arg .)
    VAR_INSTANCE    reduce using rule 155 (args -> arg .)
    VAR_CLASS       reduce using rule 155 (args -> arg .)
    SYMBOL          reduce using rule 155 (args -> arg .)
    STRING          reduce using rule 155 (args -> arg .)
    IDENTIFIER      reduce using rule 155 (args -> arg .)
    SUPER           reduce using rule 155 (args -> arg .)
    TERM            reduce using rule 155 (args -> arg .)
    $end            reduce using rule 155 (args -> arg .)
    THEN            reduce using rule 155 (args -> arg .)
    DO              reduce using rule 155 (args -> arg .)
    RESCUE          reduce using rule 155 (args -> arg .)
    RPAREN          reduce using rule 155 (args -> arg .)
    WHEN            reduce using rule 155 (args -> arg .)
    RKEY            reduce using rule 155 (args -> arg .)
    END             reduce using rule 155 (args -> arg .)
    ELSIF           reduce using rule 155 (args -> arg .)
    ELSE            reduce using rule 155 (args -> arg .)
    ENSURE          reduce using rule 155 (args -> arg .)
    COMMA           shift and go to state 237
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! COMMA           [ reduce using rule 155 (args -> arg .) ]
  ! TIMES           [ reduce using rule 155 (args -> arg .) ]
  ! PLUS            [ reduce using rule 155 (args -> arg .) ]
  ! MINUS           [ reduce using rule 155 (args -> arg .) ]
  ! AND             [ reduce using rule 155 (args -> arg .) ]
  ! OR              [ reduce using rule 155 (args -> arg .) ]


state 71

    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (67) arg -> primary .
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation

    LBRACKET        shift and go to state 147
    DOT             shift and go to state 238
    COMMA           reduce using rule 67 (arg -> primary .)
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    RBRACKET        reduce using rule 67 (arg -> primary .)
    UNARY_OP        shift and go to state 239


state 72

    (186) literal -> IDENTIFIER .
    (213) operation -> IDENTIFIER .
    (214) operation -> IDENTIFIER . NOT_SYMBOL
    (215) operation -> IDENTIFIER . OPTIONAL_SYMBOL

  ! reduce/reduce conflict for LBRACKET resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for BINARY_AND_OP resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for SUPER resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for NOT_SYMBOL resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for COMPLEMENT_OP resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for DEFINED_OP resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for LKEY resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for RETURN resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for YIELD resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for UNLESS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for UNTIL resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for CASE resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for BEGIN resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for CLASS resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for DEF resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for NUMBER resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for STRING resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR_GLOBAL resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR_LOCAL resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR_INSTANCE resolved using rule 186 (literal -> IDENTIFIER .)
  ! reduce/reduce conflict for VAR_CLASS resolved using rule 186 (literal -> IDENTIFIER .)
  ! shift/reduce conflict for NOT_SYMBOL resolved as shift
    LBRACKET        reduce using rule 186 (literal -> IDENTIFIER .)
    DOT             reduce using rule 186 (literal -> IDENTIFIER .)
    UNARY_OP        reduce using rule 186 (literal -> IDENTIFIER .)
    COMMA           reduce using rule 186 (literal -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 186 (literal -> IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 186 (literal -> IDENTIFIER .)
    OR_SYMBOL       reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_XOR_OP   reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_AND_OP   reduce using rule 186 (literal -> IDENTIFIER .)
    COMBINED_COMPARISON_OP reduce using rule 186 (literal -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 186 (literal -> IDENTIFIER .)
    GREATERTHANEQUAL reduce using rule 186 (literal -> IDENTIFIER .)
    LESSERTHAN      reduce using rule 186 (literal -> IDENTIFIER .)
    LESSERTHANEQUAL reduce using rule 186 (literal -> IDENTIFIER .)
    EQUAL           reduce using rule 186 (literal -> IDENTIFIER .)
    CASE_EQUALITY   reduce using rule 186 (literal -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 186 (literal -> IDENTIFIER .)
    MATCHED_STRINGS_OP reduce using rule 186 (literal -> IDENTIFIER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 186 (literal -> IDENTIFIER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 186 (literal -> IDENTIFIER .)
    AND             reduce using rule 186 (literal -> IDENTIFIER .)
    OR              reduce using rule 186 (literal -> IDENTIFIER .)
    PLUS            reduce using rule 186 (literal -> IDENTIFIER .)
    MINUS           reduce using rule 186 (literal -> IDENTIFIER .)
    TIMES           reduce using rule 186 (literal -> IDENTIFIER .)
    DIVIDE          reduce using rule 186 (literal -> IDENTIFIER .)
    MOD             reduce using rule 186 (literal -> IDENTIFIER .)
    POW             reduce using rule 186 (literal -> IDENTIFIER .)
    RBRACKET        reduce using rule 186 (literal -> IDENTIFIER .)
    HASH_ROCKET     reduce using rule 186 (literal -> IDENTIFIER .)
    RKEY            reduce using rule 186 (literal -> IDENTIFIER .)
    IF              reduce using rule 186 (literal -> IDENTIFIER .)
    WHILE           reduce using rule 186 (literal -> IDENTIFIER .)
    UNLESS          reduce using rule 186 (literal -> IDENTIFIER .)
    UNTIL           reduce using rule 186 (literal -> IDENTIFIER .)
    TERM            reduce using rule 186 (literal -> IDENTIFIER .)
    $end            reduce using rule 186 (literal -> IDENTIFIER .)
    RESCUE          reduce using rule 186 (literal -> IDENTIFIER .)
    RPAREN          reduce using rule 186 (literal -> IDENTIFIER .)
    WHEN            reduce using rule 186 (literal -> IDENTIFIER .)
    LKEY            reduce using rule 186 (literal -> IDENTIFIER .)
    END             reduce using rule 186 (literal -> IDENTIFIER .)
    ELSIF           reduce using rule 186 (literal -> IDENTIFIER .)
    ELSE            reduce using rule 186 (literal -> IDENTIFIER .)
    ENSURE          reduce using rule 186 (literal -> IDENTIFIER .)
    THEN            reduce using rule 186 (literal -> IDENTIFIER .)
    DO              reduce using rule 186 (literal -> IDENTIFIER .)
    COMPLEMENT_OP   reduce using rule 186 (literal -> IDENTIFIER .)
    DEFINED_OP      reduce using rule 186 (literal -> IDENTIFIER .)
    NUMBER          reduce using rule 186 (literal -> IDENTIFIER .)
    LPAREN          reduce using rule 186 (literal -> IDENTIFIER .)
    RETURN          reduce using rule 186 (literal -> IDENTIFIER .)
    YIELD           reduce using rule 186 (literal -> IDENTIFIER .)
    CASE            reduce using rule 186 (literal -> IDENTIFIER .)
    FOR             reduce using rule 186 (literal -> IDENTIFIER .)
    BEGIN           reduce using rule 186 (literal -> IDENTIFIER .)
    CLASS           reduce using rule 186 (literal -> IDENTIFIER .)
    MODULE          reduce using rule 186 (literal -> IDENTIFIER .)
    DEF             reduce using rule 186 (literal -> IDENTIFIER .)
    VAR_GLOBAL      reduce using rule 186 (literal -> IDENTIFIER .)
    VAR_LOCAL       reduce using rule 186 (literal -> IDENTIFIER .)
    VAR_INSTANCE    reduce using rule 186 (literal -> IDENTIFIER .)
    VAR_CLASS       reduce using rule 186 (literal -> IDENTIFIER .)
    SYMBOL          reduce using rule 186 (literal -> IDENTIFIER .)
    STRING          reduce using rule 186 (literal -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 186 (literal -> IDENTIFIER .)
    SUPER           reduce using rule 186 (literal -> IDENTIFIER .)
    NOT_SYMBOL      shift and go to state 150
    OPTIONAL_SYMBOL shift and go to state 151

  ! NOT_SYMBOL      [ reduce using rule 186 (literal -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BINARY_AND_OP   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! SUPER           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NOT_SYMBOL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! COMPLEMENT_OP   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DEFINED_OP      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNARY_OP        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LKEY            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RETURN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! YIELD           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNLESS          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNTIL           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CASE            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BEGIN           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CLASS           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DEF             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NUMBER          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! SYMBOL          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! STRING          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_GLOBAL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_LOCAL       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_INSTANCE    [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_CLASS       [ reduce using rule 213 (operation -> IDENTIFIER .) ]


state 73

    (60) arg -> NOT_SYMBOL . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 164
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 74

    (66) arg -> DEFINED_OP . arg
    (93) primary -> DEFINED_OP . LPAREN arg LPAREN
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    LPAREN          shift and go to state 198
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 199
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 75

    (87) primary -> RETURN .
    (88) primary -> RETURN . LPAREN RPAREN
    (89) primary -> RETURN . LPAREN call_args RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACKET        reduce using rule 87 (primary -> RETURN .)
    DOT             reduce using rule 87 (primary -> RETURN .)
    UNARY_OP        reduce using rule 87 (primary -> RETURN .)
    COMMA           reduce using rule 87 (primary -> RETURN .)
    RANGE_INCLUSIVE reduce using rule 87 (primary -> RETURN .)
    RANGE_EXCLUSIVE reduce using rule 87 (primary -> RETURN .)
    OR_SYMBOL       reduce using rule 87 (primary -> RETURN .)
    BINARY_XOR_OP   reduce using rule 87 (primary -> RETURN .)
    BINARY_AND_OP   reduce using rule 87 (primary -> RETURN .)
    COMBINED_COMPARISON_OP reduce using rule 87 (primary -> RETURN .)
    GREATERTHAN     reduce using rule 87 (primary -> RETURN .)
    GREATERTHANEQUAL reduce using rule 87 (primary -> RETURN .)
    LESSERTHAN      reduce using rule 87 (primary -> RETURN .)
    LESSERTHANEQUAL reduce using rule 87 (primary -> RETURN .)
    EQUAL           reduce using rule 87 (primary -> RETURN .)
    CASE_EQUALITY   reduce using rule 87 (primary -> RETURN .)
    NOTEQUAL        reduce using rule 87 (primary -> RETURN .)
    MATCHED_STRINGS_OP reduce using rule 87 (primary -> RETURN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 87 (primary -> RETURN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 87 (primary -> RETURN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 87 (primary -> RETURN .)
    AND             reduce using rule 87 (primary -> RETURN .)
    OR              reduce using rule 87 (primary -> RETURN .)
    PLUS            reduce using rule 87 (primary -> RETURN .)
    MINUS           reduce using rule 87 (primary -> RETURN .)
    TIMES           reduce using rule 87 (primary -> RETURN .)
    DIVIDE          reduce using rule 87 (primary -> RETURN .)
    MOD             reduce using rule 87 (primary -> RETURN .)
    POW             reduce using rule 87 (primary -> RETURN .)
    RBRACKET        reduce using rule 87 (primary -> RETURN .)
    HASH_ROCKET     reduce using rule 87 (primary -> RETURN .)
    RKEY            reduce using rule 87 (primary -> RETURN .)
    IF              reduce using rule 87 (primary -> RETURN .)
    WHILE           reduce using rule 87 (primary -> RETURN .)
    UNLESS          reduce using rule 87 (primary -> RETURN .)
    UNTIL           reduce using rule 87 (primary -> RETURN .)
    TERM            reduce using rule 87 (primary -> RETURN .)
    $end            reduce using rule 87 (primary -> RETURN .)
    THEN            reduce using rule 87 (primary -> RETURN .)
    DO              reduce using rule 87 (primary -> RETURN .)
    RESCUE          reduce using rule 87 (primary -> RETURN .)
    RPAREN          reduce using rule 87 (primary -> RETURN .)
    WHEN            reduce using rule 87 (primary -> RETURN .)
    LKEY            reduce using rule 87 (primary -> RETURN .)
    END             reduce using rule 87 (primary -> RETURN .)
    ELSIF           reduce using rule 87 (primary -> RETURN .)
    ELSE            reduce using rule 87 (primary -> RETURN .)
    ENSURE          reduce using rule 87 (primary -> RETURN .)
    NOT_SYMBOL      reduce using rule 87 (primary -> RETURN .)
    COMPLEMENT_OP   reduce using rule 87 (primary -> RETURN .)
    DEFINED_OP      reduce using rule 87 (primary -> RETURN .)
    NUMBER          reduce using rule 87 (primary -> RETURN .)
    RETURN          reduce using rule 87 (primary -> RETURN .)
    YIELD           reduce using rule 87 (primary -> RETURN .)
    CASE            reduce using rule 87 (primary -> RETURN .)
    FOR             reduce using rule 87 (primary -> RETURN .)
    BEGIN           reduce using rule 87 (primary -> RETURN .)
    CLASS           reduce using rule 87 (primary -> RETURN .)
    MODULE          reduce using rule 87 (primary -> RETURN .)
    DEF             reduce using rule 87 (primary -> RETURN .)
    VAR_GLOBAL      reduce using rule 87 (primary -> RETURN .)
    VAR_LOCAL       reduce using rule 87 (primary -> RETURN .)
    VAR_INSTANCE    reduce using rule 87 (primary -> RETURN .)
    VAR_CLASS       reduce using rule 87 (primary -> RETURN .)
    SYMBOL          reduce using rule 87 (primary -> RETURN .)
    STRING          reduce using rule 87 (primary -> RETURN .)
    IDENTIFIER      reduce using rule 87 (primary -> RETURN .)
    SUPER           reduce using rule 87 (primary -> RETURN .)
    LPAREN          shift and go to state 240

  ! LPAREN          [ reduce using rule 87 (primary -> RETURN .) ]


state 76

    (90) primary -> YIELD .
    (91) primary -> YIELD . LPAREN RPAREN
    (92) primary -> YIELD . LPAREN call_args RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    LBRACKET        reduce using rule 90 (primary -> YIELD .)
    DOT             reduce using rule 90 (primary -> YIELD .)
    UNARY_OP        reduce using rule 90 (primary -> YIELD .)
    COMMA           reduce using rule 90 (primary -> YIELD .)
    RANGE_INCLUSIVE reduce using rule 90 (primary -> YIELD .)
    RANGE_EXCLUSIVE reduce using rule 90 (primary -> YIELD .)
    OR_SYMBOL       reduce using rule 90 (primary -> YIELD .)
    BINARY_XOR_OP   reduce using rule 90 (primary -> YIELD .)
    BINARY_AND_OP   reduce using rule 90 (primary -> YIELD .)
    COMBINED_COMPARISON_OP reduce using rule 90 (primary -> YIELD .)
    GREATERTHAN     reduce using rule 90 (primary -> YIELD .)
    GREATERTHANEQUAL reduce using rule 90 (primary -> YIELD .)
    LESSERTHAN      reduce using rule 90 (primary -> YIELD .)
    LESSERTHANEQUAL reduce using rule 90 (primary -> YIELD .)
    EQUAL           reduce using rule 90 (primary -> YIELD .)
    CASE_EQUALITY   reduce using rule 90 (primary -> YIELD .)
    NOTEQUAL        reduce using rule 90 (primary -> YIELD .)
    MATCHED_STRINGS_OP reduce using rule 90 (primary -> YIELD .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 90 (primary -> YIELD .)
    BINARY_LEFT_SHIFT_OP reduce using rule 90 (primary -> YIELD .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 90 (primary -> YIELD .)
    AND             reduce using rule 90 (primary -> YIELD .)
    OR              reduce using rule 90 (primary -> YIELD .)
    PLUS            reduce using rule 90 (primary -> YIELD .)
    MINUS           reduce using rule 90 (primary -> YIELD .)
    TIMES           reduce using rule 90 (primary -> YIELD .)
    DIVIDE          reduce using rule 90 (primary -> YIELD .)
    MOD             reduce using rule 90 (primary -> YIELD .)
    POW             reduce using rule 90 (primary -> YIELD .)
    RBRACKET        reduce using rule 90 (primary -> YIELD .)
    HASH_ROCKET     reduce using rule 90 (primary -> YIELD .)
    RKEY            reduce using rule 90 (primary -> YIELD .)
    IF              reduce using rule 90 (primary -> YIELD .)
    WHILE           reduce using rule 90 (primary -> YIELD .)
    UNLESS          reduce using rule 90 (primary -> YIELD .)
    UNTIL           reduce using rule 90 (primary -> YIELD .)
    TERM            reduce using rule 90 (primary -> YIELD .)
    $end            reduce using rule 90 (primary -> YIELD .)
    THEN            reduce using rule 90 (primary -> YIELD .)
    DO              reduce using rule 90 (primary -> YIELD .)
    RESCUE          reduce using rule 90 (primary -> YIELD .)
    RPAREN          reduce using rule 90 (primary -> YIELD .)
    WHEN            reduce using rule 90 (primary -> YIELD .)
    LKEY            reduce using rule 90 (primary -> YIELD .)
    END             reduce using rule 90 (primary -> YIELD .)
    ELSIF           reduce using rule 90 (primary -> YIELD .)
    ELSE            reduce using rule 90 (primary -> YIELD .)
    ENSURE          reduce using rule 90 (primary -> YIELD .)
    NOT_SYMBOL      reduce using rule 90 (primary -> YIELD .)
    COMPLEMENT_OP   reduce using rule 90 (primary -> YIELD .)
    DEFINED_OP      reduce using rule 90 (primary -> YIELD .)
    NUMBER          reduce using rule 90 (primary -> YIELD .)
    RETURN          reduce using rule 90 (primary -> YIELD .)
    YIELD           reduce using rule 90 (primary -> YIELD .)
    CASE            reduce using rule 90 (primary -> YIELD .)
    FOR             reduce using rule 90 (primary -> YIELD .)
    BEGIN           reduce using rule 90 (primary -> YIELD .)
    CLASS           reduce using rule 90 (primary -> YIELD .)
    MODULE          reduce using rule 90 (primary -> YIELD .)
    DEF             reduce using rule 90 (primary -> YIELD .)
    VAR_GLOBAL      reduce using rule 90 (primary -> YIELD .)
    VAR_LOCAL       reduce using rule 90 (primary -> YIELD .)
    VAR_INSTANCE    reduce using rule 90 (primary -> YIELD .)
    VAR_CLASS       reduce using rule 90 (primary -> YIELD .)
    SYMBOL          reduce using rule 90 (primary -> YIELD .)
    STRING          reduce using rule 90 (primary -> YIELD .)
    IDENTIFIER      reduce using rule 90 (primary -> YIELD .)
    SUPER           reduce using rule 90 (primary -> YIELD .)
    LPAREN          shift and go to state 241

  ! LPAREN          [ reduce using rule 90 (primary -> YIELD .) ]


state 77

    (94) primary -> function .
    (95) primary -> function . LKEY compstmt LKEY
    (96) primary -> function . LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> function . LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY

  ! shift/reduce conflict for LKEY resolved as shift
    LBRACKET        reduce using rule 94 (primary -> function .)
    DOT             reduce using rule 94 (primary -> function .)
    UNARY_OP        reduce using rule 94 (primary -> function .)
    COMMA           reduce using rule 94 (primary -> function .)
    RANGE_INCLUSIVE reduce using rule 94 (primary -> function .)
    RANGE_EXCLUSIVE reduce using rule 94 (primary -> function .)
    OR_SYMBOL       reduce using rule 94 (primary -> function .)
    BINARY_XOR_OP   reduce using rule 94 (primary -> function .)
    BINARY_AND_OP   reduce using rule 94 (primary -> function .)
    COMBINED_COMPARISON_OP reduce using rule 94 (primary -> function .)
    GREATERTHAN     reduce using rule 94 (primary -> function .)
    GREATERTHANEQUAL reduce using rule 94 (primary -> function .)
    LESSERTHAN      reduce using rule 94 (primary -> function .)
    LESSERTHANEQUAL reduce using rule 94 (primary -> function .)
    EQUAL           reduce using rule 94 (primary -> function .)
    CASE_EQUALITY   reduce using rule 94 (primary -> function .)
    NOTEQUAL        reduce using rule 94 (primary -> function .)
    MATCHED_STRINGS_OP reduce using rule 94 (primary -> function .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 94 (primary -> function .)
    BINARY_LEFT_SHIFT_OP reduce using rule 94 (primary -> function .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 94 (primary -> function .)
    AND             reduce using rule 94 (primary -> function .)
    OR              reduce using rule 94 (primary -> function .)
    PLUS            reduce using rule 94 (primary -> function .)
    MINUS           reduce using rule 94 (primary -> function .)
    TIMES           reduce using rule 94 (primary -> function .)
    DIVIDE          reduce using rule 94 (primary -> function .)
    MOD             reduce using rule 94 (primary -> function .)
    POW             reduce using rule 94 (primary -> function .)
    RBRACKET        reduce using rule 94 (primary -> function .)
    TERM            reduce using rule 94 (primary -> function .)
    THEN            reduce using rule 94 (primary -> function .)
    DO              reduce using rule 94 (primary -> function .)
    HASH_ROCKET     reduce using rule 94 (primary -> function .)
    RKEY            reduce using rule 94 (primary -> function .)
    IF              reduce using rule 94 (primary -> function .)
    WHILE           reduce using rule 94 (primary -> function .)
    UNLESS          reduce using rule 94 (primary -> function .)
    UNTIL           reduce using rule 94 (primary -> function .)
    $end            reduce using rule 94 (primary -> function .)
    RESCUE          reduce using rule 94 (primary -> function .)
    RPAREN          reduce using rule 94 (primary -> function .)
    WHEN            reduce using rule 94 (primary -> function .)
    END             reduce using rule 94 (primary -> function .)
    ELSIF           reduce using rule 94 (primary -> function .)
    ELSE            reduce using rule 94 (primary -> function .)
    ENSURE          reduce using rule 94 (primary -> function .)
    NOT_SYMBOL      reduce using rule 94 (primary -> function .)
    COMPLEMENT_OP   reduce using rule 94 (primary -> function .)
    DEFINED_OP      reduce using rule 94 (primary -> function .)
    NUMBER          reduce using rule 94 (primary -> function .)
    LPAREN          reduce using rule 94 (primary -> function .)
    RETURN          reduce using rule 94 (primary -> function .)
    YIELD           reduce using rule 94 (primary -> function .)
    CASE            reduce using rule 94 (primary -> function .)
    FOR             reduce using rule 94 (primary -> function .)
    BEGIN           reduce using rule 94 (primary -> function .)
    CLASS           reduce using rule 94 (primary -> function .)
    MODULE          reduce using rule 94 (primary -> function .)
    DEF             reduce using rule 94 (primary -> function .)
    VAR_GLOBAL      reduce using rule 94 (primary -> function .)
    VAR_LOCAL       reduce using rule 94 (primary -> function .)
    VAR_INSTANCE    reduce using rule 94 (primary -> function .)
    VAR_CLASS       reduce using rule 94 (primary -> function .)
    SYMBOL          reduce using rule 94 (primary -> function .)
    STRING          reduce using rule 94 (primary -> function .)
    IDENTIFIER      reduce using rule 94 (primary -> function .)
    SUPER           reduce using rule 94 (primary -> function .)
    LKEY            shift and go to state 146

  ! LKEY            [ reduce using rule 94 (primary -> function .) ]


state 78

    (108) primary -> BEGIN . compstmt rescue END
    (109) primary -> BEGIN . compstmt rescue ELSE compstmt END
    (110) primary -> BEGIN . compstmt rescue ENSURE compstmt END
    (111) primary -> BEGIN . compstmt rescue ELSE compstmt ENSURE compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 122
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 79

    (235) math_operations -> NUMBER . PLUS NUMBER
    (236) math_operations -> NUMBER . MINUS NUMBER
    (237) math_operations -> NUMBER . TIMES NUMBER
    (238) math_operations -> NUMBER . DIVIDE NUMBER
    (239) math_operations -> NUMBER . MOD NUMBER
    (240) math_operations -> NUMBER . POW NUMBER
    (183) literal -> NUMBER .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    PLUS            shift and go to state 217
    MINUS           shift and go to state 218
    TIMES           shift and go to state 219
    DIVIDE          shift and go to state 220
    MOD             shift and go to state 221
    POW             shift and go to state 222
    LBRACKET        reduce using rule 183 (literal -> NUMBER .)
    DOT             reduce using rule 183 (literal -> NUMBER .)
    UNARY_OP        reduce using rule 183 (literal -> NUMBER .)
    COMMA           reduce using rule 183 (literal -> NUMBER .)
    RANGE_INCLUSIVE reduce using rule 183 (literal -> NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 183 (literal -> NUMBER .)
    OR_SYMBOL       reduce using rule 183 (literal -> NUMBER .)
    BINARY_XOR_OP   reduce using rule 183 (literal -> NUMBER .)
    BINARY_AND_OP   reduce using rule 183 (literal -> NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 183 (literal -> NUMBER .)
    GREATERTHAN     reduce using rule 183 (literal -> NUMBER .)
    GREATERTHANEQUAL reduce using rule 183 (literal -> NUMBER .)
    LESSERTHAN      reduce using rule 183 (literal -> NUMBER .)
    LESSERTHANEQUAL reduce using rule 183 (literal -> NUMBER .)
    EQUAL           reduce using rule 183 (literal -> NUMBER .)
    CASE_EQUALITY   reduce using rule 183 (literal -> NUMBER .)
    NOTEQUAL        reduce using rule 183 (literal -> NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 183 (literal -> NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 183 (literal -> NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 183 (literal -> NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 183 (literal -> NUMBER .)
    AND             reduce using rule 183 (literal -> NUMBER .)
    OR              reduce using rule 183 (literal -> NUMBER .)
    RBRACKET        reduce using rule 183 (literal -> NUMBER .)
    TERM            reduce using rule 183 (literal -> NUMBER .)
    THEN            reduce using rule 183 (literal -> NUMBER .)
    DO              reduce using rule 183 (literal -> NUMBER .)
    HASH_ROCKET     reduce using rule 183 (literal -> NUMBER .)
    RKEY            reduce using rule 183 (literal -> NUMBER .)
    IF              reduce using rule 183 (literal -> NUMBER .)
    WHILE           reduce using rule 183 (literal -> NUMBER .)
    UNLESS          reduce using rule 183 (literal -> NUMBER .)
    UNTIL           reduce using rule 183 (literal -> NUMBER .)
    $end            reduce using rule 183 (literal -> NUMBER .)
    RESCUE          reduce using rule 183 (literal -> NUMBER .)
    RPAREN          reduce using rule 183 (literal -> NUMBER .)
    WHEN            reduce using rule 183 (literal -> NUMBER .)
    LKEY            reduce using rule 183 (literal -> NUMBER .)
    END             reduce using rule 183 (literal -> NUMBER .)
    ELSIF           reduce using rule 183 (literal -> NUMBER .)
    ELSE            reduce using rule 183 (literal -> NUMBER .)
    ENSURE          reduce using rule 183 (literal -> NUMBER .)
    NOT_SYMBOL      reduce using rule 183 (literal -> NUMBER .)
    COMPLEMENT_OP   reduce using rule 183 (literal -> NUMBER .)
    DEFINED_OP      reduce using rule 183 (literal -> NUMBER .)
    NUMBER          reduce using rule 183 (literal -> NUMBER .)
    LPAREN          reduce using rule 183 (literal -> NUMBER .)
    RETURN          reduce using rule 183 (literal -> NUMBER .)
    YIELD           reduce using rule 183 (literal -> NUMBER .)
    CASE            reduce using rule 183 (literal -> NUMBER .)
    FOR             reduce using rule 183 (literal -> NUMBER .)
    BEGIN           reduce using rule 183 (literal -> NUMBER .)
    CLASS           reduce using rule 183 (literal -> NUMBER .)
    MODULE          reduce using rule 183 (literal -> NUMBER .)
    DEF             reduce using rule 183 (literal -> NUMBER .)
    VAR_GLOBAL      reduce using rule 183 (literal -> NUMBER .)
    VAR_LOCAL       reduce using rule 183 (literal -> NUMBER .)
    VAR_INSTANCE    reduce using rule 183 (literal -> NUMBER .)
    VAR_CLASS       reduce using rule 183 (literal -> NUMBER .)
    SYMBOL          reduce using rule 183 (literal -> NUMBER .)
    STRING          reduce using rule 183 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 183 (literal -> NUMBER .)
    SUPER           reduce using rule 183 (literal -> NUMBER .)

  ! PLUS            [ reduce using rule 183 (literal -> NUMBER .) ]
  ! MINUS           [ reduce using rule 183 (literal -> NUMBER .) ]
  ! TIMES           [ reduce using rule 183 (literal -> NUMBER .) ]
  ! DIVIDE          [ reduce using rule 183 (literal -> NUMBER .) ]
  ! MOD             [ reduce using rule 183 (literal -> NUMBER .) ]
  ! POW             [ reduce using rule 183 (literal -> NUMBER .) ]


state 80

    (33) function -> operation . LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET

    LBRACKET        shift and go to state 242


state 81

    (38) function -> SUPER . LPAREN call_args RPAREN
    (39) function -> SUPER .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 243
    LKEY            reduce using rule 39 (function -> SUPER .)
    LBRACKET        reduce using rule 39 (function -> SUPER .)
    DOT             reduce using rule 39 (function -> SUPER .)
    UNARY_OP        reduce using rule 39 (function -> SUPER .)
    COMMA           reduce using rule 39 (function -> SUPER .)
    RANGE_INCLUSIVE reduce using rule 39 (function -> SUPER .)
    RANGE_EXCLUSIVE reduce using rule 39 (function -> SUPER .)
    OR_SYMBOL       reduce using rule 39 (function -> SUPER .)
    BINARY_XOR_OP   reduce using rule 39 (function -> SUPER .)
    BINARY_AND_OP   reduce using rule 39 (function -> SUPER .)
    COMBINED_COMPARISON_OP reduce using rule 39 (function -> SUPER .)
    GREATERTHAN     reduce using rule 39 (function -> SUPER .)
    GREATERTHANEQUAL reduce using rule 39 (function -> SUPER .)
    LESSERTHAN      reduce using rule 39 (function -> SUPER .)
    LESSERTHANEQUAL reduce using rule 39 (function -> SUPER .)
    EQUAL           reduce using rule 39 (function -> SUPER .)
    CASE_EQUALITY   reduce using rule 39 (function -> SUPER .)
    NOTEQUAL        reduce using rule 39 (function -> SUPER .)
    MATCHED_STRINGS_OP reduce using rule 39 (function -> SUPER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 39 (function -> SUPER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 39 (function -> SUPER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 39 (function -> SUPER .)
    AND             reduce using rule 39 (function -> SUPER .)
    OR              reduce using rule 39 (function -> SUPER .)
    PLUS            reduce using rule 39 (function -> SUPER .)
    MINUS           reduce using rule 39 (function -> SUPER .)
    TIMES           reduce using rule 39 (function -> SUPER .)
    DIVIDE          reduce using rule 39 (function -> SUPER .)
    MOD             reduce using rule 39 (function -> SUPER .)
    POW             reduce using rule 39 (function -> SUPER .)
    RBRACKET        reduce using rule 39 (function -> SUPER .)
    HASH_ROCKET     reduce using rule 39 (function -> SUPER .)
    RKEY            reduce using rule 39 (function -> SUPER .)
    IF              reduce using rule 39 (function -> SUPER .)
    WHILE           reduce using rule 39 (function -> SUPER .)
    UNLESS          reduce using rule 39 (function -> SUPER .)
    UNTIL           reduce using rule 39 (function -> SUPER .)
    TERM            reduce using rule 39 (function -> SUPER .)
    $end            reduce using rule 39 (function -> SUPER .)
    RESCUE          reduce using rule 39 (function -> SUPER .)
    RPAREN          reduce using rule 39 (function -> SUPER .)
    WHEN            reduce using rule 39 (function -> SUPER .)
    END             reduce using rule 39 (function -> SUPER .)
    ELSIF           reduce using rule 39 (function -> SUPER .)
    ELSE            reduce using rule 39 (function -> SUPER .)
    ENSURE          reduce using rule 39 (function -> SUPER .)
    THEN            reduce using rule 39 (function -> SUPER .)
    DO              reduce using rule 39 (function -> SUPER .)
    NOT_SYMBOL      reduce using rule 39 (function -> SUPER .)
    COMPLEMENT_OP   reduce using rule 39 (function -> SUPER .)
    DEFINED_OP      reduce using rule 39 (function -> SUPER .)
    NUMBER          reduce using rule 39 (function -> SUPER .)
    RETURN          reduce using rule 39 (function -> SUPER .)
    YIELD           reduce using rule 39 (function -> SUPER .)
    CASE            reduce using rule 39 (function -> SUPER .)
    FOR             reduce using rule 39 (function -> SUPER .)
    BEGIN           reduce using rule 39 (function -> SUPER .)
    CLASS           reduce using rule 39 (function -> SUPER .)
    MODULE          reduce using rule 39 (function -> SUPER .)
    DEF             reduce using rule 39 (function -> SUPER .)
    VAR_GLOBAL      reduce using rule 39 (function -> SUPER .)
    VAR_LOCAL       reduce using rule 39 (function -> SUPER .)
    VAR_INSTANCE    reduce using rule 39 (function -> SUPER .)
    VAR_CLASS       reduce using rule 39 (function -> SUPER .)
    SYMBOL          reduce using rule 39 (function -> SUPER .)
    STRING          reduce using rule 39 (function -> SUPER .)
    IDENTIFIER      reduce using rule 39 (function -> SUPER .)
    SUPER           reduce using rule 39 (function -> SUPER .)

  ! LPAREN          [ reduce using rule 39 (function -> SUPER .) ]


state 82

    (15) stmt -> END LKEY . compstmt RKEY
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 244
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 83

    (8) stmt -> UNDEF fname .

    IF              reduce using rule 8 (stmt -> UNDEF fname .)
    WHILE           reduce using rule 8 (stmt -> UNDEF fname .)
    UNLESS          reduce using rule 8 (stmt -> UNDEF fname .)
    UNTIL           reduce using rule 8 (stmt -> UNDEF fname .)
    TERM            reduce using rule 8 (stmt -> UNDEF fname .)
    $end            reduce using rule 8 (stmt -> UNDEF fname .)
    RESCUE          reduce using rule 8 (stmt -> UNDEF fname .)
    RPAREN          reduce using rule 8 (stmt -> UNDEF fname .)
    WHEN            reduce using rule 8 (stmt -> UNDEF fname .)
    RKEY            reduce using rule 8 (stmt -> UNDEF fname .)
    LKEY            reduce using rule 8 (stmt -> UNDEF fname .)
    END             reduce using rule 8 (stmt -> UNDEF fname .)
    ELSIF           reduce using rule 8 (stmt -> UNDEF fname .)
    ELSE            reduce using rule 8 (stmt -> UNDEF fname .)
    ENSURE          reduce using rule 8 (stmt -> UNDEF fname .)


state 84

    (187) fname -> IDENTIFIER .

    IF              reduce using rule 187 (fname -> IDENTIFIER .)
    WHILE           reduce using rule 187 (fname -> IDENTIFIER .)
    UNLESS          reduce using rule 187 (fname -> IDENTIFIER .)
    UNTIL           reduce using rule 187 (fname -> IDENTIFIER .)
    TERM            reduce using rule 187 (fname -> IDENTIFIER .)
    $end            reduce using rule 187 (fname -> IDENTIFIER .)
    RESCUE          reduce using rule 187 (fname -> IDENTIFIER .)
    RPAREN          reduce using rule 187 (fname -> IDENTIFIER .)
    WHEN            reduce using rule 187 (fname -> IDENTIFIER .)
    RKEY            reduce using rule 187 (fname -> IDENTIFIER .)
    LKEY            reduce using rule 187 (fname -> IDENTIFIER .)
    END             reduce using rule 187 (fname -> IDENTIFIER .)
    ELSIF           reduce using rule 187 (fname -> IDENTIFIER .)
    ELSE            reduce using rule 187 (fname -> IDENTIFIER .)
    ENSURE          reduce using rule 187 (fname -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 187 (fname -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 187 (fname -> IDENTIFIER .)
    OR_SYMBOL       reduce using rule 187 (fname -> IDENTIFIER .)
    BINARY_AND_OP   reduce using rule 187 (fname -> IDENTIFIER .)
    BINARY_XOR_OP   reduce using rule 187 (fname -> IDENTIFIER .)
    COMBINED_COMPARISON_OP reduce using rule 187 (fname -> IDENTIFIER .)
    EQUAL           reduce using rule 187 (fname -> IDENTIFIER .)
    CASE_EQUALITY   reduce using rule 187 (fname -> IDENTIFIER .)
    MATCHED_STRINGS_OP reduce using rule 187 (fname -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 187 (fname -> IDENTIFIER .)
    GREATERTHANEQUAL reduce using rule 187 (fname -> IDENTIFIER .)
    LESSERTHAN      reduce using rule 187 (fname -> IDENTIFIER .)
    LESSERTHANEQUAL reduce using rule 187 (fname -> IDENTIFIER .)
    PLUS            reduce using rule 187 (fname -> IDENTIFIER .)
    MINUS           reduce using rule 187 (fname -> IDENTIFIER .)
    TIMES           reduce using rule 187 (fname -> IDENTIFIER .)
    DIVIDE          reduce using rule 187 (fname -> IDENTIFIER .)
    MOD             reduce using rule 187 (fname -> IDENTIFIER .)
    POW             reduce using rule 187 (fname -> IDENTIFIER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 187 (fname -> IDENTIFIER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 187 (fname -> IDENTIFIER .)
    COMPLEMENT_OP   reduce using rule 187 (fname -> IDENTIFIER .)
    OVERLOAD_PLUS   reduce using rule 187 (fname -> IDENTIFIER .)
    OVERLOAD_MINUS  reduce using rule 187 (fname -> IDENTIFIER .)
    LBRACKET        reduce using rule 187 (fname -> IDENTIFIER .)
    LPAREN          reduce using rule 187 (fname -> IDENTIFIER .)


state 85

    (188) fname -> RANGE_INCLUSIVE .

    IF              reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    WHILE           reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    UNLESS          reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    UNTIL           reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    TERM            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    $end            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    RESCUE          reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    RPAREN          reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    WHEN            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    RKEY            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    LKEY            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    END             reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    ELSIF           reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    ELSE            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    ENSURE          reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    IDENTIFIER      reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    RANGE_INCLUSIVE reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    OR_SYMBOL       reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    BINARY_AND_OP   reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    BINARY_XOR_OP   reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    COMBINED_COMPARISON_OP reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    EQUAL           reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    CASE_EQUALITY   reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    MATCHED_STRINGS_OP reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    GREATERTHAN     reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    GREATERTHANEQUAL reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    LESSERTHAN      reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    LESSERTHANEQUAL reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    PLUS            reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    MINUS           reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    TIMES           reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    DIVIDE          reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    MOD             reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    POW             reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    BINARY_LEFT_SHIFT_OP reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    COMPLEMENT_OP   reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    OVERLOAD_PLUS   reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    OVERLOAD_MINUS  reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    LBRACKET        reduce using rule 188 (fname -> RANGE_INCLUSIVE .)
    LPAREN          reduce using rule 188 (fname -> RANGE_INCLUSIVE .)


state 86

    (189) fname -> OR_SYMBOL .

    IF              reduce using rule 189 (fname -> OR_SYMBOL .)
    WHILE           reduce using rule 189 (fname -> OR_SYMBOL .)
    UNLESS          reduce using rule 189 (fname -> OR_SYMBOL .)
    UNTIL           reduce using rule 189 (fname -> OR_SYMBOL .)
    TERM            reduce using rule 189 (fname -> OR_SYMBOL .)
    $end            reduce using rule 189 (fname -> OR_SYMBOL .)
    RESCUE          reduce using rule 189 (fname -> OR_SYMBOL .)
    RPAREN          reduce using rule 189 (fname -> OR_SYMBOL .)
    WHEN            reduce using rule 189 (fname -> OR_SYMBOL .)
    RKEY            reduce using rule 189 (fname -> OR_SYMBOL .)
    LKEY            reduce using rule 189 (fname -> OR_SYMBOL .)
    END             reduce using rule 189 (fname -> OR_SYMBOL .)
    ELSIF           reduce using rule 189 (fname -> OR_SYMBOL .)
    ELSE            reduce using rule 189 (fname -> OR_SYMBOL .)
    ENSURE          reduce using rule 189 (fname -> OR_SYMBOL .)
    IDENTIFIER      reduce using rule 189 (fname -> OR_SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 189 (fname -> OR_SYMBOL .)
    OR_SYMBOL       reduce using rule 189 (fname -> OR_SYMBOL .)
    BINARY_AND_OP   reduce using rule 189 (fname -> OR_SYMBOL .)
    BINARY_XOR_OP   reduce using rule 189 (fname -> OR_SYMBOL .)
    COMBINED_COMPARISON_OP reduce using rule 189 (fname -> OR_SYMBOL .)
    EQUAL           reduce using rule 189 (fname -> OR_SYMBOL .)
    CASE_EQUALITY   reduce using rule 189 (fname -> OR_SYMBOL .)
    MATCHED_STRINGS_OP reduce using rule 189 (fname -> OR_SYMBOL .)
    GREATERTHAN     reduce using rule 189 (fname -> OR_SYMBOL .)
    GREATERTHANEQUAL reduce using rule 189 (fname -> OR_SYMBOL .)
    LESSERTHAN      reduce using rule 189 (fname -> OR_SYMBOL .)
    LESSERTHANEQUAL reduce using rule 189 (fname -> OR_SYMBOL .)
    PLUS            reduce using rule 189 (fname -> OR_SYMBOL .)
    MINUS           reduce using rule 189 (fname -> OR_SYMBOL .)
    TIMES           reduce using rule 189 (fname -> OR_SYMBOL .)
    DIVIDE          reduce using rule 189 (fname -> OR_SYMBOL .)
    MOD             reduce using rule 189 (fname -> OR_SYMBOL .)
    POW             reduce using rule 189 (fname -> OR_SYMBOL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 189 (fname -> OR_SYMBOL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 189 (fname -> OR_SYMBOL .)
    COMPLEMENT_OP   reduce using rule 189 (fname -> OR_SYMBOL .)
    OVERLOAD_PLUS   reduce using rule 189 (fname -> OR_SYMBOL .)
    OVERLOAD_MINUS  reduce using rule 189 (fname -> OR_SYMBOL .)
    LBRACKET        reduce using rule 189 (fname -> OR_SYMBOL .)
    LPAREN          reduce using rule 189 (fname -> OR_SYMBOL .)


state 87

    (190) fname -> BINARY_AND_OP .

    IF              reduce using rule 190 (fname -> BINARY_AND_OP .)
    WHILE           reduce using rule 190 (fname -> BINARY_AND_OP .)
    UNLESS          reduce using rule 190 (fname -> BINARY_AND_OP .)
    UNTIL           reduce using rule 190 (fname -> BINARY_AND_OP .)
    TERM            reduce using rule 190 (fname -> BINARY_AND_OP .)
    $end            reduce using rule 190 (fname -> BINARY_AND_OP .)
    RESCUE          reduce using rule 190 (fname -> BINARY_AND_OP .)
    RPAREN          reduce using rule 190 (fname -> BINARY_AND_OP .)
    WHEN            reduce using rule 190 (fname -> BINARY_AND_OP .)
    RKEY            reduce using rule 190 (fname -> BINARY_AND_OP .)
    LKEY            reduce using rule 190 (fname -> BINARY_AND_OP .)
    END             reduce using rule 190 (fname -> BINARY_AND_OP .)
    ELSIF           reduce using rule 190 (fname -> BINARY_AND_OP .)
    ELSE            reduce using rule 190 (fname -> BINARY_AND_OP .)
    ENSURE          reduce using rule 190 (fname -> BINARY_AND_OP .)
    IDENTIFIER      reduce using rule 190 (fname -> BINARY_AND_OP .)
    RANGE_INCLUSIVE reduce using rule 190 (fname -> BINARY_AND_OP .)
    OR_SYMBOL       reduce using rule 190 (fname -> BINARY_AND_OP .)
    BINARY_AND_OP   reduce using rule 190 (fname -> BINARY_AND_OP .)
    BINARY_XOR_OP   reduce using rule 190 (fname -> BINARY_AND_OP .)
    COMBINED_COMPARISON_OP reduce using rule 190 (fname -> BINARY_AND_OP .)
    EQUAL           reduce using rule 190 (fname -> BINARY_AND_OP .)
    CASE_EQUALITY   reduce using rule 190 (fname -> BINARY_AND_OP .)
    MATCHED_STRINGS_OP reduce using rule 190 (fname -> BINARY_AND_OP .)
    GREATERTHAN     reduce using rule 190 (fname -> BINARY_AND_OP .)
    GREATERTHANEQUAL reduce using rule 190 (fname -> BINARY_AND_OP .)
    LESSERTHAN      reduce using rule 190 (fname -> BINARY_AND_OP .)
    LESSERTHANEQUAL reduce using rule 190 (fname -> BINARY_AND_OP .)
    PLUS            reduce using rule 190 (fname -> BINARY_AND_OP .)
    MINUS           reduce using rule 190 (fname -> BINARY_AND_OP .)
    TIMES           reduce using rule 190 (fname -> BINARY_AND_OP .)
    DIVIDE          reduce using rule 190 (fname -> BINARY_AND_OP .)
    MOD             reduce using rule 190 (fname -> BINARY_AND_OP .)
    POW             reduce using rule 190 (fname -> BINARY_AND_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 190 (fname -> BINARY_AND_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 190 (fname -> BINARY_AND_OP .)
    COMPLEMENT_OP   reduce using rule 190 (fname -> BINARY_AND_OP .)
    OVERLOAD_PLUS   reduce using rule 190 (fname -> BINARY_AND_OP .)
    OVERLOAD_MINUS  reduce using rule 190 (fname -> BINARY_AND_OP .)
    LBRACKET        reduce using rule 190 (fname -> BINARY_AND_OP .)
    LPAREN          reduce using rule 190 (fname -> BINARY_AND_OP .)


state 88

    (191) fname -> BINARY_XOR_OP .

    IF              reduce using rule 191 (fname -> BINARY_XOR_OP .)
    WHILE           reduce using rule 191 (fname -> BINARY_XOR_OP .)
    UNLESS          reduce using rule 191 (fname -> BINARY_XOR_OP .)
    UNTIL           reduce using rule 191 (fname -> BINARY_XOR_OP .)
    TERM            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    $end            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    RESCUE          reduce using rule 191 (fname -> BINARY_XOR_OP .)
    RPAREN          reduce using rule 191 (fname -> BINARY_XOR_OP .)
    WHEN            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    RKEY            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    LKEY            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    END             reduce using rule 191 (fname -> BINARY_XOR_OP .)
    ELSIF           reduce using rule 191 (fname -> BINARY_XOR_OP .)
    ELSE            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    ENSURE          reduce using rule 191 (fname -> BINARY_XOR_OP .)
    IDENTIFIER      reduce using rule 191 (fname -> BINARY_XOR_OP .)
    RANGE_INCLUSIVE reduce using rule 191 (fname -> BINARY_XOR_OP .)
    OR_SYMBOL       reduce using rule 191 (fname -> BINARY_XOR_OP .)
    BINARY_AND_OP   reduce using rule 191 (fname -> BINARY_XOR_OP .)
    BINARY_XOR_OP   reduce using rule 191 (fname -> BINARY_XOR_OP .)
    COMBINED_COMPARISON_OP reduce using rule 191 (fname -> BINARY_XOR_OP .)
    EQUAL           reduce using rule 191 (fname -> BINARY_XOR_OP .)
    CASE_EQUALITY   reduce using rule 191 (fname -> BINARY_XOR_OP .)
    MATCHED_STRINGS_OP reduce using rule 191 (fname -> BINARY_XOR_OP .)
    GREATERTHAN     reduce using rule 191 (fname -> BINARY_XOR_OP .)
    GREATERTHANEQUAL reduce using rule 191 (fname -> BINARY_XOR_OP .)
    LESSERTHAN      reduce using rule 191 (fname -> BINARY_XOR_OP .)
    LESSERTHANEQUAL reduce using rule 191 (fname -> BINARY_XOR_OP .)
    PLUS            reduce using rule 191 (fname -> BINARY_XOR_OP .)
    MINUS           reduce using rule 191 (fname -> BINARY_XOR_OP .)
    TIMES           reduce using rule 191 (fname -> BINARY_XOR_OP .)
    DIVIDE          reduce using rule 191 (fname -> BINARY_XOR_OP .)
    MOD             reduce using rule 191 (fname -> BINARY_XOR_OP .)
    POW             reduce using rule 191 (fname -> BINARY_XOR_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 191 (fname -> BINARY_XOR_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 191 (fname -> BINARY_XOR_OP .)
    COMPLEMENT_OP   reduce using rule 191 (fname -> BINARY_XOR_OP .)
    OVERLOAD_PLUS   reduce using rule 191 (fname -> BINARY_XOR_OP .)
    OVERLOAD_MINUS  reduce using rule 191 (fname -> BINARY_XOR_OP .)
    LBRACKET        reduce using rule 191 (fname -> BINARY_XOR_OP .)
    LPAREN          reduce using rule 191 (fname -> BINARY_XOR_OP .)


state 89

    (192) fname -> COMBINED_COMPARISON_OP .

    IF              reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    WHILE           reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    UNLESS          reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    UNTIL           reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    TERM            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    $end            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    RESCUE          reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    RPAREN          reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    WHEN            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    RKEY            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    LKEY            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    END             reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    ELSIF           reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    ELSE            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    ENSURE          reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    IDENTIFIER      reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    RANGE_INCLUSIVE reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    OR_SYMBOL       reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    BINARY_AND_OP   reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    BINARY_XOR_OP   reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    COMBINED_COMPARISON_OP reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    EQUAL           reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    CASE_EQUALITY   reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    MATCHED_STRINGS_OP reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    GREATERTHAN     reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    GREATERTHANEQUAL reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    LESSERTHAN      reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    LESSERTHANEQUAL reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    PLUS            reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    MINUS           reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    TIMES           reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    DIVIDE          reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    MOD             reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    POW             reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    COMPLEMENT_OP   reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    OVERLOAD_PLUS   reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    OVERLOAD_MINUS  reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    LBRACKET        reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)
    LPAREN          reduce using rule 192 (fname -> COMBINED_COMPARISON_OP .)


state 90

    (193) fname -> EQUAL .

    IF              reduce using rule 193 (fname -> EQUAL .)
    WHILE           reduce using rule 193 (fname -> EQUAL .)
    UNLESS          reduce using rule 193 (fname -> EQUAL .)
    UNTIL           reduce using rule 193 (fname -> EQUAL .)
    TERM            reduce using rule 193 (fname -> EQUAL .)
    $end            reduce using rule 193 (fname -> EQUAL .)
    RESCUE          reduce using rule 193 (fname -> EQUAL .)
    RPAREN          reduce using rule 193 (fname -> EQUAL .)
    WHEN            reduce using rule 193 (fname -> EQUAL .)
    RKEY            reduce using rule 193 (fname -> EQUAL .)
    LKEY            reduce using rule 193 (fname -> EQUAL .)
    END             reduce using rule 193 (fname -> EQUAL .)
    ELSIF           reduce using rule 193 (fname -> EQUAL .)
    ELSE            reduce using rule 193 (fname -> EQUAL .)
    ENSURE          reduce using rule 193 (fname -> EQUAL .)
    IDENTIFIER      reduce using rule 193 (fname -> EQUAL .)
    RANGE_INCLUSIVE reduce using rule 193 (fname -> EQUAL .)
    OR_SYMBOL       reduce using rule 193 (fname -> EQUAL .)
    BINARY_AND_OP   reduce using rule 193 (fname -> EQUAL .)
    BINARY_XOR_OP   reduce using rule 193 (fname -> EQUAL .)
    COMBINED_COMPARISON_OP reduce using rule 193 (fname -> EQUAL .)
    EQUAL           reduce using rule 193 (fname -> EQUAL .)
    CASE_EQUALITY   reduce using rule 193 (fname -> EQUAL .)
    MATCHED_STRINGS_OP reduce using rule 193 (fname -> EQUAL .)
    GREATERTHAN     reduce using rule 193 (fname -> EQUAL .)
    GREATERTHANEQUAL reduce using rule 193 (fname -> EQUAL .)
    LESSERTHAN      reduce using rule 193 (fname -> EQUAL .)
    LESSERTHANEQUAL reduce using rule 193 (fname -> EQUAL .)
    PLUS            reduce using rule 193 (fname -> EQUAL .)
    MINUS           reduce using rule 193 (fname -> EQUAL .)
    TIMES           reduce using rule 193 (fname -> EQUAL .)
    DIVIDE          reduce using rule 193 (fname -> EQUAL .)
    MOD             reduce using rule 193 (fname -> EQUAL .)
    POW             reduce using rule 193 (fname -> EQUAL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 193 (fname -> EQUAL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 193 (fname -> EQUAL .)
    COMPLEMENT_OP   reduce using rule 193 (fname -> EQUAL .)
    OVERLOAD_PLUS   reduce using rule 193 (fname -> EQUAL .)
    OVERLOAD_MINUS  reduce using rule 193 (fname -> EQUAL .)
    LBRACKET        reduce using rule 193 (fname -> EQUAL .)
    LPAREN          reduce using rule 193 (fname -> EQUAL .)


state 91

    (194) fname -> CASE_EQUALITY .

    IF              reduce using rule 194 (fname -> CASE_EQUALITY .)
    WHILE           reduce using rule 194 (fname -> CASE_EQUALITY .)
    UNLESS          reduce using rule 194 (fname -> CASE_EQUALITY .)
    UNTIL           reduce using rule 194 (fname -> CASE_EQUALITY .)
    TERM            reduce using rule 194 (fname -> CASE_EQUALITY .)
    $end            reduce using rule 194 (fname -> CASE_EQUALITY .)
    RESCUE          reduce using rule 194 (fname -> CASE_EQUALITY .)
    RPAREN          reduce using rule 194 (fname -> CASE_EQUALITY .)
    WHEN            reduce using rule 194 (fname -> CASE_EQUALITY .)
    RKEY            reduce using rule 194 (fname -> CASE_EQUALITY .)
    LKEY            reduce using rule 194 (fname -> CASE_EQUALITY .)
    END             reduce using rule 194 (fname -> CASE_EQUALITY .)
    ELSIF           reduce using rule 194 (fname -> CASE_EQUALITY .)
    ELSE            reduce using rule 194 (fname -> CASE_EQUALITY .)
    ENSURE          reduce using rule 194 (fname -> CASE_EQUALITY .)
    IDENTIFIER      reduce using rule 194 (fname -> CASE_EQUALITY .)
    RANGE_INCLUSIVE reduce using rule 194 (fname -> CASE_EQUALITY .)
    OR_SYMBOL       reduce using rule 194 (fname -> CASE_EQUALITY .)
    BINARY_AND_OP   reduce using rule 194 (fname -> CASE_EQUALITY .)
    BINARY_XOR_OP   reduce using rule 194 (fname -> CASE_EQUALITY .)
    COMBINED_COMPARISON_OP reduce using rule 194 (fname -> CASE_EQUALITY .)
    EQUAL           reduce using rule 194 (fname -> CASE_EQUALITY .)
    CASE_EQUALITY   reduce using rule 194 (fname -> CASE_EQUALITY .)
    MATCHED_STRINGS_OP reduce using rule 194 (fname -> CASE_EQUALITY .)
    GREATERTHAN     reduce using rule 194 (fname -> CASE_EQUALITY .)
    GREATERTHANEQUAL reduce using rule 194 (fname -> CASE_EQUALITY .)
    LESSERTHAN      reduce using rule 194 (fname -> CASE_EQUALITY .)
    LESSERTHANEQUAL reduce using rule 194 (fname -> CASE_EQUALITY .)
    PLUS            reduce using rule 194 (fname -> CASE_EQUALITY .)
    MINUS           reduce using rule 194 (fname -> CASE_EQUALITY .)
    TIMES           reduce using rule 194 (fname -> CASE_EQUALITY .)
    DIVIDE          reduce using rule 194 (fname -> CASE_EQUALITY .)
    MOD             reduce using rule 194 (fname -> CASE_EQUALITY .)
    POW             reduce using rule 194 (fname -> CASE_EQUALITY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 194 (fname -> CASE_EQUALITY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 194 (fname -> CASE_EQUALITY .)
    COMPLEMENT_OP   reduce using rule 194 (fname -> CASE_EQUALITY .)
    OVERLOAD_PLUS   reduce using rule 194 (fname -> CASE_EQUALITY .)
    OVERLOAD_MINUS  reduce using rule 194 (fname -> CASE_EQUALITY .)
    LBRACKET        reduce using rule 194 (fname -> CASE_EQUALITY .)
    LPAREN          reduce using rule 194 (fname -> CASE_EQUALITY .)


state 92

    (195) fname -> MATCHED_STRINGS_OP .

    IF              reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    WHILE           reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    UNLESS          reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    UNTIL           reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    TERM            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    $end            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    RESCUE          reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    RPAREN          reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    WHEN            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    RKEY            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    LKEY            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    END             reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    ELSIF           reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    ELSE            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    ENSURE          reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    IDENTIFIER      reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    RANGE_INCLUSIVE reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    OR_SYMBOL       reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    BINARY_AND_OP   reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    BINARY_XOR_OP   reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    COMBINED_COMPARISON_OP reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    EQUAL           reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    CASE_EQUALITY   reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    MATCHED_STRINGS_OP reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    GREATERTHAN     reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    GREATERTHANEQUAL reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    LESSERTHAN      reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    LESSERTHANEQUAL reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    PLUS            reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    MINUS           reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    TIMES           reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    DIVIDE          reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    MOD             reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    POW             reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    COMPLEMENT_OP   reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    OVERLOAD_PLUS   reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    OVERLOAD_MINUS  reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    LBRACKET        reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)
    LPAREN          reduce using rule 195 (fname -> MATCHED_STRINGS_OP .)


state 93

    (196) fname -> GREATERTHAN .

    IF              reduce using rule 196 (fname -> GREATERTHAN .)
    WHILE           reduce using rule 196 (fname -> GREATERTHAN .)
    UNLESS          reduce using rule 196 (fname -> GREATERTHAN .)
    UNTIL           reduce using rule 196 (fname -> GREATERTHAN .)
    TERM            reduce using rule 196 (fname -> GREATERTHAN .)
    $end            reduce using rule 196 (fname -> GREATERTHAN .)
    RESCUE          reduce using rule 196 (fname -> GREATERTHAN .)
    RPAREN          reduce using rule 196 (fname -> GREATERTHAN .)
    WHEN            reduce using rule 196 (fname -> GREATERTHAN .)
    RKEY            reduce using rule 196 (fname -> GREATERTHAN .)
    LKEY            reduce using rule 196 (fname -> GREATERTHAN .)
    END             reduce using rule 196 (fname -> GREATERTHAN .)
    ELSIF           reduce using rule 196 (fname -> GREATERTHAN .)
    ELSE            reduce using rule 196 (fname -> GREATERTHAN .)
    ENSURE          reduce using rule 196 (fname -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 196 (fname -> GREATERTHAN .)
    RANGE_INCLUSIVE reduce using rule 196 (fname -> GREATERTHAN .)
    OR_SYMBOL       reduce using rule 196 (fname -> GREATERTHAN .)
    BINARY_AND_OP   reduce using rule 196 (fname -> GREATERTHAN .)
    BINARY_XOR_OP   reduce using rule 196 (fname -> GREATERTHAN .)
    COMBINED_COMPARISON_OP reduce using rule 196 (fname -> GREATERTHAN .)
    EQUAL           reduce using rule 196 (fname -> GREATERTHAN .)
    CASE_EQUALITY   reduce using rule 196 (fname -> GREATERTHAN .)
    MATCHED_STRINGS_OP reduce using rule 196 (fname -> GREATERTHAN .)
    GREATERTHAN     reduce using rule 196 (fname -> GREATERTHAN .)
    GREATERTHANEQUAL reduce using rule 196 (fname -> GREATERTHAN .)
    LESSERTHAN      reduce using rule 196 (fname -> GREATERTHAN .)
    LESSERTHANEQUAL reduce using rule 196 (fname -> GREATERTHAN .)
    PLUS            reduce using rule 196 (fname -> GREATERTHAN .)
    MINUS           reduce using rule 196 (fname -> GREATERTHAN .)
    TIMES           reduce using rule 196 (fname -> GREATERTHAN .)
    DIVIDE          reduce using rule 196 (fname -> GREATERTHAN .)
    MOD             reduce using rule 196 (fname -> GREATERTHAN .)
    POW             reduce using rule 196 (fname -> GREATERTHAN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 196 (fname -> GREATERTHAN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 196 (fname -> GREATERTHAN .)
    COMPLEMENT_OP   reduce using rule 196 (fname -> GREATERTHAN .)
    OVERLOAD_PLUS   reduce using rule 196 (fname -> GREATERTHAN .)
    OVERLOAD_MINUS  reduce using rule 196 (fname -> GREATERTHAN .)
    LBRACKET        reduce using rule 196 (fname -> GREATERTHAN .)
    LPAREN          reduce using rule 196 (fname -> GREATERTHAN .)


state 94

    (197) fname -> GREATERTHANEQUAL .

    IF              reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    WHILE           reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    UNLESS          reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    UNTIL           reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    TERM            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    $end            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    RESCUE          reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    RPAREN          reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    WHEN            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    RKEY            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    LKEY            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    END             reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    ELSIF           reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    ELSE            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    ENSURE          reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    IDENTIFIER      reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    RANGE_INCLUSIVE reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    OR_SYMBOL       reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    BINARY_AND_OP   reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    BINARY_XOR_OP   reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    COMBINED_COMPARISON_OP reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    EQUAL           reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    CASE_EQUALITY   reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    MATCHED_STRINGS_OP reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    GREATERTHAN     reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    GREATERTHANEQUAL reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    LESSERTHAN      reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    LESSERTHANEQUAL reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    PLUS            reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    MINUS           reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    TIMES           reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    DIVIDE          reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    MOD             reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    POW             reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    COMPLEMENT_OP   reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    OVERLOAD_PLUS   reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    OVERLOAD_MINUS  reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    LBRACKET        reduce using rule 197 (fname -> GREATERTHANEQUAL .)
    LPAREN          reduce using rule 197 (fname -> GREATERTHANEQUAL .)


state 95

    (198) fname -> LESSERTHAN .

    IF              reduce using rule 198 (fname -> LESSERTHAN .)
    WHILE           reduce using rule 198 (fname -> LESSERTHAN .)
    UNLESS          reduce using rule 198 (fname -> LESSERTHAN .)
    UNTIL           reduce using rule 198 (fname -> LESSERTHAN .)
    TERM            reduce using rule 198 (fname -> LESSERTHAN .)
    $end            reduce using rule 198 (fname -> LESSERTHAN .)
    RESCUE          reduce using rule 198 (fname -> LESSERTHAN .)
    RPAREN          reduce using rule 198 (fname -> LESSERTHAN .)
    WHEN            reduce using rule 198 (fname -> LESSERTHAN .)
    RKEY            reduce using rule 198 (fname -> LESSERTHAN .)
    LKEY            reduce using rule 198 (fname -> LESSERTHAN .)
    END             reduce using rule 198 (fname -> LESSERTHAN .)
    ELSIF           reduce using rule 198 (fname -> LESSERTHAN .)
    ELSE            reduce using rule 198 (fname -> LESSERTHAN .)
    ENSURE          reduce using rule 198 (fname -> LESSERTHAN .)
    IDENTIFIER      reduce using rule 198 (fname -> LESSERTHAN .)
    RANGE_INCLUSIVE reduce using rule 198 (fname -> LESSERTHAN .)
    OR_SYMBOL       reduce using rule 198 (fname -> LESSERTHAN .)
    BINARY_AND_OP   reduce using rule 198 (fname -> LESSERTHAN .)
    BINARY_XOR_OP   reduce using rule 198 (fname -> LESSERTHAN .)
    COMBINED_COMPARISON_OP reduce using rule 198 (fname -> LESSERTHAN .)
    EQUAL           reduce using rule 198 (fname -> LESSERTHAN .)
    CASE_EQUALITY   reduce using rule 198 (fname -> LESSERTHAN .)
    MATCHED_STRINGS_OP reduce using rule 198 (fname -> LESSERTHAN .)
    GREATERTHAN     reduce using rule 198 (fname -> LESSERTHAN .)
    GREATERTHANEQUAL reduce using rule 198 (fname -> LESSERTHAN .)
    LESSERTHAN      reduce using rule 198 (fname -> LESSERTHAN .)
    LESSERTHANEQUAL reduce using rule 198 (fname -> LESSERTHAN .)
    PLUS            reduce using rule 198 (fname -> LESSERTHAN .)
    MINUS           reduce using rule 198 (fname -> LESSERTHAN .)
    TIMES           reduce using rule 198 (fname -> LESSERTHAN .)
    DIVIDE          reduce using rule 198 (fname -> LESSERTHAN .)
    MOD             reduce using rule 198 (fname -> LESSERTHAN .)
    POW             reduce using rule 198 (fname -> LESSERTHAN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 198 (fname -> LESSERTHAN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 198 (fname -> LESSERTHAN .)
    COMPLEMENT_OP   reduce using rule 198 (fname -> LESSERTHAN .)
    OVERLOAD_PLUS   reduce using rule 198 (fname -> LESSERTHAN .)
    OVERLOAD_MINUS  reduce using rule 198 (fname -> LESSERTHAN .)
    LBRACKET        reduce using rule 198 (fname -> LESSERTHAN .)
    LPAREN          reduce using rule 198 (fname -> LESSERTHAN .)


state 96

    (199) fname -> LESSERTHANEQUAL .

    IF              reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    WHILE           reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    UNLESS          reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    UNTIL           reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    TERM            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    $end            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    RESCUE          reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    RPAREN          reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    WHEN            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    RKEY            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    LKEY            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    END             reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    ELSIF           reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    ELSE            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    ENSURE          reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    IDENTIFIER      reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    RANGE_INCLUSIVE reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    OR_SYMBOL       reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    BINARY_AND_OP   reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    BINARY_XOR_OP   reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    COMBINED_COMPARISON_OP reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    EQUAL           reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    CASE_EQUALITY   reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    MATCHED_STRINGS_OP reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    GREATERTHAN     reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    GREATERTHANEQUAL reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    LESSERTHAN      reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    LESSERTHANEQUAL reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    PLUS            reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    MINUS           reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    TIMES           reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    DIVIDE          reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    MOD             reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    POW             reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    COMPLEMENT_OP   reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    OVERLOAD_PLUS   reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    OVERLOAD_MINUS  reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    LBRACKET        reduce using rule 199 (fname -> LESSERTHANEQUAL .)
    LPAREN          reduce using rule 199 (fname -> LESSERTHANEQUAL .)


state 97

    (200) fname -> PLUS .

    IF              reduce using rule 200 (fname -> PLUS .)
    WHILE           reduce using rule 200 (fname -> PLUS .)
    UNLESS          reduce using rule 200 (fname -> PLUS .)
    UNTIL           reduce using rule 200 (fname -> PLUS .)
    TERM            reduce using rule 200 (fname -> PLUS .)
    $end            reduce using rule 200 (fname -> PLUS .)
    RESCUE          reduce using rule 200 (fname -> PLUS .)
    RPAREN          reduce using rule 200 (fname -> PLUS .)
    WHEN            reduce using rule 200 (fname -> PLUS .)
    RKEY            reduce using rule 200 (fname -> PLUS .)
    LKEY            reduce using rule 200 (fname -> PLUS .)
    END             reduce using rule 200 (fname -> PLUS .)
    ELSIF           reduce using rule 200 (fname -> PLUS .)
    ELSE            reduce using rule 200 (fname -> PLUS .)
    ENSURE          reduce using rule 200 (fname -> PLUS .)
    IDENTIFIER      reduce using rule 200 (fname -> PLUS .)
    RANGE_INCLUSIVE reduce using rule 200 (fname -> PLUS .)
    OR_SYMBOL       reduce using rule 200 (fname -> PLUS .)
    BINARY_AND_OP   reduce using rule 200 (fname -> PLUS .)
    BINARY_XOR_OP   reduce using rule 200 (fname -> PLUS .)
    COMBINED_COMPARISON_OP reduce using rule 200 (fname -> PLUS .)
    EQUAL           reduce using rule 200 (fname -> PLUS .)
    CASE_EQUALITY   reduce using rule 200 (fname -> PLUS .)
    MATCHED_STRINGS_OP reduce using rule 200 (fname -> PLUS .)
    GREATERTHAN     reduce using rule 200 (fname -> PLUS .)
    GREATERTHANEQUAL reduce using rule 200 (fname -> PLUS .)
    LESSERTHAN      reduce using rule 200 (fname -> PLUS .)
    LESSERTHANEQUAL reduce using rule 200 (fname -> PLUS .)
    PLUS            reduce using rule 200 (fname -> PLUS .)
    MINUS           reduce using rule 200 (fname -> PLUS .)
    TIMES           reduce using rule 200 (fname -> PLUS .)
    DIVIDE          reduce using rule 200 (fname -> PLUS .)
    MOD             reduce using rule 200 (fname -> PLUS .)
    POW             reduce using rule 200 (fname -> PLUS .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 200 (fname -> PLUS .)
    BINARY_LEFT_SHIFT_OP reduce using rule 200 (fname -> PLUS .)
    COMPLEMENT_OP   reduce using rule 200 (fname -> PLUS .)
    OVERLOAD_PLUS   reduce using rule 200 (fname -> PLUS .)
    OVERLOAD_MINUS  reduce using rule 200 (fname -> PLUS .)
    LBRACKET        reduce using rule 200 (fname -> PLUS .)
    LPAREN          reduce using rule 200 (fname -> PLUS .)


state 98

    (201) fname -> MINUS .

    IF              reduce using rule 201 (fname -> MINUS .)
    WHILE           reduce using rule 201 (fname -> MINUS .)
    UNLESS          reduce using rule 201 (fname -> MINUS .)
    UNTIL           reduce using rule 201 (fname -> MINUS .)
    TERM            reduce using rule 201 (fname -> MINUS .)
    $end            reduce using rule 201 (fname -> MINUS .)
    RESCUE          reduce using rule 201 (fname -> MINUS .)
    RPAREN          reduce using rule 201 (fname -> MINUS .)
    WHEN            reduce using rule 201 (fname -> MINUS .)
    RKEY            reduce using rule 201 (fname -> MINUS .)
    LKEY            reduce using rule 201 (fname -> MINUS .)
    END             reduce using rule 201 (fname -> MINUS .)
    ELSIF           reduce using rule 201 (fname -> MINUS .)
    ELSE            reduce using rule 201 (fname -> MINUS .)
    ENSURE          reduce using rule 201 (fname -> MINUS .)
    IDENTIFIER      reduce using rule 201 (fname -> MINUS .)
    RANGE_INCLUSIVE reduce using rule 201 (fname -> MINUS .)
    OR_SYMBOL       reduce using rule 201 (fname -> MINUS .)
    BINARY_AND_OP   reduce using rule 201 (fname -> MINUS .)
    BINARY_XOR_OP   reduce using rule 201 (fname -> MINUS .)
    COMBINED_COMPARISON_OP reduce using rule 201 (fname -> MINUS .)
    EQUAL           reduce using rule 201 (fname -> MINUS .)
    CASE_EQUALITY   reduce using rule 201 (fname -> MINUS .)
    MATCHED_STRINGS_OP reduce using rule 201 (fname -> MINUS .)
    GREATERTHAN     reduce using rule 201 (fname -> MINUS .)
    GREATERTHANEQUAL reduce using rule 201 (fname -> MINUS .)
    LESSERTHAN      reduce using rule 201 (fname -> MINUS .)
    LESSERTHANEQUAL reduce using rule 201 (fname -> MINUS .)
    PLUS            reduce using rule 201 (fname -> MINUS .)
    MINUS           reduce using rule 201 (fname -> MINUS .)
    TIMES           reduce using rule 201 (fname -> MINUS .)
    DIVIDE          reduce using rule 201 (fname -> MINUS .)
    MOD             reduce using rule 201 (fname -> MINUS .)
    POW             reduce using rule 201 (fname -> MINUS .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 201 (fname -> MINUS .)
    BINARY_LEFT_SHIFT_OP reduce using rule 201 (fname -> MINUS .)
    COMPLEMENT_OP   reduce using rule 201 (fname -> MINUS .)
    OVERLOAD_PLUS   reduce using rule 201 (fname -> MINUS .)
    OVERLOAD_MINUS  reduce using rule 201 (fname -> MINUS .)
    LBRACKET        reduce using rule 201 (fname -> MINUS .)
    LPAREN          reduce using rule 201 (fname -> MINUS .)


state 99

    (202) fname -> TIMES .

    IF              reduce using rule 202 (fname -> TIMES .)
    WHILE           reduce using rule 202 (fname -> TIMES .)
    UNLESS          reduce using rule 202 (fname -> TIMES .)
    UNTIL           reduce using rule 202 (fname -> TIMES .)
    TERM            reduce using rule 202 (fname -> TIMES .)
    $end            reduce using rule 202 (fname -> TIMES .)
    RESCUE          reduce using rule 202 (fname -> TIMES .)
    RPAREN          reduce using rule 202 (fname -> TIMES .)
    WHEN            reduce using rule 202 (fname -> TIMES .)
    RKEY            reduce using rule 202 (fname -> TIMES .)
    LKEY            reduce using rule 202 (fname -> TIMES .)
    END             reduce using rule 202 (fname -> TIMES .)
    ELSIF           reduce using rule 202 (fname -> TIMES .)
    ELSE            reduce using rule 202 (fname -> TIMES .)
    ENSURE          reduce using rule 202 (fname -> TIMES .)
    IDENTIFIER      reduce using rule 202 (fname -> TIMES .)
    RANGE_INCLUSIVE reduce using rule 202 (fname -> TIMES .)
    OR_SYMBOL       reduce using rule 202 (fname -> TIMES .)
    BINARY_AND_OP   reduce using rule 202 (fname -> TIMES .)
    BINARY_XOR_OP   reduce using rule 202 (fname -> TIMES .)
    COMBINED_COMPARISON_OP reduce using rule 202 (fname -> TIMES .)
    EQUAL           reduce using rule 202 (fname -> TIMES .)
    CASE_EQUALITY   reduce using rule 202 (fname -> TIMES .)
    MATCHED_STRINGS_OP reduce using rule 202 (fname -> TIMES .)
    GREATERTHAN     reduce using rule 202 (fname -> TIMES .)
    GREATERTHANEQUAL reduce using rule 202 (fname -> TIMES .)
    LESSERTHAN      reduce using rule 202 (fname -> TIMES .)
    LESSERTHANEQUAL reduce using rule 202 (fname -> TIMES .)
    PLUS            reduce using rule 202 (fname -> TIMES .)
    MINUS           reduce using rule 202 (fname -> TIMES .)
    TIMES           reduce using rule 202 (fname -> TIMES .)
    DIVIDE          reduce using rule 202 (fname -> TIMES .)
    MOD             reduce using rule 202 (fname -> TIMES .)
    POW             reduce using rule 202 (fname -> TIMES .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 202 (fname -> TIMES .)
    BINARY_LEFT_SHIFT_OP reduce using rule 202 (fname -> TIMES .)
    COMPLEMENT_OP   reduce using rule 202 (fname -> TIMES .)
    OVERLOAD_PLUS   reduce using rule 202 (fname -> TIMES .)
    OVERLOAD_MINUS  reduce using rule 202 (fname -> TIMES .)
    LBRACKET        reduce using rule 202 (fname -> TIMES .)
    LPAREN          reduce using rule 202 (fname -> TIMES .)


state 100

    (203) fname -> DIVIDE .

    IF              reduce using rule 203 (fname -> DIVIDE .)
    WHILE           reduce using rule 203 (fname -> DIVIDE .)
    UNLESS          reduce using rule 203 (fname -> DIVIDE .)
    UNTIL           reduce using rule 203 (fname -> DIVIDE .)
    TERM            reduce using rule 203 (fname -> DIVIDE .)
    $end            reduce using rule 203 (fname -> DIVIDE .)
    RESCUE          reduce using rule 203 (fname -> DIVIDE .)
    RPAREN          reduce using rule 203 (fname -> DIVIDE .)
    WHEN            reduce using rule 203 (fname -> DIVIDE .)
    RKEY            reduce using rule 203 (fname -> DIVIDE .)
    LKEY            reduce using rule 203 (fname -> DIVIDE .)
    END             reduce using rule 203 (fname -> DIVIDE .)
    ELSIF           reduce using rule 203 (fname -> DIVIDE .)
    ELSE            reduce using rule 203 (fname -> DIVIDE .)
    ENSURE          reduce using rule 203 (fname -> DIVIDE .)
    IDENTIFIER      reduce using rule 203 (fname -> DIVIDE .)
    RANGE_INCLUSIVE reduce using rule 203 (fname -> DIVIDE .)
    OR_SYMBOL       reduce using rule 203 (fname -> DIVIDE .)
    BINARY_AND_OP   reduce using rule 203 (fname -> DIVIDE .)
    BINARY_XOR_OP   reduce using rule 203 (fname -> DIVIDE .)
    COMBINED_COMPARISON_OP reduce using rule 203 (fname -> DIVIDE .)
    EQUAL           reduce using rule 203 (fname -> DIVIDE .)
    CASE_EQUALITY   reduce using rule 203 (fname -> DIVIDE .)
    MATCHED_STRINGS_OP reduce using rule 203 (fname -> DIVIDE .)
    GREATERTHAN     reduce using rule 203 (fname -> DIVIDE .)
    GREATERTHANEQUAL reduce using rule 203 (fname -> DIVIDE .)
    LESSERTHAN      reduce using rule 203 (fname -> DIVIDE .)
    LESSERTHANEQUAL reduce using rule 203 (fname -> DIVIDE .)
    PLUS            reduce using rule 203 (fname -> DIVIDE .)
    MINUS           reduce using rule 203 (fname -> DIVIDE .)
    TIMES           reduce using rule 203 (fname -> DIVIDE .)
    DIVIDE          reduce using rule 203 (fname -> DIVIDE .)
    MOD             reduce using rule 203 (fname -> DIVIDE .)
    POW             reduce using rule 203 (fname -> DIVIDE .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 203 (fname -> DIVIDE .)
    BINARY_LEFT_SHIFT_OP reduce using rule 203 (fname -> DIVIDE .)
    COMPLEMENT_OP   reduce using rule 203 (fname -> DIVIDE .)
    OVERLOAD_PLUS   reduce using rule 203 (fname -> DIVIDE .)
    OVERLOAD_MINUS  reduce using rule 203 (fname -> DIVIDE .)
    LBRACKET        reduce using rule 203 (fname -> DIVIDE .)
    LPAREN          reduce using rule 203 (fname -> DIVIDE .)


state 101

    (204) fname -> MOD .

    IF              reduce using rule 204 (fname -> MOD .)
    WHILE           reduce using rule 204 (fname -> MOD .)
    UNLESS          reduce using rule 204 (fname -> MOD .)
    UNTIL           reduce using rule 204 (fname -> MOD .)
    TERM            reduce using rule 204 (fname -> MOD .)
    $end            reduce using rule 204 (fname -> MOD .)
    RESCUE          reduce using rule 204 (fname -> MOD .)
    RPAREN          reduce using rule 204 (fname -> MOD .)
    WHEN            reduce using rule 204 (fname -> MOD .)
    RKEY            reduce using rule 204 (fname -> MOD .)
    LKEY            reduce using rule 204 (fname -> MOD .)
    END             reduce using rule 204 (fname -> MOD .)
    ELSIF           reduce using rule 204 (fname -> MOD .)
    ELSE            reduce using rule 204 (fname -> MOD .)
    ENSURE          reduce using rule 204 (fname -> MOD .)
    IDENTIFIER      reduce using rule 204 (fname -> MOD .)
    RANGE_INCLUSIVE reduce using rule 204 (fname -> MOD .)
    OR_SYMBOL       reduce using rule 204 (fname -> MOD .)
    BINARY_AND_OP   reduce using rule 204 (fname -> MOD .)
    BINARY_XOR_OP   reduce using rule 204 (fname -> MOD .)
    COMBINED_COMPARISON_OP reduce using rule 204 (fname -> MOD .)
    EQUAL           reduce using rule 204 (fname -> MOD .)
    CASE_EQUALITY   reduce using rule 204 (fname -> MOD .)
    MATCHED_STRINGS_OP reduce using rule 204 (fname -> MOD .)
    GREATERTHAN     reduce using rule 204 (fname -> MOD .)
    GREATERTHANEQUAL reduce using rule 204 (fname -> MOD .)
    LESSERTHAN      reduce using rule 204 (fname -> MOD .)
    LESSERTHANEQUAL reduce using rule 204 (fname -> MOD .)
    PLUS            reduce using rule 204 (fname -> MOD .)
    MINUS           reduce using rule 204 (fname -> MOD .)
    TIMES           reduce using rule 204 (fname -> MOD .)
    DIVIDE          reduce using rule 204 (fname -> MOD .)
    MOD             reduce using rule 204 (fname -> MOD .)
    POW             reduce using rule 204 (fname -> MOD .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 204 (fname -> MOD .)
    BINARY_LEFT_SHIFT_OP reduce using rule 204 (fname -> MOD .)
    COMPLEMENT_OP   reduce using rule 204 (fname -> MOD .)
    OVERLOAD_PLUS   reduce using rule 204 (fname -> MOD .)
    OVERLOAD_MINUS  reduce using rule 204 (fname -> MOD .)
    LBRACKET        reduce using rule 204 (fname -> MOD .)
    LPAREN          reduce using rule 204 (fname -> MOD .)


state 102

    (205) fname -> POW .

    IF              reduce using rule 205 (fname -> POW .)
    WHILE           reduce using rule 205 (fname -> POW .)
    UNLESS          reduce using rule 205 (fname -> POW .)
    UNTIL           reduce using rule 205 (fname -> POW .)
    TERM            reduce using rule 205 (fname -> POW .)
    $end            reduce using rule 205 (fname -> POW .)
    RESCUE          reduce using rule 205 (fname -> POW .)
    RPAREN          reduce using rule 205 (fname -> POW .)
    WHEN            reduce using rule 205 (fname -> POW .)
    RKEY            reduce using rule 205 (fname -> POW .)
    LKEY            reduce using rule 205 (fname -> POW .)
    END             reduce using rule 205 (fname -> POW .)
    ELSIF           reduce using rule 205 (fname -> POW .)
    ELSE            reduce using rule 205 (fname -> POW .)
    ENSURE          reduce using rule 205 (fname -> POW .)
    IDENTIFIER      reduce using rule 205 (fname -> POW .)
    RANGE_INCLUSIVE reduce using rule 205 (fname -> POW .)
    OR_SYMBOL       reduce using rule 205 (fname -> POW .)
    BINARY_AND_OP   reduce using rule 205 (fname -> POW .)
    BINARY_XOR_OP   reduce using rule 205 (fname -> POW .)
    COMBINED_COMPARISON_OP reduce using rule 205 (fname -> POW .)
    EQUAL           reduce using rule 205 (fname -> POW .)
    CASE_EQUALITY   reduce using rule 205 (fname -> POW .)
    MATCHED_STRINGS_OP reduce using rule 205 (fname -> POW .)
    GREATERTHAN     reduce using rule 205 (fname -> POW .)
    GREATERTHANEQUAL reduce using rule 205 (fname -> POW .)
    LESSERTHAN      reduce using rule 205 (fname -> POW .)
    LESSERTHANEQUAL reduce using rule 205 (fname -> POW .)
    PLUS            reduce using rule 205 (fname -> POW .)
    MINUS           reduce using rule 205 (fname -> POW .)
    TIMES           reduce using rule 205 (fname -> POW .)
    DIVIDE          reduce using rule 205 (fname -> POW .)
    MOD             reduce using rule 205 (fname -> POW .)
    POW             reduce using rule 205 (fname -> POW .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 205 (fname -> POW .)
    BINARY_LEFT_SHIFT_OP reduce using rule 205 (fname -> POW .)
    COMPLEMENT_OP   reduce using rule 205 (fname -> POW .)
    OVERLOAD_PLUS   reduce using rule 205 (fname -> POW .)
    OVERLOAD_MINUS  reduce using rule 205 (fname -> POW .)
    LBRACKET        reduce using rule 205 (fname -> POW .)
    LPAREN          reduce using rule 205 (fname -> POW .)


state 103

    (206) fname -> BINARY_RIGHT_SHIFT_OP .

    IF              reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    WHILE           reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    UNLESS          reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    UNTIL           reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    TERM            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    $end            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    RESCUE          reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    RPAREN          reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    WHEN            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    RKEY            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    LKEY            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    END             reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    ELSIF           reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    ELSE            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    ENSURE          reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    IDENTIFIER      reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    RANGE_INCLUSIVE reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    OR_SYMBOL       reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    BINARY_AND_OP   reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    BINARY_XOR_OP   reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    COMBINED_COMPARISON_OP reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    EQUAL           reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    CASE_EQUALITY   reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    MATCHED_STRINGS_OP reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    GREATERTHAN     reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    GREATERTHANEQUAL reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    LESSERTHAN      reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    LESSERTHANEQUAL reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    PLUS            reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    MINUS           reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    TIMES           reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    DIVIDE          reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    MOD             reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    POW             reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    COMPLEMENT_OP   reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    OVERLOAD_PLUS   reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    OVERLOAD_MINUS  reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    LBRACKET        reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)
    LPAREN          reduce using rule 206 (fname -> BINARY_RIGHT_SHIFT_OP .)


state 104

    (207) fname -> BINARY_LEFT_SHIFT_OP .

    IF              reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    WHILE           reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    UNLESS          reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    UNTIL           reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    TERM            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    $end            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    RESCUE          reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    RPAREN          reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    WHEN            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    RKEY            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    LKEY            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    END             reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    ELSIF           reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    ELSE            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    ENSURE          reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    IDENTIFIER      reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    RANGE_INCLUSIVE reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    OR_SYMBOL       reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    BINARY_AND_OP   reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    BINARY_XOR_OP   reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    COMBINED_COMPARISON_OP reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    EQUAL           reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    CASE_EQUALITY   reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    MATCHED_STRINGS_OP reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    GREATERTHAN     reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    GREATERTHANEQUAL reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    LESSERTHAN      reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    LESSERTHANEQUAL reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    PLUS            reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    MINUS           reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    TIMES           reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    DIVIDE          reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    MOD             reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    POW             reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    COMPLEMENT_OP   reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    OVERLOAD_PLUS   reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    OVERLOAD_MINUS  reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    LBRACKET        reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)
    LPAREN          reduce using rule 207 (fname -> BINARY_LEFT_SHIFT_OP .)


state 105

    (208) fname -> COMPLEMENT_OP .

    IF              reduce using rule 208 (fname -> COMPLEMENT_OP .)
    WHILE           reduce using rule 208 (fname -> COMPLEMENT_OP .)
    UNLESS          reduce using rule 208 (fname -> COMPLEMENT_OP .)
    UNTIL           reduce using rule 208 (fname -> COMPLEMENT_OP .)
    TERM            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    $end            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    RESCUE          reduce using rule 208 (fname -> COMPLEMENT_OP .)
    RPAREN          reduce using rule 208 (fname -> COMPLEMENT_OP .)
    WHEN            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    RKEY            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    LKEY            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    END             reduce using rule 208 (fname -> COMPLEMENT_OP .)
    ELSIF           reduce using rule 208 (fname -> COMPLEMENT_OP .)
    ELSE            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    ENSURE          reduce using rule 208 (fname -> COMPLEMENT_OP .)
    IDENTIFIER      reduce using rule 208 (fname -> COMPLEMENT_OP .)
    RANGE_INCLUSIVE reduce using rule 208 (fname -> COMPLEMENT_OP .)
    OR_SYMBOL       reduce using rule 208 (fname -> COMPLEMENT_OP .)
    BINARY_AND_OP   reduce using rule 208 (fname -> COMPLEMENT_OP .)
    BINARY_XOR_OP   reduce using rule 208 (fname -> COMPLEMENT_OP .)
    COMBINED_COMPARISON_OP reduce using rule 208 (fname -> COMPLEMENT_OP .)
    EQUAL           reduce using rule 208 (fname -> COMPLEMENT_OP .)
    CASE_EQUALITY   reduce using rule 208 (fname -> COMPLEMENT_OP .)
    MATCHED_STRINGS_OP reduce using rule 208 (fname -> COMPLEMENT_OP .)
    GREATERTHAN     reduce using rule 208 (fname -> COMPLEMENT_OP .)
    GREATERTHANEQUAL reduce using rule 208 (fname -> COMPLEMENT_OP .)
    LESSERTHAN      reduce using rule 208 (fname -> COMPLEMENT_OP .)
    LESSERTHANEQUAL reduce using rule 208 (fname -> COMPLEMENT_OP .)
    PLUS            reduce using rule 208 (fname -> COMPLEMENT_OP .)
    MINUS           reduce using rule 208 (fname -> COMPLEMENT_OP .)
    TIMES           reduce using rule 208 (fname -> COMPLEMENT_OP .)
    DIVIDE          reduce using rule 208 (fname -> COMPLEMENT_OP .)
    MOD             reduce using rule 208 (fname -> COMPLEMENT_OP .)
    POW             reduce using rule 208 (fname -> COMPLEMENT_OP .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 208 (fname -> COMPLEMENT_OP .)
    BINARY_LEFT_SHIFT_OP reduce using rule 208 (fname -> COMPLEMENT_OP .)
    COMPLEMENT_OP   reduce using rule 208 (fname -> COMPLEMENT_OP .)
    OVERLOAD_PLUS   reduce using rule 208 (fname -> COMPLEMENT_OP .)
    OVERLOAD_MINUS  reduce using rule 208 (fname -> COMPLEMENT_OP .)
    LBRACKET        reduce using rule 208 (fname -> COMPLEMENT_OP .)
    LPAREN          reduce using rule 208 (fname -> COMPLEMENT_OP .)


state 106

    (209) fname -> OVERLOAD_PLUS .

    IF              reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    WHILE           reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    UNLESS          reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    UNTIL           reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    TERM            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    $end            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    RESCUE          reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    RPAREN          reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    WHEN            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    RKEY            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    LKEY            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    END             reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    ELSIF           reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    ELSE            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    ENSURE          reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    IDENTIFIER      reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    RANGE_INCLUSIVE reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    OR_SYMBOL       reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    BINARY_AND_OP   reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    BINARY_XOR_OP   reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    COMBINED_COMPARISON_OP reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    EQUAL           reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    CASE_EQUALITY   reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    MATCHED_STRINGS_OP reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    GREATERTHAN     reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    GREATERTHANEQUAL reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    LESSERTHAN      reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    LESSERTHANEQUAL reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    PLUS            reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    MINUS           reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    TIMES           reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    DIVIDE          reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    MOD             reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    POW             reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    BINARY_LEFT_SHIFT_OP reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    COMPLEMENT_OP   reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    OVERLOAD_PLUS   reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    OVERLOAD_MINUS  reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    LBRACKET        reduce using rule 209 (fname -> OVERLOAD_PLUS .)
    LPAREN          reduce using rule 209 (fname -> OVERLOAD_PLUS .)


state 107

    (210) fname -> OVERLOAD_MINUS .

    IF              reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    WHILE           reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    UNLESS          reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    UNTIL           reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    TERM            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    $end            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    RESCUE          reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    RPAREN          reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    WHEN            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    RKEY            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    LKEY            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    END             reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    ELSIF           reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    ELSE            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    ENSURE          reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    IDENTIFIER      reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    RANGE_INCLUSIVE reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    OR_SYMBOL       reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    BINARY_AND_OP   reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    BINARY_XOR_OP   reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    COMBINED_COMPARISON_OP reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    EQUAL           reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    CASE_EQUALITY   reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    MATCHED_STRINGS_OP reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    GREATERTHAN     reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    GREATERTHANEQUAL reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    LESSERTHAN      reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    LESSERTHANEQUAL reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    PLUS            reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    MINUS           reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    TIMES           reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    DIVIDE          reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    MOD             reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    POW             reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    BINARY_LEFT_SHIFT_OP reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    COMPLEMENT_OP   reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    OVERLOAD_PLUS   reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    OVERLOAD_MINUS  reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    LBRACKET        reduce using rule 210 (fname -> OVERLOAD_MINUS .)
    LPAREN          reduce using rule 210 (fname -> OVERLOAD_MINUS .)


state 108

    (211) fname -> LBRACKET . RBRACKET
    (212) fname -> LBRACKET . RBRACKET EQUAL_SYMBOL

    RBRACKET        shift and go to state 245


state 109

    (9) stmt -> ALIAS fname . fname
    (187) fname -> . IDENTIFIER
    (188) fname -> . RANGE_INCLUSIVE
    (189) fname -> . OR_SYMBOL
    (190) fname -> . BINARY_AND_OP
    (191) fname -> . BINARY_XOR_OP
    (192) fname -> . COMBINED_COMPARISON_OP
    (193) fname -> . EQUAL
    (194) fname -> . CASE_EQUALITY
    (195) fname -> . MATCHED_STRINGS_OP
    (196) fname -> . GREATERTHAN
    (197) fname -> . GREATERTHANEQUAL
    (198) fname -> . LESSERTHAN
    (199) fname -> . LESSERTHANEQUAL
    (200) fname -> . PLUS
    (201) fname -> . MINUS
    (202) fname -> . TIMES
    (203) fname -> . DIVIDE
    (204) fname -> . MOD
    (205) fname -> . POW
    (206) fname -> . BINARY_RIGHT_SHIFT_OP
    (207) fname -> . BINARY_LEFT_SHIFT_OP
    (208) fname -> . COMPLEMENT_OP
    (209) fname -> . OVERLOAD_PLUS
    (210) fname -> . OVERLOAD_MINUS
    (211) fname -> . LBRACKET RBRACKET
    (212) fname -> . LBRACKET RBRACKET EQUAL_SYMBOL

    IDENTIFIER      shift and go to state 84
    RANGE_INCLUSIVE shift and go to state 85
    OR_SYMBOL       shift and go to state 86
    BINARY_AND_OP   shift and go to state 87
    BINARY_XOR_OP   shift and go to state 88
    COMBINED_COMPARISON_OP shift and go to state 89
    EQUAL           shift and go to state 90
    CASE_EQUALITY   shift and go to state 91
    MATCHED_STRINGS_OP shift and go to state 92
    GREATERTHAN     shift and go to state 93
    GREATERTHANEQUAL shift and go to state 94
    LESSERTHAN      shift and go to state 95
    LESSERTHANEQUAL shift and go to state 96
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 100
    MOD             shift and go to state 101
    POW             shift and go to state 102
    BINARY_RIGHT_SHIFT_OP shift and go to state 103
    BINARY_LEFT_SHIFT_OP shift and go to state 104
    COMPLEMENT_OP   shift and go to state 105
    OVERLOAD_PLUS   shift and go to state 106
    OVERLOAD_MINUS  shift and go to state 107
    LBRACKET        shift and go to state 108

    fname                          shift and go to state 246

state 110

    (98) primary -> IF expr . then compstmt END
    (99) primary -> IF expr . then compstmt elsif END
    (100) primary -> IF expr . then compstmt elsif ELSE compstmt END
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (129) then -> . TERM
    (130) then -> . THEN
    (131) then -> . TERM THEN

    AND             shift and go to state 58
    OR              shift and go to state 59
    TERM            shift and go to state 248
    THEN            shift and go to state 249

    then                           shift and go to state 247

state 111

    (24) expr -> command .

    AND             reduce using rule 24 (expr -> command .)
    OR              reduce using rule 24 (expr -> command .)
    TERM            reduce using rule 24 (expr -> command .)
    THEN            reduce using rule 24 (expr -> command .)
    DO              reduce using rule 24 (expr -> command .)
    IF              reduce using rule 24 (expr -> command .)
    WHILE           reduce using rule 24 (expr -> command .)
    UNLESS          reduce using rule 24 (expr -> command .)
    UNTIL           reduce using rule 24 (expr -> command .)
    $end            reduce using rule 24 (expr -> command .)
    RESCUE          reduce using rule 24 (expr -> command .)
    RPAREN          reduce using rule 24 (expr -> command .)
    WHEN            reduce using rule 24 (expr -> command .)
    RKEY            reduce using rule 24 (expr -> command .)
    LKEY            reduce using rule 24 (expr -> command .)
    END             reduce using rule 24 (expr -> command .)
    ELSIF           reduce using rule 24 (expr -> command .)
    ELSE            reduce using rule 24 (expr -> command .)
    ENSURE          reduce using rule 24 (expr -> command .)


state 112

    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (153) mlhs_item -> lhs .
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    =               shift and go to state 236
    COMMA           reduce using rule 153 (mlhs_item -> lhs .)
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 113

    (29) command -> operation . call_args
    (33) function -> operation . LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    LBRACKET        shift and go to state 190
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    operation                      shift and go to state 113
    call_args                      shift and go to state 191
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 114

    (30) command -> primary . DOT operation call_args
    (31) command -> primary . UNARY_OP operation call_args
    (67) arg -> primary .
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation

  ! shift/reduce conflict for LBRACKET resolved as shift
    DOT             shift and go to state 250
    UNARY_OP        shift and go to state 251
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    TERM            reduce using rule 67 (arg -> primary .)
    THEN            reduce using rule 67 (arg -> primary .)
    DO              reduce using rule 67 (arg -> primary .)
    COMMA           reduce using rule 67 (arg -> primary .)
    HASH_ROCKET     reduce using rule 67 (arg -> primary .)
    IF              reduce using rule 67 (arg -> primary .)
    WHILE           reduce using rule 67 (arg -> primary .)
    UNLESS          reduce using rule 67 (arg -> primary .)
    UNTIL           reduce using rule 67 (arg -> primary .)
    $end            reduce using rule 67 (arg -> primary .)
    RESCUE          reduce using rule 67 (arg -> primary .)
    RPAREN          reduce using rule 67 (arg -> primary .)
    WHEN            reduce using rule 67 (arg -> primary .)
    RKEY            reduce using rule 67 (arg -> primary .)
    LKEY            reduce using rule 67 (arg -> primary .)
    END             reduce using rule 67 (arg -> primary .)
    ELSIF           reduce using rule 67 (arg -> primary .)
    ELSE            reduce using rule 67 (arg -> primary .)
    ENSURE          reduce using rule 67 (arg -> primary .)
    RBRACKET        reduce using rule 67 (arg -> primary .)
    LBRACKET        shift and go to state 252

  ! LBRACKET        [ reduce using rule 67 (arg -> primary .) ]


state 115

    (32) command -> SUPER . call_args
    (38) function -> SUPER . LPAREN call_args RPAREN
    (39) function -> SUPER .
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    LPAREN          shift and go to state 196
    DOT             reduce using rule 39 (function -> SUPER .)
    RANGE_INCLUSIVE reduce using rule 39 (function -> SUPER .)
    RANGE_EXCLUSIVE reduce using rule 39 (function -> SUPER .)
    OR_SYMBOL       reduce using rule 39 (function -> SUPER .)
    BINARY_XOR_OP   reduce using rule 39 (function -> SUPER .)
    COMBINED_COMPARISON_OP reduce using rule 39 (function -> SUPER .)
    GREATERTHAN     reduce using rule 39 (function -> SUPER .)
    GREATERTHANEQUAL reduce using rule 39 (function -> SUPER .)
    LESSERTHAN      reduce using rule 39 (function -> SUPER .)
    LESSERTHANEQUAL reduce using rule 39 (function -> SUPER .)
    EQUAL           reduce using rule 39 (function -> SUPER .)
    CASE_EQUALITY   reduce using rule 39 (function -> SUPER .)
    NOTEQUAL        reduce using rule 39 (function -> SUPER .)
    MATCHED_STRINGS_OP reduce using rule 39 (function -> SUPER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 39 (function -> SUPER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 39 (function -> SUPER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 39 (function -> SUPER .)
    AND             reduce using rule 39 (function -> SUPER .)
    OR              reduce using rule 39 (function -> SUPER .)
    DIVIDE          reduce using rule 39 (function -> SUPER .)
    MOD             reduce using rule 39 (function -> SUPER .)
    POW             reduce using rule 39 (function -> SUPER .)
    TERM            reduce using rule 39 (function -> SUPER .)
    THEN            reduce using rule 39 (function -> SUPER .)
    DO              reduce using rule 39 (function -> SUPER .)
    COMMA           reduce using rule 39 (function -> SUPER .)
    HASH_ROCKET     reduce using rule 39 (function -> SUPER .)
    $end            reduce using rule 39 (function -> SUPER .)
    RESCUE          reduce using rule 39 (function -> SUPER .)
    RPAREN          reduce using rule 39 (function -> SUPER .)
    WHEN            reduce using rule 39 (function -> SUPER .)
    RKEY            reduce using rule 39 (function -> SUPER .)
    END             reduce using rule 39 (function -> SUPER .)
    ELSIF           reduce using rule 39 (function -> SUPER .)
    ELSE            reduce using rule 39 (function -> SUPER .)
    ENSURE          reduce using rule 39 (function -> SUPER .)
    RBRACKET        reduce using rule 39 (function -> SUPER .)
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 39 (function -> SUPER .) ]
  ! UNARY_OP        [ reduce using rule 39 (function -> SUPER .) ]
  ! LBRACKET        [ reduce using rule 39 (function -> SUPER .) ]
  ! BINARY_AND_OP   [ reduce using rule 39 (function -> SUPER .) ]
  ! PLUS            [ reduce using rule 39 (function -> SUPER .) ]
  ! MINUS           [ reduce using rule 39 (function -> SUPER .) ]
  ! TIMES           [ reduce using rule 39 (function -> SUPER .) ]
  ! IF              [ reduce using rule 39 (function -> SUPER .) ]
  ! WHILE           [ reduce using rule 39 (function -> SUPER .) ]
  ! UNLESS          [ reduce using rule 39 (function -> SUPER .) ]
  ! UNTIL           [ reduce using rule 39 (function -> SUPER .) ]
  ! LPAREN          [ reduce using rule 39 (function -> SUPER .) ]

    call_args                      shift and go to state 197
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 116

    (154) mlhs_item -> LPAREN . mlhs RPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (27) call -> . function
    (28) call -> . command
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    TIMES           shift and go to state 44
    LPAREN          shift and go to state 116
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    SUPER           shift and go to state 31
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72

    mlhs                           shift and go to state 193
    compstmt                       shift and go to state 192
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 253
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    command                        shift and go to state 17
    variable                       shift and go to state 19
    primary                        shift and go to state 254
    function                       shift and go to state 18
    arg                            shift and go to state 27
    literal                        shift and go to state 36
    operation                      shift and go to state 28
    math_operations                shift and go to state 45

state 117

    (74) primary -> variable .
    (141) lhs -> variable .

  ! reduce/reduce conflict for COMMA resolved using rule 74 (primary -> variable .)
    DOT             reduce using rule 74 (primary -> variable .)
    UNARY_OP        reduce using rule 74 (primary -> variable .)
    LBRACKET        reduce using rule 74 (primary -> variable .)
    RANGE_INCLUSIVE reduce using rule 74 (primary -> variable .)
    RANGE_EXCLUSIVE reduce using rule 74 (primary -> variable .)
    OR_SYMBOL       reduce using rule 74 (primary -> variable .)
    BINARY_XOR_OP   reduce using rule 74 (primary -> variable .)
    BINARY_AND_OP   reduce using rule 74 (primary -> variable .)
    COMBINED_COMPARISON_OP reduce using rule 74 (primary -> variable .)
    GREATERTHAN     reduce using rule 74 (primary -> variable .)
    GREATERTHANEQUAL reduce using rule 74 (primary -> variable .)
    LESSERTHAN      reduce using rule 74 (primary -> variable .)
    LESSERTHANEQUAL reduce using rule 74 (primary -> variable .)
    EQUAL           reduce using rule 74 (primary -> variable .)
    CASE_EQUALITY   reduce using rule 74 (primary -> variable .)
    NOTEQUAL        reduce using rule 74 (primary -> variable .)
    MATCHED_STRINGS_OP reduce using rule 74 (primary -> variable .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 74 (primary -> variable .)
    BINARY_LEFT_SHIFT_OP reduce using rule 74 (primary -> variable .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 74 (primary -> variable .)
    AND             reduce using rule 74 (primary -> variable .)
    OR              reduce using rule 74 (primary -> variable .)
    PLUS            reduce using rule 74 (primary -> variable .)
    MINUS           reduce using rule 74 (primary -> variable .)
    TIMES           reduce using rule 74 (primary -> variable .)
    DIVIDE          reduce using rule 74 (primary -> variable .)
    MOD             reduce using rule 74 (primary -> variable .)
    POW             reduce using rule 74 (primary -> variable .)
    TERM            reduce using rule 74 (primary -> variable .)
    THEN            reduce using rule 74 (primary -> variable .)
    DO              reduce using rule 74 (primary -> variable .)
    COMMA           reduce using rule 74 (primary -> variable .)
    HASH_ROCKET     reduce using rule 74 (primary -> variable .)
    IF              reduce using rule 74 (primary -> variable .)
    WHILE           reduce using rule 74 (primary -> variable .)
    UNLESS          reduce using rule 74 (primary -> variable .)
    UNTIL           reduce using rule 74 (primary -> variable .)
    $end            reduce using rule 74 (primary -> variable .)
    RESCUE          reduce using rule 74 (primary -> variable .)
    RPAREN          reduce using rule 74 (primary -> variable .)
    WHEN            reduce using rule 74 (primary -> variable .)
    RKEY            reduce using rule 74 (primary -> variable .)
    LKEY            reduce using rule 74 (primary -> variable .)
    END             reduce using rule 74 (primary -> variable .)
    ELSIF           reduce using rule 74 (primary -> variable .)
    ELSE            reduce using rule 74 (primary -> variable .)
    ENSURE          reduce using rule 74 (primary -> variable .)
    RBRACKET        reduce using rule 74 (primary -> variable .)
    =               reduce using rule 141 (lhs -> variable .)
    PLUS_EQUAL      reduce using rule 141 (lhs -> variable .)
    MINUS_EQUAL     reduce using rule 141 (lhs -> variable .)
    TIMES_EQUAL     reduce using rule 141 (lhs -> variable .)
    DIVIDE_EQUAL    reduce using rule 141 (lhs -> variable .)
    MOD_EQUAL       reduce using rule 141 (lhs -> variable .)
    POW_EQUAL       reduce using rule 141 (lhs -> variable .)
    SINGLE_AND_EQUAL reduce using rule 141 (lhs -> variable .)
    SINGLE_OR_EQUAL reduce using rule 141 (lhs -> variable .)
    XOR_EQUAL       reduce using rule 141 (lhs -> variable .)
    BINARY_LEFT_EQUAL reduce using rule 141 (lhs -> variable .)
    BINARY_RIGHT_EQUAL reduce using rule 141 (lhs -> variable .)
    AND_EQUAL       reduce using rule 141 (lhs -> variable .)
    OR_EQUAL        reduce using rule 141 (lhs -> variable .)

  ! COMMA           [ reduce using rule 141 (lhs -> variable .) ]


state 118

    (103) primary -> WHILE expr . do compstmt END
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    AND             shift and go to state 58
    OR              shift and go to state 59
    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 255
    term                           shift and go to state 61

state 119

    (101) primary -> UNLESS expr . then compstmt END
    (102) primary -> UNLESS expr . then compstmt ELSE compstmt END
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (129) then -> . TERM
    (130) then -> . THEN
    (131) then -> . TERM THEN

    AND             shift and go to state 58
    OR              shift and go to state 59
    TERM            shift and go to state 248
    THEN            shift and go to state 249

    then                           shift and go to state 256

state 120

    (104) primary -> UNTIL expr . do compstmt END
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    AND             shift and go to state 58
    OR              shift and go to state 59
    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 257
    term                           shift and go to state 61

state 121

    (14) stmt -> BEGIN LKEY . compstmt RKEY
    (82) primary -> LKEY . RKEY
    (83) primary -> LKEY . args RKEY
    (84) primary -> LKEY . assocs RKEY
    (85) primary -> LKEY . args COMMA RKEY
    (86) primary -> LKEY . assocs COMMA RKEY
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    RKEY            shift and go to state 123
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    TIMES           shift and go to state 44
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72

    compstmt                       shift and go to state 258
    args                           shift and go to state 124
    assocs                         shift and go to state 125
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    arg                            shift and go to state 259
    assoc                          shift and go to state 127
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    math_operations                shift and go to state 45
    primary                        shift and go to state 261
    function                       shift and go to state 18
    variable                       shift and go to state 19
    mlhs                           shift and go to state 22
    literal                        shift and go to state 36
    operation                      shift and go to state 28
    mlhs_item                      shift and go to state 43

state 122

    (108) primary -> BEGIN compstmt . rescue END
    (109) primary -> BEGIN compstmt . rescue ELSE compstmt END
    (110) primary -> BEGIN compstmt . rescue ENSURE compstmt END
    (111) primary -> BEGIN compstmt . rescue ELSE compstmt ENSURE compstmt END
    (122) rescue -> . RESCUE args do compstmt
    (123) rescue -> . RESCUE do compstmt
    (124) rescue -> . rescue RESCUE args do compstmt
    (125) rescue -> . rescue RESCUE do compstmt

    RESCUE          shift and go to state 263

    rescue                         shift and go to state 262

state 123

    (82) primary -> LKEY RKEY .

    LBRACKET        reduce using rule 82 (primary -> LKEY RKEY .)
    DOT             reduce using rule 82 (primary -> LKEY RKEY .)
    UNARY_OP        reduce using rule 82 (primary -> LKEY RKEY .)
    RANGE_INCLUSIVE reduce using rule 82 (primary -> LKEY RKEY .)
    RANGE_EXCLUSIVE reduce using rule 82 (primary -> LKEY RKEY .)
    OR_SYMBOL       reduce using rule 82 (primary -> LKEY RKEY .)
    BINARY_XOR_OP   reduce using rule 82 (primary -> LKEY RKEY .)
    BINARY_AND_OP   reduce using rule 82 (primary -> LKEY RKEY .)
    COMBINED_COMPARISON_OP reduce using rule 82 (primary -> LKEY RKEY .)
    GREATERTHAN     reduce using rule 82 (primary -> LKEY RKEY .)
    GREATERTHANEQUAL reduce using rule 82 (primary -> LKEY RKEY .)
    LESSERTHAN      reduce using rule 82 (primary -> LKEY RKEY .)
    LESSERTHANEQUAL reduce using rule 82 (primary -> LKEY RKEY .)
    EQUAL           reduce using rule 82 (primary -> LKEY RKEY .)
    CASE_EQUALITY   reduce using rule 82 (primary -> LKEY RKEY .)
    NOTEQUAL        reduce using rule 82 (primary -> LKEY RKEY .)
    MATCHED_STRINGS_OP reduce using rule 82 (primary -> LKEY RKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 82 (primary -> LKEY RKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 82 (primary -> LKEY RKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 82 (primary -> LKEY RKEY .)
    AND             reduce using rule 82 (primary -> LKEY RKEY .)
    OR              reduce using rule 82 (primary -> LKEY RKEY .)
    PLUS            reduce using rule 82 (primary -> LKEY RKEY .)
    MINUS           reduce using rule 82 (primary -> LKEY RKEY .)
    TIMES           reduce using rule 82 (primary -> LKEY RKEY .)
    DIVIDE          reduce using rule 82 (primary -> LKEY RKEY .)
    MOD             reduce using rule 82 (primary -> LKEY RKEY .)
    POW             reduce using rule 82 (primary -> LKEY RKEY .)
    IF              reduce using rule 82 (primary -> LKEY RKEY .)
    WHILE           reduce using rule 82 (primary -> LKEY RKEY .)
    UNLESS          reduce using rule 82 (primary -> LKEY RKEY .)
    UNTIL           reduce using rule 82 (primary -> LKEY RKEY .)
    TERM            reduce using rule 82 (primary -> LKEY RKEY .)
    $end            reduce using rule 82 (primary -> LKEY RKEY .)
    COMMA           reduce using rule 82 (primary -> LKEY RKEY .)
    RBRACKET        reduce using rule 82 (primary -> LKEY RKEY .)
    THEN            reduce using rule 82 (primary -> LKEY RKEY .)
    DO              reduce using rule 82 (primary -> LKEY RKEY .)
    RESCUE          reduce using rule 82 (primary -> LKEY RKEY .)
    HASH_ROCKET     reduce using rule 82 (primary -> LKEY RKEY .)
    RKEY            reduce using rule 82 (primary -> LKEY RKEY .)
    RPAREN          reduce using rule 82 (primary -> LKEY RKEY .)
    WHEN            reduce using rule 82 (primary -> LKEY RKEY .)
    LKEY            reduce using rule 82 (primary -> LKEY RKEY .)
    END             reduce using rule 82 (primary -> LKEY RKEY .)
    ELSIF           reduce using rule 82 (primary -> LKEY RKEY .)
    ELSE            reduce using rule 82 (primary -> LKEY RKEY .)
    ENSURE          reduce using rule 82 (primary -> LKEY RKEY .)
    NOT_SYMBOL      reduce using rule 82 (primary -> LKEY RKEY .)
    COMPLEMENT_OP   reduce using rule 82 (primary -> LKEY RKEY .)
    DEFINED_OP      reduce using rule 82 (primary -> LKEY RKEY .)
    NUMBER          reduce using rule 82 (primary -> LKEY RKEY .)
    LPAREN          reduce using rule 82 (primary -> LKEY RKEY .)
    RETURN          reduce using rule 82 (primary -> LKEY RKEY .)
    YIELD           reduce using rule 82 (primary -> LKEY RKEY .)
    CASE            reduce using rule 82 (primary -> LKEY RKEY .)
    FOR             reduce using rule 82 (primary -> LKEY RKEY .)
    BEGIN           reduce using rule 82 (primary -> LKEY RKEY .)
    CLASS           reduce using rule 82 (primary -> LKEY RKEY .)
    MODULE          reduce using rule 82 (primary -> LKEY RKEY .)
    DEF             reduce using rule 82 (primary -> LKEY RKEY .)
    VAR_GLOBAL      reduce using rule 82 (primary -> LKEY RKEY .)
    VAR_LOCAL       reduce using rule 82 (primary -> LKEY RKEY .)
    VAR_INSTANCE    reduce using rule 82 (primary -> LKEY RKEY .)
    VAR_CLASS       reduce using rule 82 (primary -> LKEY RKEY .)
    SYMBOL          reduce using rule 82 (primary -> LKEY RKEY .)
    STRING          reduce using rule 82 (primary -> LKEY RKEY .)
    IDENTIFIER      reduce using rule 82 (primary -> LKEY RKEY .)
    SUPER           reduce using rule 82 (primary -> LKEY RKEY .)


state 124

    (83) primary -> LKEY args . RKEY
    (85) primary -> LKEY args . COMMA RKEY

    RKEY            shift and go to state 264
    COMMA           shift and go to state 265


state 125

    (84) primary -> LKEY assocs . RKEY
    (86) primary -> LKEY assocs . COMMA RKEY

    RKEY            shift and go to state 266
    COMMA           shift and go to state 267


state 126

    (155) args -> arg .
    (156) args -> arg . COMMA arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (166) assoc -> arg . HASH_ROCKET arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RKEY            reduce using rule 155 (args -> arg .)
    IF              reduce using rule 155 (args -> arg .)
    WHILE           reduce using rule 155 (args -> arg .)
    UNLESS          reduce using rule 155 (args -> arg .)
    UNTIL           reduce using rule 155 (args -> arg .)
    TERM            reduce using rule 155 (args -> arg .)
    $end            reduce using rule 155 (args -> arg .)
    THEN            reduce using rule 155 (args -> arg .)
    DO              reduce using rule 155 (args -> arg .)
    RESCUE          reduce using rule 155 (args -> arg .)
    RPAREN          reduce using rule 155 (args -> arg .)
    WHEN            reduce using rule 155 (args -> arg .)
    LKEY            reduce using rule 155 (args -> arg .)
    END             reduce using rule 155 (args -> arg .)
    ELSIF           reduce using rule 155 (args -> arg .)
    ELSE            reduce using rule 155 (args -> arg .)
    ENSURE          reduce using rule 155 (args -> arg .)
    LBRACKET        reduce using rule 155 (args -> arg .)
    RBRACKET        reduce using rule 155 (args -> arg .)
    COMMA           shift and go to state 237
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    HASH_ROCKET     shift and go to state 268
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! COMMA           [ reduce using rule 155 (args -> arg .) ]
  ! AND             [ reduce using rule 155 (args -> arg .) ]
  ! OR              [ reduce using rule 155 (args -> arg .) ]


state 127

    (164) assocs -> assoc .
    (165) assocs -> assoc . COMMA assoc

  ! shift/reduce conflict for COMMA resolved as shift
    RKEY            reduce using rule 164 (assocs -> assoc .)
    AND             reduce using rule 164 (assocs -> assoc .)
    OR              reduce using rule 164 (assocs -> assoc .)
    IF              reduce using rule 164 (assocs -> assoc .)
    WHILE           reduce using rule 164 (assocs -> assoc .)
    UNLESS          reduce using rule 164 (assocs -> assoc .)
    UNTIL           reduce using rule 164 (assocs -> assoc .)
    TERM            reduce using rule 164 (assocs -> assoc .)
    $end            reduce using rule 164 (assocs -> assoc .)
    THEN            reduce using rule 164 (assocs -> assoc .)
    DO              reduce using rule 164 (assocs -> assoc .)
    RESCUE          reduce using rule 164 (assocs -> assoc .)
    RPAREN          reduce using rule 164 (assocs -> assoc .)
    WHEN            reduce using rule 164 (assocs -> assoc .)
    LKEY            reduce using rule 164 (assocs -> assoc .)
    END             reduce using rule 164 (assocs -> assoc .)
    ELSIF           reduce using rule 164 (assocs -> assoc .)
    ELSE            reduce using rule 164 (assocs -> assoc .)
    ENSURE          reduce using rule 164 (assocs -> assoc .)
    LBRACKET        reduce using rule 164 (assocs -> assoc .)
    RBRACKET        reduce using rule 164 (assocs -> assoc .)
    COMMA           shift and go to state 269

  ! COMMA           [ reduce using rule 164 (assocs -> assoc .) ]


state 128

    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    =               shift and go to state 236
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 129

    (67) arg -> primary .
    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation

  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
    COMMA           reduce using rule 67 (arg -> primary .)
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    HASH_ROCKET     reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    RKEY            reduce using rule 67 (arg -> primary .)
    IF              reduce using rule 67 (arg -> primary .)
    WHILE           reduce using rule 67 (arg -> primary .)
    UNLESS          reduce using rule 67 (arg -> primary .)
    UNTIL           reduce using rule 67 (arg -> primary .)
    TERM            reduce using rule 67 (arg -> primary .)
    $end            reduce using rule 67 (arg -> primary .)
    RESCUE          reduce using rule 67 (arg -> primary .)
    RPAREN          reduce using rule 67 (arg -> primary .)
    WHEN            reduce using rule 67 (arg -> primary .)
    LKEY            reduce using rule 67 (arg -> primary .)
    END             reduce using rule 67 (arg -> primary .)
    ELSIF           reduce using rule 67 (arg -> primary .)
    ELSE            reduce using rule 67 (arg -> primary .)
    ENSURE          reduce using rule 67 (arg -> primary .)
    RBRACKET        reduce using rule 67 (arg -> primary .)
    THEN            reduce using rule 67 (arg -> primary .)
    DO              reduce using rule 67 (arg -> primary .)
    NOT_SYMBOL      reduce using rule 67 (arg -> primary .)
    COMPLEMENT_OP   reduce using rule 67 (arg -> primary .)
    DEFINED_OP      reduce using rule 67 (arg -> primary .)
    NUMBER          reduce using rule 67 (arg -> primary .)
    LPAREN          reduce using rule 67 (arg -> primary .)
    RETURN          reduce using rule 67 (arg -> primary .)
    YIELD           reduce using rule 67 (arg -> primary .)
    CASE            reduce using rule 67 (arg -> primary .)
    FOR             reduce using rule 67 (arg -> primary .)
    BEGIN           reduce using rule 67 (arg -> primary .)
    CLASS           reduce using rule 67 (arg -> primary .)
    MODULE          reduce using rule 67 (arg -> primary .)
    DEF             reduce using rule 67 (arg -> primary .)
    VAR_GLOBAL      reduce using rule 67 (arg -> primary .)
    VAR_LOCAL       reduce using rule 67 (arg -> primary .)
    VAR_INSTANCE    reduce using rule 67 (arg -> primary .)
    VAR_CLASS       reduce using rule 67 (arg -> primary .)
    SYMBOL          reduce using rule 67 (arg -> primary .)
    STRING          reduce using rule 67 (arg -> primary .)
    IDENTIFIER      reduce using rule 67 (arg -> primary .)
    SUPER           reduce using rule 67 (arg -> primary .)
    LBRACKET        shift and go to state 147
    DOT             shift and go to state 238
    UNARY_OP        shift and go to state 239

  ! LBRACKET        [ reduce using rule 67 (arg -> primary .) ]
  ! UNARY_OP        [ reduce using rule 67 (arg -> primary .) ]


state 130

    (72) primary -> LPAREN . compstmt RPAREN
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 192
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 131

    (16) stmt -> lhs = . command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (40) arg -> lhs = . arg
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    lhs                            shift and go to state 128
    command                        shift and go to state 270
    arg                            shift and go to state 271
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 132

    (41) arg -> lhs op_asgn . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    lhs                            shift and go to state 128
    arg                            shift and go to state 272
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 133

    (216) op_asgn -> PLUS_EQUAL .

    PLUS            reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    MINUS           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    NOT_SYMBOL      reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    COMPLEMENT_OP   reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    DEFINED_OP      reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    NUMBER          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    LPAREN          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    UNARY_OP        reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    LBRACKET        reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    LKEY            reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    RETURN          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    YIELD           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    IF              reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    UNLESS          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    WHILE           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    UNTIL           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    CASE            reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    FOR             reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    BEGIN           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    CLASS           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    MODULE          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    DEF             reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    VAR_GLOBAL      reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    VAR_LOCAL       reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    VAR_INSTANCE    reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    VAR_CLASS       reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    SYMBOL          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    STRING          reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    IDENTIFIER      reduce using rule 216 (op_asgn -> PLUS_EQUAL .)
    SUPER           reduce using rule 216 (op_asgn -> PLUS_EQUAL .)


state 134

    (217) op_asgn -> MINUS_EQUAL .

    PLUS            reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    MINUS           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    NOT_SYMBOL      reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    COMPLEMENT_OP   reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    DEFINED_OP      reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    NUMBER          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    LPAREN          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    UNARY_OP        reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    LBRACKET        reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    LKEY            reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    RETURN          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    YIELD           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    IF              reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    UNLESS          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    WHILE           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    UNTIL           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    CASE            reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    FOR             reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    BEGIN           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    CLASS           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    MODULE          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    DEF             reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    VAR_GLOBAL      reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    VAR_LOCAL       reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    VAR_INSTANCE    reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    VAR_CLASS       reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    SYMBOL          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    STRING          reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    IDENTIFIER      reduce using rule 217 (op_asgn -> MINUS_EQUAL .)
    SUPER           reduce using rule 217 (op_asgn -> MINUS_EQUAL .)


state 135

    (218) op_asgn -> TIMES_EQUAL .

    PLUS            reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    MINUS           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    NOT_SYMBOL      reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    COMPLEMENT_OP   reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    DEFINED_OP      reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    NUMBER          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    LPAREN          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    UNARY_OP        reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    LBRACKET        reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    LKEY            reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    RETURN          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    YIELD           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    IF              reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    UNLESS          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    WHILE           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    UNTIL           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    CASE            reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    FOR             reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    BEGIN           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    CLASS           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    MODULE          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    DEF             reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    VAR_GLOBAL      reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    VAR_LOCAL       reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    VAR_INSTANCE    reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    VAR_CLASS       reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    SYMBOL          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    STRING          reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    IDENTIFIER      reduce using rule 218 (op_asgn -> TIMES_EQUAL .)
    SUPER           reduce using rule 218 (op_asgn -> TIMES_EQUAL .)


state 136

    (219) op_asgn -> DIVIDE_EQUAL .

    PLUS            reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    MINUS           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    NOT_SYMBOL      reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    COMPLEMENT_OP   reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    DEFINED_OP      reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    NUMBER          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    LPAREN          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    UNARY_OP        reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    LBRACKET        reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    LKEY            reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    RETURN          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    YIELD           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    IF              reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    UNLESS          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    WHILE           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    UNTIL           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    CASE            reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    FOR             reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    BEGIN           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    CLASS           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    MODULE          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    DEF             reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    VAR_GLOBAL      reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    VAR_LOCAL       reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    VAR_INSTANCE    reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    VAR_CLASS       reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    SYMBOL          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    STRING          reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    IDENTIFIER      reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)
    SUPER           reduce using rule 219 (op_asgn -> DIVIDE_EQUAL .)


state 137

    (220) op_asgn -> MOD_EQUAL .

    PLUS            reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    MINUS           reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    NOT_SYMBOL      reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    COMPLEMENT_OP   reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    DEFINED_OP      reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    NUMBER          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    LPAREN          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    UNARY_OP        reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    LBRACKET        reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    LKEY            reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    RETURN          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    YIELD           reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    IF              reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    UNLESS          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    WHILE           reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    UNTIL           reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    CASE            reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    FOR             reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    BEGIN           reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    CLASS           reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    MODULE          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    DEF             reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    VAR_GLOBAL      reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    VAR_LOCAL       reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    VAR_INSTANCE    reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    VAR_CLASS       reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    SYMBOL          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    STRING          reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    IDENTIFIER      reduce using rule 220 (op_asgn -> MOD_EQUAL .)
    SUPER           reduce using rule 220 (op_asgn -> MOD_EQUAL .)


state 138

    (221) op_asgn -> POW_EQUAL .

    PLUS            reduce using rule 221 (op_asgn -> POW_EQUAL .)
    MINUS           reduce using rule 221 (op_asgn -> POW_EQUAL .)
    NOT_SYMBOL      reduce using rule 221 (op_asgn -> POW_EQUAL .)
    COMPLEMENT_OP   reduce using rule 221 (op_asgn -> POW_EQUAL .)
    DEFINED_OP      reduce using rule 221 (op_asgn -> POW_EQUAL .)
    NUMBER          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    LPAREN          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    UNARY_OP        reduce using rule 221 (op_asgn -> POW_EQUAL .)
    LBRACKET        reduce using rule 221 (op_asgn -> POW_EQUAL .)
    LKEY            reduce using rule 221 (op_asgn -> POW_EQUAL .)
    RETURN          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    YIELD           reduce using rule 221 (op_asgn -> POW_EQUAL .)
    IF              reduce using rule 221 (op_asgn -> POW_EQUAL .)
    UNLESS          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    WHILE           reduce using rule 221 (op_asgn -> POW_EQUAL .)
    UNTIL           reduce using rule 221 (op_asgn -> POW_EQUAL .)
    CASE            reduce using rule 221 (op_asgn -> POW_EQUAL .)
    FOR             reduce using rule 221 (op_asgn -> POW_EQUAL .)
    BEGIN           reduce using rule 221 (op_asgn -> POW_EQUAL .)
    CLASS           reduce using rule 221 (op_asgn -> POW_EQUAL .)
    MODULE          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    DEF             reduce using rule 221 (op_asgn -> POW_EQUAL .)
    VAR_GLOBAL      reduce using rule 221 (op_asgn -> POW_EQUAL .)
    VAR_LOCAL       reduce using rule 221 (op_asgn -> POW_EQUAL .)
    VAR_INSTANCE    reduce using rule 221 (op_asgn -> POW_EQUAL .)
    VAR_CLASS       reduce using rule 221 (op_asgn -> POW_EQUAL .)
    SYMBOL          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    STRING          reduce using rule 221 (op_asgn -> POW_EQUAL .)
    IDENTIFIER      reduce using rule 221 (op_asgn -> POW_EQUAL .)
    SUPER           reduce using rule 221 (op_asgn -> POW_EQUAL .)


state 139

    (222) op_asgn -> SINGLE_AND_EQUAL .

    PLUS            reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    MINUS           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    NOT_SYMBOL      reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    COMPLEMENT_OP   reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    DEFINED_OP      reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    NUMBER          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    LPAREN          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    UNARY_OP        reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    LBRACKET        reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    LKEY            reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    RETURN          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    YIELD           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    IF              reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    UNLESS          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    WHILE           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    UNTIL           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    CASE            reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    FOR             reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    BEGIN           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    CLASS           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    MODULE          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    DEF             reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    VAR_GLOBAL      reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    VAR_LOCAL       reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    VAR_INSTANCE    reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    VAR_CLASS       reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    SYMBOL          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    STRING          reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    IDENTIFIER      reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)
    SUPER           reduce using rule 222 (op_asgn -> SINGLE_AND_EQUAL .)


state 140

    (223) op_asgn -> SINGLE_OR_EQUAL .

    PLUS            reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    MINUS           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    NOT_SYMBOL      reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    COMPLEMENT_OP   reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    DEFINED_OP      reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    NUMBER          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    LPAREN          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    UNARY_OP        reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    LBRACKET        reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    LKEY            reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    RETURN          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    YIELD           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    IF              reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    UNLESS          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    WHILE           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    UNTIL           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    CASE            reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    FOR             reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    BEGIN           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    CLASS           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    MODULE          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    DEF             reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    VAR_GLOBAL      reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    VAR_LOCAL       reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    VAR_INSTANCE    reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    VAR_CLASS       reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    SYMBOL          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    STRING          reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    IDENTIFIER      reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)
    SUPER           reduce using rule 223 (op_asgn -> SINGLE_OR_EQUAL .)


state 141

    (224) op_asgn -> XOR_EQUAL .

    PLUS            reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    MINUS           reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    NOT_SYMBOL      reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    COMPLEMENT_OP   reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    DEFINED_OP      reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    NUMBER          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    LPAREN          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    UNARY_OP        reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    LBRACKET        reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    LKEY            reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    RETURN          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    YIELD           reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    IF              reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    UNLESS          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    WHILE           reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    UNTIL           reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    CASE            reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    FOR             reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    BEGIN           reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    CLASS           reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    MODULE          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    DEF             reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    VAR_GLOBAL      reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    VAR_LOCAL       reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    VAR_INSTANCE    reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    VAR_CLASS       reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    SYMBOL          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    STRING          reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    IDENTIFIER      reduce using rule 224 (op_asgn -> XOR_EQUAL .)
    SUPER           reduce using rule 224 (op_asgn -> XOR_EQUAL .)


state 142

    (225) op_asgn -> BINARY_LEFT_EQUAL .

    PLUS            reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    MINUS           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    NOT_SYMBOL      reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    COMPLEMENT_OP   reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    DEFINED_OP      reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    NUMBER          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    LPAREN          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    UNARY_OP        reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    LBRACKET        reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    LKEY            reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    RETURN          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    YIELD           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    IF              reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    UNLESS          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    WHILE           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    UNTIL           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    CASE            reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    FOR             reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    BEGIN           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    CLASS           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    MODULE          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    DEF             reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    VAR_GLOBAL      reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    VAR_LOCAL       reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    VAR_INSTANCE    reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    VAR_CLASS       reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    SYMBOL          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    STRING          reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    IDENTIFIER      reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)
    SUPER           reduce using rule 225 (op_asgn -> BINARY_LEFT_EQUAL .)


state 143

    (226) op_asgn -> BINARY_RIGHT_EQUAL .

    PLUS            reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    MINUS           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    NOT_SYMBOL      reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    COMPLEMENT_OP   reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    DEFINED_OP      reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    NUMBER          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    LPAREN          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    UNARY_OP        reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    LBRACKET        reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    LKEY            reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    RETURN          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    YIELD           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    IF              reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    UNLESS          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    WHILE           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    UNTIL           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    CASE            reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    FOR             reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    BEGIN           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    CLASS           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    MODULE          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    DEF             reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    VAR_GLOBAL      reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    VAR_LOCAL       reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    VAR_INSTANCE    reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    VAR_CLASS       reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    SYMBOL          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    STRING          reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    IDENTIFIER      reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)
    SUPER           reduce using rule 226 (op_asgn -> BINARY_RIGHT_EQUAL .)


state 144

    (227) op_asgn -> AND_EQUAL .

    PLUS            reduce using rule 227 (op_asgn -> AND_EQUAL .)
    MINUS           reduce using rule 227 (op_asgn -> AND_EQUAL .)
    NOT_SYMBOL      reduce using rule 227 (op_asgn -> AND_EQUAL .)
    COMPLEMENT_OP   reduce using rule 227 (op_asgn -> AND_EQUAL .)
    DEFINED_OP      reduce using rule 227 (op_asgn -> AND_EQUAL .)
    NUMBER          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    LPAREN          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    UNARY_OP        reduce using rule 227 (op_asgn -> AND_EQUAL .)
    LBRACKET        reduce using rule 227 (op_asgn -> AND_EQUAL .)
    LKEY            reduce using rule 227 (op_asgn -> AND_EQUAL .)
    RETURN          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    YIELD           reduce using rule 227 (op_asgn -> AND_EQUAL .)
    IF              reduce using rule 227 (op_asgn -> AND_EQUAL .)
    UNLESS          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    WHILE           reduce using rule 227 (op_asgn -> AND_EQUAL .)
    UNTIL           reduce using rule 227 (op_asgn -> AND_EQUAL .)
    CASE            reduce using rule 227 (op_asgn -> AND_EQUAL .)
    FOR             reduce using rule 227 (op_asgn -> AND_EQUAL .)
    BEGIN           reduce using rule 227 (op_asgn -> AND_EQUAL .)
    CLASS           reduce using rule 227 (op_asgn -> AND_EQUAL .)
    MODULE          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    DEF             reduce using rule 227 (op_asgn -> AND_EQUAL .)
    VAR_GLOBAL      reduce using rule 227 (op_asgn -> AND_EQUAL .)
    VAR_LOCAL       reduce using rule 227 (op_asgn -> AND_EQUAL .)
    VAR_INSTANCE    reduce using rule 227 (op_asgn -> AND_EQUAL .)
    VAR_CLASS       reduce using rule 227 (op_asgn -> AND_EQUAL .)
    SYMBOL          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    STRING          reduce using rule 227 (op_asgn -> AND_EQUAL .)
    IDENTIFIER      reduce using rule 227 (op_asgn -> AND_EQUAL .)
    SUPER           reduce using rule 227 (op_asgn -> AND_EQUAL .)


state 145

    (228) op_asgn -> OR_EQUAL .

    PLUS            reduce using rule 228 (op_asgn -> OR_EQUAL .)
    MINUS           reduce using rule 228 (op_asgn -> OR_EQUAL .)
    NOT_SYMBOL      reduce using rule 228 (op_asgn -> OR_EQUAL .)
    COMPLEMENT_OP   reduce using rule 228 (op_asgn -> OR_EQUAL .)
    DEFINED_OP      reduce using rule 228 (op_asgn -> OR_EQUAL .)
    NUMBER          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    LPAREN          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    UNARY_OP        reduce using rule 228 (op_asgn -> OR_EQUAL .)
    LBRACKET        reduce using rule 228 (op_asgn -> OR_EQUAL .)
    LKEY            reduce using rule 228 (op_asgn -> OR_EQUAL .)
    RETURN          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    YIELD           reduce using rule 228 (op_asgn -> OR_EQUAL .)
    IF              reduce using rule 228 (op_asgn -> OR_EQUAL .)
    UNLESS          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    WHILE           reduce using rule 228 (op_asgn -> OR_EQUAL .)
    UNTIL           reduce using rule 228 (op_asgn -> OR_EQUAL .)
    CASE            reduce using rule 228 (op_asgn -> OR_EQUAL .)
    FOR             reduce using rule 228 (op_asgn -> OR_EQUAL .)
    BEGIN           reduce using rule 228 (op_asgn -> OR_EQUAL .)
    CLASS           reduce using rule 228 (op_asgn -> OR_EQUAL .)
    MODULE          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    DEF             reduce using rule 228 (op_asgn -> OR_EQUAL .)
    VAR_GLOBAL      reduce using rule 228 (op_asgn -> OR_EQUAL .)
    VAR_LOCAL       reduce using rule 228 (op_asgn -> OR_EQUAL .)
    VAR_INSTANCE    reduce using rule 228 (op_asgn -> OR_EQUAL .)
    VAR_CLASS       reduce using rule 228 (op_asgn -> OR_EQUAL .)
    SYMBOL          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    STRING          reduce using rule 228 (op_asgn -> OR_EQUAL .)
    IDENTIFIER      reduce using rule 228 (op_asgn -> OR_EQUAL .)
    SUPER           reduce using rule 228 (op_asgn -> OR_EQUAL .)


state 146

    (95) primary -> function LKEY . compstmt LKEY
    (96) primary -> function LKEY . OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> function LKEY . OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    OR_SYMBOL       shift and go to state 274
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    function                       shift and go to state 18
    compstmt                       shift and go to state 273
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 147

    (142) lhs -> primary LBRACKET . RBRACKET
    (143) lhs -> primary LBRACKET . args RBRACKET
    (77) primary -> primary LBRACKET . RBRACKET
    (78) primary -> primary LBRACKET . args RBRACKET
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    RBRACKET        shift and go to state 275
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    primary                        shift and go to state 129
    args                           shift and go to state 276
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 148

    (144) lhs -> primary DOT . IDENTIFIER
    (34) function -> primary DOT . operation LPAREN call_args RPAREN
    (36) function -> primary DOT . operation
    (30) command -> primary DOT . operation call_args
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 277

    operation                      shift and go to state 278

state 149

    (35) function -> primary UNARY_OP . operation LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP . operation
    (31) command -> primary UNARY_OP . operation call_args
    (75) primary -> primary UNARY_OP . IDENTIFIER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 280

    operation                      shift and go to state 279

state 150

    (214) operation -> IDENTIFIER NOT_SYMBOL .

    LBRACKET        reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    TIMES           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    BINARY_AND_OP   reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    SUPER           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    PLUS            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    MINUS           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    NOT_SYMBOL      reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    COMPLEMENT_OP   reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    DEFINED_OP      reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    IDENTIFIER      reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    LPAREN          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    UNARY_OP        reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    LKEY            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RETURN          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    YIELD           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    IF              reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    UNLESS          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    WHILE           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    UNTIL           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    CASE            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    FOR             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    BEGIN           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    CLASS           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    MODULE          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    DEF             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    NUMBER          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    SYMBOL          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    STRING          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    VAR_GLOBAL      reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    VAR_LOCAL       reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    VAR_INSTANCE    reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    VAR_CLASS       reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    DO              reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    TERM            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    DOT             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RANGE_EXCLUSIVE reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    OR_SYMBOL       reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    BINARY_XOR_OP   reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    COMBINED_COMPARISON_OP reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    GREATERTHAN     reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    GREATERTHANEQUAL reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    LESSERTHAN      reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    LESSERTHANEQUAL reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    EQUAL           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    CASE_EQUALITY   reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    NOTEQUAL        reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    MATCHED_STRINGS_OP reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    AND             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    OR              reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    DIVIDE          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    MOD             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    POW             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    $end            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RESCUE          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RPAREN          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    WHEN            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RKEY            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    COMMA           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    HASH_ROCKET     reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    END             reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    ELSIF           reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    ELSE            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    ENSURE          reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    RBRACKET        reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)
    THEN            reduce using rule 214 (operation -> IDENTIFIER NOT_SYMBOL .)


state 151

    (215) operation -> IDENTIFIER OPTIONAL_SYMBOL .

    LBRACKET        reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    TIMES           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    BINARY_AND_OP   reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    SUPER           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    PLUS            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    MINUS           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    NOT_SYMBOL      reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    COMPLEMENT_OP   reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    DEFINED_OP      reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    IDENTIFIER      reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    LPAREN          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    UNARY_OP        reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    LKEY            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RETURN          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    YIELD           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    IF              reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    UNLESS          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    WHILE           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    UNTIL           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    CASE            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    FOR             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    BEGIN           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    CLASS           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    MODULE          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    DEF             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    NUMBER          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    SYMBOL          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    STRING          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    VAR_GLOBAL      reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    VAR_LOCAL       reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    VAR_INSTANCE    reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    VAR_CLASS       reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    DO              reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    TERM            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    DOT             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RANGE_EXCLUSIVE reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    OR_SYMBOL       reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    BINARY_XOR_OP   reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    COMBINED_COMPARISON_OP reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    GREATERTHAN     reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    GREATERTHANEQUAL reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    LESSERTHAN      reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    LESSERTHANEQUAL reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    EQUAL           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    CASE_EQUALITY   reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    NOTEQUAL        reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    MATCHED_STRINGS_OP reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    AND             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    OR              reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    DIVIDE          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    MOD             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    POW             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    $end            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RESCUE          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RPAREN          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    WHEN            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RKEY            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    COMMA           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    HASH_ROCKET     reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    END             reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    ELSIF           reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    ELSE            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    ENSURE          reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    RBRACKET        reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)
    THEN            reduce using rule 215 (operation -> IDENTIFIER OPTIONAL_SYMBOL .)


state 152

    (18) expr -> mlhs = . mrhs
    (136) mrhs -> . args
    (137) mrhs -> . args COMMA
    (138) mrhs -> . args TIMES
    (139) mrhs -> . args arg
    (140) mrhs -> . TIMES arg
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 283
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    mrhs                           shift and go to state 281
    args                           shift and go to state 282
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 153

    (19) expr -> RETURN call_args .

    AND             reduce using rule 19 (expr -> RETURN call_args .)
    OR              reduce using rule 19 (expr -> RETURN call_args .)
    IF              reduce using rule 19 (expr -> RETURN call_args .)
    WHILE           reduce using rule 19 (expr -> RETURN call_args .)
    UNLESS          reduce using rule 19 (expr -> RETURN call_args .)
    UNTIL           reduce using rule 19 (expr -> RETURN call_args .)
    TERM            reduce using rule 19 (expr -> RETURN call_args .)
    $end            reduce using rule 19 (expr -> RETURN call_args .)
    THEN            reduce using rule 19 (expr -> RETURN call_args .)
    DO              reduce using rule 19 (expr -> RETURN call_args .)
    RESCUE          reduce using rule 19 (expr -> RETURN call_args .)
    RPAREN          reduce using rule 19 (expr -> RETURN call_args .)
    WHEN            reduce using rule 19 (expr -> RETURN call_args .)
    RKEY            reduce using rule 19 (expr -> RETURN call_args .)
    LKEY            reduce using rule 19 (expr -> RETURN call_args .)
    END             reduce using rule 19 (expr -> RETURN call_args .)
    ELSIF           reduce using rule 19 (expr -> RETURN call_args .)
    ELSE            reduce using rule 19 (expr -> RETURN call_args .)
    ENSURE          reduce using rule 19 (expr -> RETURN call_args .)


state 154

    (88) primary -> RETURN LPAREN . RPAREN
    (89) primary -> RETURN LPAREN . call_args RPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    RPAREN          shift and go to state 285
    TIMES           shift and go to state 287
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 284
    YIELD           shift and go to state 289
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NOT             shift and go to state 25
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    call_args                      shift and go to state 286
    compstmt                       shift and go to state 192
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 259
    command                        shift and go to state 288
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 290
    mlhs                           shift and go to state 22
    mlhs_item                      shift and go to state 43

state 155

    (167) call_args -> args .
    (168) call_args -> args . COMMA assocs
    (169) call_args -> args . COMMA TIMES arg
    (170) call_args -> args . COMMA BINARY_AND_OP arg
    (171) call_args -> args . COMMA assocs COMMA TIMES arg
    (172) call_args -> args . COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> args . COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> args . COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg

    AND             reduce using rule 167 (call_args -> args .)
    OR              reduce using rule 167 (call_args -> args .)
    IF              reduce using rule 167 (call_args -> args .)
    WHILE           reduce using rule 167 (call_args -> args .)
    UNLESS          reduce using rule 167 (call_args -> args .)
    UNTIL           reduce using rule 167 (call_args -> args .)
    TERM            reduce using rule 167 (call_args -> args .)
    $end            reduce using rule 167 (call_args -> args .)
    THEN            reduce using rule 167 (call_args -> args .)
    DO              reduce using rule 167 (call_args -> args .)
    RESCUE          reduce using rule 167 (call_args -> args .)
    RPAREN          reduce using rule 167 (call_args -> args .)
    WHEN            reduce using rule 167 (call_args -> args .)
    RKEY            reduce using rule 167 (call_args -> args .)
    LKEY            reduce using rule 167 (call_args -> args .)
    END             reduce using rule 167 (call_args -> args .)
    ELSIF           reduce using rule 167 (call_args -> args .)
    ELSE            reduce using rule 167 (call_args -> args .)
    ENSURE          reduce using rule 167 (call_args -> args .)
    LBRACKET        reduce using rule 167 (call_args -> args .)
    RBRACKET        reduce using rule 167 (call_args -> args .)
    COMMA           shift and go to state 291


state 156

    (175) call_args -> assocs .
    (176) call_args -> assocs . COMMA TIMES arg
    (177) call_args -> assocs . COMMA BINARY_AND_OP arg
    (178) call_args -> assocs . COMMA TIMES arg COMMA BINARY_AND_OP arg

    AND             reduce using rule 175 (call_args -> assocs .)
    OR              reduce using rule 175 (call_args -> assocs .)
    IF              reduce using rule 175 (call_args -> assocs .)
    WHILE           reduce using rule 175 (call_args -> assocs .)
    UNLESS          reduce using rule 175 (call_args -> assocs .)
    UNTIL           reduce using rule 175 (call_args -> assocs .)
    TERM            reduce using rule 175 (call_args -> assocs .)
    $end            reduce using rule 175 (call_args -> assocs .)
    THEN            reduce using rule 175 (call_args -> assocs .)
    DO              reduce using rule 175 (call_args -> assocs .)
    RESCUE          reduce using rule 175 (call_args -> assocs .)
    RPAREN          reduce using rule 175 (call_args -> assocs .)
    WHEN            reduce using rule 175 (call_args -> assocs .)
    RKEY            reduce using rule 175 (call_args -> assocs .)
    LKEY            reduce using rule 175 (call_args -> assocs .)
    END             reduce using rule 175 (call_args -> assocs .)
    ELSIF           reduce using rule 175 (call_args -> assocs .)
    ELSE            reduce using rule 175 (call_args -> assocs .)
    ENSURE          reduce using rule 175 (call_args -> assocs .)
    LBRACKET        reduce using rule 175 (call_args -> assocs .)
    RBRACKET        reduce using rule 175 (call_args -> assocs .)
    COMMA           shift and go to state 292


state 157

    (179) call_args -> TIMES . arg
    (180) call_args -> TIMES . arg COMMA BINARY_AND_OP arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 293
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 158

    (181) call_args -> BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 294
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 159

    (182) call_args -> command .

    AND             reduce using rule 182 (call_args -> command .)
    OR              reduce using rule 182 (call_args -> command .)
    IF              reduce using rule 182 (call_args -> command .)
    WHILE           reduce using rule 182 (call_args -> command .)
    UNLESS          reduce using rule 182 (call_args -> command .)
    UNTIL           reduce using rule 182 (call_args -> command .)
    TERM            reduce using rule 182 (call_args -> command .)
    $end            reduce using rule 182 (call_args -> command .)
    THEN            reduce using rule 182 (call_args -> command .)
    DO              reduce using rule 182 (call_args -> command .)
    RESCUE          reduce using rule 182 (call_args -> command .)
    RPAREN          reduce using rule 182 (call_args -> command .)
    WHEN            reduce using rule 182 (call_args -> command .)
    RKEY            reduce using rule 182 (call_args -> command .)
    LKEY            reduce using rule 182 (call_args -> command .)
    END             reduce using rule 182 (call_args -> command .)
    ELSIF           reduce using rule 182 (call_args -> command .)
    ELSE            reduce using rule 182 (call_args -> command .)
    ENSURE          reduce using rule 182 (call_args -> command .)
    LBRACKET        reduce using rule 182 (call_args -> command .)
    RBRACKET        reduce using rule 182 (call_args -> command .)


state 160

    (20) expr -> YIELD call_args .

    AND             reduce using rule 20 (expr -> YIELD call_args .)
    OR              reduce using rule 20 (expr -> YIELD call_args .)
    IF              reduce using rule 20 (expr -> YIELD call_args .)
    WHILE           reduce using rule 20 (expr -> YIELD call_args .)
    UNLESS          reduce using rule 20 (expr -> YIELD call_args .)
    UNTIL           reduce using rule 20 (expr -> YIELD call_args .)
    TERM            reduce using rule 20 (expr -> YIELD call_args .)
    $end            reduce using rule 20 (expr -> YIELD call_args .)
    THEN            reduce using rule 20 (expr -> YIELD call_args .)
    DO              reduce using rule 20 (expr -> YIELD call_args .)
    RESCUE          reduce using rule 20 (expr -> YIELD call_args .)
    RPAREN          reduce using rule 20 (expr -> YIELD call_args .)
    WHEN            reduce using rule 20 (expr -> YIELD call_args .)
    RKEY            reduce using rule 20 (expr -> YIELD call_args .)
    LKEY            reduce using rule 20 (expr -> YIELD call_args .)
    END             reduce using rule 20 (expr -> YIELD call_args .)
    ELSIF           reduce using rule 20 (expr -> YIELD call_args .)
    ELSE            reduce using rule 20 (expr -> YIELD call_args .)
    ENSURE          reduce using rule 20 (expr -> YIELD call_args .)


state 161

    (91) primary -> YIELD LPAREN . RPAREN
    (92) primary -> YIELD LPAREN . call_args RPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    RPAREN          shift and go to state 295
    TIMES           shift and go to state 287
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 284
    YIELD           shift and go to state 289
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NOT             shift and go to state 25
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    call_args                      shift and go to state 296
    compstmt                       shift and go to state 192
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 259
    command                        shift and go to state 288
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 290
    mlhs                           shift and go to state 22
    mlhs_item                      shift and go to state 43

state 162

    (23) expr -> NOT expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 23 (expr -> NOT expr .)
    WHILE           reduce using rule 23 (expr -> NOT expr .)
    UNLESS          reduce using rule 23 (expr -> NOT expr .)
    UNTIL           reduce using rule 23 (expr -> NOT expr .)
    TERM            reduce using rule 23 (expr -> NOT expr .)
    $end            reduce using rule 23 (expr -> NOT expr .)
    THEN            reduce using rule 23 (expr -> NOT expr .)
    DO              reduce using rule 23 (expr -> NOT expr .)
    RESCUE          reduce using rule 23 (expr -> NOT expr .)
    RPAREN          reduce using rule 23 (expr -> NOT expr .)
    WHEN            reduce using rule 23 (expr -> NOT expr .)
    RKEY            reduce using rule 23 (expr -> NOT expr .)
    LKEY            reduce using rule 23 (expr -> NOT expr .)
    END             reduce using rule 23 (expr -> NOT expr .)
    ELSIF           reduce using rule 23 (expr -> NOT expr .)
    ELSE            reduce using rule 23 (expr -> NOT expr .)
    ENSURE          reduce using rule 23 (expr -> NOT expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59

  ! AND             [ reduce using rule 23 (expr -> NOT expr .) ]
  ! OR              [ reduce using rule 23 (expr -> NOT expr .) ]


state 163

    (25) expr -> NOT_SYMBOL command .

    AND             reduce using rule 25 (expr -> NOT_SYMBOL command .)
    OR              reduce using rule 25 (expr -> NOT_SYMBOL command .)
    IF              reduce using rule 25 (expr -> NOT_SYMBOL command .)
    WHILE           reduce using rule 25 (expr -> NOT_SYMBOL command .)
    UNLESS          reduce using rule 25 (expr -> NOT_SYMBOL command .)
    UNTIL           reduce using rule 25 (expr -> NOT_SYMBOL command .)
    TERM            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    $end            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    THEN            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    DO              reduce using rule 25 (expr -> NOT_SYMBOL command .)
    RESCUE          reduce using rule 25 (expr -> NOT_SYMBOL command .)
    RPAREN          reduce using rule 25 (expr -> NOT_SYMBOL command .)
    WHEN            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    RKEY            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    LKEY            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    END             reduce using rule 25 (expr -> NOT_SYMBOL command .)
    ELSIF           reduce using rule 25 (expr -> NOT_SYMBOL command .)
    ELSE            reduce using rule 25 (expr -> NOT_SYMBOL command .)
    ENSURE          reduce using rule 25 (expr -> NOT_SYMBOL command .)


state 164

    (60) arg -> NOT_SYMBOL arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    WHILE           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    UNLESS          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    UNTIL           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    TERM            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    $end            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    COMMA           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    RBRACKET        reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    THEN            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    DO              reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    RESCUE          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    HASH_ROCKET     reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    RKEY            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    RPAREN          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    WHEN            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    LKEY            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    END             reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    ELSIF           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    ELSE            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    ENSURE          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    LBRACKET        reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    NOT_SYMBOL      reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    COMPLEMENT_OP   reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    DEFINED_OP      reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    NUMBER          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    LPAREN          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    UNARY_OP        reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    RETURN          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    YIELD           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    CASE            reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    FOR             reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    BEGIN           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    CLASS           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    MODULE          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    DEF             reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    VAR_GLOBAL      reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    VAR_LOCAL       reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    VAR_INSTANCE    reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    VAR_CLASS       reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    SYMBOL          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    STRING          reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    IDENTIFIER      reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    SUPER           reduce using rule 60 (arg -> NOT_SYMBOL arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! OR_SYMBOL       [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! GREATERTHAN     [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! LESSERTHAN      [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! EQUAL           [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! NOTEQUAL        [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! AND             [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! OR              [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! PLUS            [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! MINUS           [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! TIMES           [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! DIVIDE          [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! MOD             [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]
  ! POW             [ reduce using rule 60 (arg -> NOT_SYMBOL arg .) ]


state 165

    (42) arg -> arg RANGE_INCLUSIVE . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 297
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 166

    (43) arg -> arg RANGE_EXCLUSIVE . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 298
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 167

    (47) arg -> arg OR_SYMBOL . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 299
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 168

    (48) arg -> arg BINARY_XOR_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 300
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 169

    (49) arg -> arg BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 301
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 170

    (50) arg -> arg COMBINED_COMPARISON_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 302
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 171

    (51) arg -> arg GREATERTHAN . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 303
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 172

    (52) arg -> arg GREATERTHANEQUAL . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 304
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 173

    (53) arg -> arg LESSERTHAN . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 305
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 174

    (54) arg -> arg LESSERTHANEQUAL . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 306
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 175

    (55) arg -> arg EQUAL . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 307
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 176

    (56) arg -> arg CASE_EQUALITY . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 308
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 177

    (57) arg -> arg NOTEQUAL . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 309
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 178

    (58) arg -> arg MATCHED_STRINGS_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 310
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 179

    (59) arg -> arg OPPOSITE_MATCHED_STRINGS_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 311
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 180

    (62) arg -> arg BINARY_LEFT_SHIFT_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 312
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 181

    (63) arg -> arg BINARY_RIGHT_SHIFT_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 313
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 182

    (64) arg -> arg AND . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 314
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 183

    (65) arg -> arg OR . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 315
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 184

    (229) math_operations -> arg PLUS . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 316
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 185

    (230) math_operations -> arg MINUS . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 317
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 186

    (231) math_operations -> arg TIMES . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 318
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 187

    (232) math_operations -> arg DIVIDE . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 319
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 188

    (233) math_operations -> arg MOD . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 320
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 189

    (234) math_operations -> arg POW . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 321
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 190

    (33) function -> operation LBRACKET . LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (79) primary -> LBRACKET . RBRACKET
    (80) primary -> LBRACKET . args RBRACKET
    (81) primary -> LBRACKET . args COMMA RBRACKET
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    LPAREN          shift and go to state 322
    RBRACKET        shift and go to state 65
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    operation                      shift and go to state 80
    args                           shift and go to state 67
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77

state 191

    (29) command -> operation call_args .

    DO              reduce using rule 29 (command -> operation call_args .)
    TERM            reduce using rule 29 (command -> operation call_args .)
    AND             reduce using rule 29 (command -> operation call_args .)
    OR              reduce using rule 29 (command -> operation call_args .)
    IF              reduce using rule 29 (command -> operation call_args .)
    WHILE           reduce using rule 29 (command -> operation call_args .)
    UNLESS          reduce using rule 29 (command -> operation call_args .)
    UNTIL           reduce using rule 29 (command -> operation call_args .)
    $end            reduce using rule 29 (command -> operation call_args .)
    THEN            reduce using rule 29 (command -> operation call_args .)
    RESCUE          reduce using rule 29 (command -> operation call_args .)
    RPAREN          reduce using rule 29 (command -> operation call_args .)
    WHEN            reduce using rule 29 (command -> operation call_args .)
    RKEY            reduce using rule 29 (command -> operation call_args .)
    LKEY            reduce using rule 29 (command -> operation call_args .)
    END             reduce using rule 29 (command -> operation call_args .)
    ELSIF           reduce using rule 29 (command -> operation call_args .)
    ELSE            reduce using rule 29 (command -> operation call_args .)
    ENSURE          reduce using rule 29 (command -> operation call_args .)
    LBRACKET        reduce using rule 29 (command -> operation call_args .)
    RBRACKET        reduce using rule 29 (command -> operation call_args .)


state 192

    (72) primary -> LPAREN compstmt . RPAREN

    RPAREN          shift and go to state 323


state 193

    (154) mlhs_item -> LPAREN mlhs . RPAREN
    (18) expr -> mlhs . = mrhs

    RPAREN          shift and go to state 324
    =               shift and go to state 152


state 194

    (16) stmt -> lhs . = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (153) mlhs_item -> lhs .
    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    =               shift and go to state 131
    COMMA           reduce using rule 153 (mlhs_item -> lhs .)
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 195

    (76) primary -> UNARY_OP IDENTIFIER .

    LBRACKET        reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    DOT             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    UNARY_OP        reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    OR_SYMBOL       reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    BINARY_XOR_OP   reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    BINARY_AND_OP   reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    COMBINED_COMPARISON_OP reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    GREATERTHAN     reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    GREATERTHANEQUAL reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    LESSERTHAN      reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    LESSERTHANEQUAL reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    EQUAL           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    CASE_EQUALITY   reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    NOTEQUAL        reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    MATCHED_STRINGS_OP reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    AND             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    OR              reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    PLUS            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    MINUS           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    TIMES           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    DIVIDE          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    MOD             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    POW             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    IF              reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    WHILE           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    UNLESS          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    UNTIL           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    TERM            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    $end            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    COMMA           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RBRACKET        reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    THEN            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    DO              reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RESCUE          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    HASH_ROCKET     reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RKEY            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RPAREN          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    WHEN            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    LKEY            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    END             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    ELSIF           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    ELSE            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    ENSURE          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    NOT_SYMBOL      reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    COMPLEMENT_OP   reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    DEFINED_OP      reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    NUMBER          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    LPAREN          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    RETURN          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    YIELD           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    CASE            reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    FOR             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    BEGIN           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    CLASS           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    MODULE          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    DEF             reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    VAR_GLOBAL      reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    VAR_LOCAL       reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    VAR_INSTANCE    reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    VAR_CLASS       reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    SYMBOL          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    STRING          reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    IDENTIFIER      reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)
    SUPER           reduce using rule 76 (primary -> UNARY_OP IDENTIFIER .)


state 196

    (38) function -> SUPER LPAREN . call_args RPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    TIMES           shift and go to state 287
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 284
    YIELD           shift and go to state 289
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NOT             shift and go to state 25
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    call_args                      shift and go to state 325
    compstmt                       shift and go to state 192
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 259
    command                        shift and go to state 288
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 290
    mlhs                           shift and go to state 22
    mlhs_item                      shift and go to state 43

state 197

    (32) command -> SUPER call_args .

    DO              reduce using rule 32 (command -> SUPER call_args .)
    TERM            reduce using rule 32 (command -> SUPER call_args .)
    AND             reduce using rule 32 (command -> SUPER call_args .)
    OR              reduce using rule 32 (command -> SUPER call_args .)
    IF              reduce using rule 32 (command -> SUPER call_args .)
    WHILE           reduce using rule 32 (command -> SUPER call_args .)
    UNLESS          reduce using rule 32 (command -> SUPER call_args .)
    UNTIL           reduce using rule 32 (command -> SUPER call_args .)
    $end            reduce using rule 32 (command -> SUPER call_args .)
    THEN            reduce using rule 32 (command -> SUPER call_args .)
    RESCUE          reduce using rule 32 (command -> SUPER call_args .)
    RPAREN          reduce using rule 32 (command -> SUPER call_args .)
    WHEN            reduce using rule 32 (command -> SUPER call_args .)
    RKEY            reduce using rule 32 (command -> SUPER call_args .)
    LKEY            reduce using rule 32 (command -> SUPER call_args .)
    END             reduce using rule 32 (command -> SUPER call_args .)
    ELSIF           reduce using rule 32 (command -> SUPER call_args .)
    ELSE            reduce using rule 32 (command -> SUPER call_args .)
    ENSURE          reduce using rule 32 (command -> SUPER call_args .)
    LBRACKET        reduce using rule 32 (command -> SUPER call_args .)
    RBRACKET        reduce using rule 32 (command -> SUPER call_args .)


state 198

    (93) primary -> DEFINED_OP LPAREN . arg LPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (27) call -> . function
    (28) call -> . command
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 328
    LKEY            shift and go to state 15
    RETURN          shift and go to state 284
    YIELD           shift and go to state 289
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 329
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    END             shift and go to state 7
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 31
    NOT             shift and go to state 25
    TIMES           shift and go to state 44

    arg                            shift and go to state 326
    compstmt                       shift and go to state 192
    lhs                            shift and go to state 327
    math_operations                shift and go to state 45
    primary                        shift and go to state 261
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 290
    call                           shift and go to state 5
    command                        shift and go to state 17
    operation                      shift and go to state 28
    mlhs                           shift and go to state 22
    mlhs_item                      shift and go to state 43

state 199

    (66) arg -> DEFINED_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 66 (arg -> DEFINED_OP arg .)
    WHILE           reduce using rule 66 (arg -> DEFINED_OP arg .)
    UNLESS          reduce using rule 66 (arg -> DEFINED_OP arg .)
    UNTIL           reduce using rule 66 (arg -> DEFINED_OP arg .)
    TERM            reduce using rule 66 (arg -> DEFINED_OP arg .)
    $end            reduce using rule 66 (arg -> DEFINED_OP arg .)
    COMMA           reduce using rule 66 (arg -> DEFINED_OP arg .)
    RBRACKET        reduce using rule 66 (arg -> DEFINED_OP arg .)
    THEN            reduce using rule 66 (arg -> DEFINED_OP arg .)
    DO              reduce using rule 66 (arg -> DEFINED_OP arg .)
    RESCUE          reduce using rule 66 (arg -> DEFINED_OP arg .)
    HASH_ROCKET     reduce using rule 66 (arg -> DEFINED_OP arg .)
    RKEY            reduce using rule 66 (arg -> DEFINED_OP arg .)
    RPAREN          reduce using rule 66 (arg -> DEFINED_OP arg .)
    WHEN            reduce using rule 66 (arg -> DEFINED_OP arg .)
    LKEY            reduce using rule 66 (arg -> DEFINED_OP arg .)
    END             reduce using rule 66 (arg -> DEFINED_OP arg .)
    ELSIF           reduce using rule 66 (arg -> DEFINED_OP arg .)
    ELSE            reduce using rule 66 (arg -> DEFINED_OP arg .)
    ENSURE          reduce using rule 66 (arg -> DEFINED_OP arg .)
    LBRACKET        reduce using rule 66 (arg -> DEFINED_OP arg .)
    NOT_SYMBOL      reduce using rule 66 (arg -> DEFINED_OP arg .)
    COMPLEMENT_OP   reduce using rule 66 (arg -> DEFINED_OP arg .)
    DEFINED_OP      reduce using rule 66 (arg -> DEFINED_OP arg .)
    NUMBER          reduce using rule 66 (arg -> DEFINED_OP arg .)
    LPAREN          reduce using rule 66 (arg -> DEFINED_OP arg .)
    UNARY_OP        reduce using rule 66 (arg -> DEFINED_OP arg .)
    RETURN          reduce using rule 66 (arg -> DEFINED_OP arg .)
    YIELD           reduce using rule 66 (arg -> DEFINED_OP arg .)
    CASE            reduce using rule 66 (arg -> DEFINED_OP arg .)
    FOR             reduce using rule 66 (arg -> DEFINED_OP arg .)
    BEGIN           reduce using rule 66 (arg -> DEFINED_OP arg .)
    CLASS           reduce using rule 66 (arg -> DEFINED_OP arg .)
    MODULE          reduce using rule 66 (arg -> DEFINED_OP arg .)
    DEF             reduce using rule 66 (arg -> DEFINED_OP arg .)
    VAR_GLOBAL      reduce using rule 66 (arg -> DEFINED_OP arg .)
    VAR_LOCAL       reduce using rule 66 (arg -> DEFINED_OP arg .)
    VAR_INSTANCE    reduce using rule 66 (arg -> DEFINED_OP arg .)
    VAR_CLASS       reduce using rule 66 (arg -> DEFINED_OP arg .)
    SYMBOL          reduce using rule 66 (arg -> DEFINED_OP arg .)
    STRING          reduce using rule 66 (arg -> DEFINED_OP arg .)
    IDENTIFIER      reduce using rule 66 (arg -> DEFINED_OP arg .)
    SUPER           reduce using rule 66 (arg -> DEFINED_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! EQUAL           [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! AND             [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! OR              [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! PLUS            [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! MINUS           [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! TIMES           [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! DIVIDE          [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! MOD             [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]
  ! POW             [ reduce using rule 66 (arg -> DEFINED_OP arg .) ]


state 200

    (105) primary -> CASE compstmt . when END
    (106) primary -> CASE compstmt . when ELSE compstmt END
    (120) when -> . WHEN when_args then compstmt
    (121) when -> . when WHEN when_args then compstmt

    WHEN            shift and go to state 331

    when                           shift and go to state 330

state 201

    (107) primary -> FOR block_var . IN expr do compstmt END

    IN              shift and go to state 332


state 202

    (145) block_var -> lhs .
    (153) mlhs_item -> lhs .

    IN              reduce using rule 145 (block_var -> lhs .)
    OR_SYMBOL       reduce using rule 145 (block_var -> lhs .)
    COMMA           reduce using rule 153 (mlhs_item -> lhs .)


state 203

    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation

    LBRACKET        shift and go to state 147
    DOT             shift and go to state 238
    UNARY_OP        shift and go to state 239


state 204

    (93) primary -> DEFINED_OP . LPAREN arg LPAREN

    LPAREN          shift and go to state 333


state 205

    (183) literal -> NUMBER .

    LBRACKET        reduce using rule 183 (literal -> NUMBER .)
    DOT             reduce using rule 183 (literal -> NUMBER .)
    UNARY_OP        reduce using rule 183 (literal -> NUMBER .)


state 206

    (112) primary -> CLASS IDENTIFIER . compstmt END
    (113) primary -> CLASS IDENTIFIER . LESSERTHAN IDENTIFIER compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LESSERTHAN      shift and go to state 335
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 334
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 207

    (114) primary -> MODULE IDENTIFIER . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 336
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 208

    (115) primary -> DEF fname . argdecl compstmt END
    (157) argdecl -> . LPAREN arglist RPAREN
    (158) argdecl -> . arglist term
    (159) arglist -> . IDENTIFIER
    (160) arglist -> . IDENTIFIER COMMA IDENTIFIER
    (161) arglist -> . IDENTIFIER COMMA & IDENTIFIER

    LPAREN          shift and go to state 338
    IDENTIFIER      shift and go to state 340

    argdecl                        shift and go to state 337
    arglist                        shift and go to state 339

state 209

    (116) primary -> DEF singleton . DOT fname argdecl compstmt END
    (117) primary -> DEF singleton . UNARY_OP fname argdecl compstmt END

    DOT             shift and go to state 341
    UNARY_OP        shift and go to state 342


state 210

    (162) singleton -> variable .

    DOT             reduce using rule 162 (singleton -> variable .)
    UNARY_OP        reduce using rule 162 (singleton -> variable .)


state 211

    (163) singleton -> LPAREN . expr RPAREN
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 343
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 212

    (147) mlhs -> mlhs_item COMMA . mlhs_item TIMES
    (148) mlhs -> mlhs_item COMMA . mlhs_item lhs
    (149) mlhs -> mlhs_item COMMA . mult_mlhs_item TIMES
    (150) mlhs -> mlhs_item COMMA . mult_mlhs_item lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (152) mult_mlhs_item -> . COMMA mlhs_item
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    LPAREN          shift and go to state 116
    COMMA           shift and go to state 345
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    mlhs_item                      shift and go to state 344
    lhs                            shift and go to state 346
    mult_mlhs_item                 shift and go to state 347
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 213

    (151) mlhs -> TIMES lhs .

    =               reduce using rule 151 (mlhs -> TIMES lhs .)
    RBRACKET        reduce using rule 151 (mlhs -> TIMES lhs .)
    RPAREN          reduce using rule 151 (mlhs -> TIMES lhs .)
    IN              reduce using rule 151 (mlhs -> TIMES lhs .)
    OR_SYMBOL       reduce using rule 151 (mlhs -> TIMES lhs .)


state 214

    (45) arg -> PLUS arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 45 (arg -> PLUS arg .)
    WHILE           reduce using rule 45 (arg -> PLUS arg .)
    UNLESS          reduce using rule 45 (arg -> PLUS arg .)
    UNTIL           reduce using rule 45 (arg -> PLUS arg .)
    TERM            reduce using rule 45 (arg -> PLUS arg .)
    $end            reduce using rule 45 (arg -> PLUS arg .)
    COMMA           reduce using rule 45 (arg -> PLUS arg .)
    RBRACKET        reduce using rule 45 (arg -> PLUS arg .)
    THEN            reduce using rule 45 (arg -> PLUS arg .)
    DO              reduce using rule 45 (arg -> PLUS arg .)
    RESCUE          reduce using rule 45 (arg -> PLUS arg .)
    HASH_ROCKET     reduce using rule 45 (arg -> PLUS arg .)
    RKEY            reduce using rule 45 (arg -> PLUS arg .)
    RPAREN          reduce using rule 45 (arg -> PLUS arg .)
    WHEN            reduce using rule 45 (arg -> PLUS arg .)
    LKEY            reduce using rule 45 (arg -> PLUS arg .)
    END             reduce using rule 45 (arg -> PLUS arg .)
    ELSIF           reduce using rule 45 (arg -> PLUS arg .)
    ELSE            reduce using rule 45 (arg -> PLUS arg .)
    ENSURE          reduce using rule 45 (arg -> PLUS arg .)
    LBRACKET        reduce using rule 45 (arg -> PLUS arg .)
    NOT_SYMBOL      reduce using rule 45 (arg -> PLUS arg .)
    COMPLEMENT_OP   reduce using rule 45 (arg -> PLUS arg .)
    DEFINED_OP      reduce using rule 45 (arg -> PLUS arg .)
    NUMBER          reduce using rule 45 (arg -> PLUS arg .)
    LPAREN          reduce using rule 45 (arg -> PLUS arg .)
    UNARY_OP        reduce using rule 45 (arg -> PLUS arg .)
    RETURN          reduce using rule 45 (arg -> PLUS arg .)
    YIELD           reduce using rule 45 (arg -> PLUS arg .)
    CASE            reduce using rule 45 (arg -> PLUS arg .)
    FOR             reduce using rule 45 (arg -> PLUS arg .)
    BEGIN           reduce using rule 45 (arg -> PLUS arg .)
    CLASS           reduce using rule 45 (arg -> PLUS arg .)
    MODULE          reduce using rule 45 (arg -> PLUS arg .)
    DEF             reduce using rule 45 (arg -> PLUS arg .)
    VAR_GLOBAL      reduce using rule 45 (arg -> PLUS arg .)
    VAR_LOCAL       reduce using rule 45 (arg -> PLUS arg .)
    VAR_INSTANCE    reduce using rule 45 (arg -> PLUS arg .)
    VAR_CLASS       reduce using rule 45 (arg -> PLUS arg .)
    SYMBOL          reduce using rule 45 (arg -> PLUS arg .)
    STRING          reduce using rule 45 (arg -> PLUS arg .)
    IDENTIFIER      reduce using rule 45 (arg -> PLUS arg .)
    SUPER           reduce using rule 45 (arg -> PLUS arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! OR_SYMBOL       [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! GREATERTHAN     [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! LESSERTHAN      [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! EQUAL           [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! NOTEQUAL        [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! AND             [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! OR              [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! PLUS            [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! MINUS           [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! TIMES           [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! DIVIDE          [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! MOD             [ reduce using rule 45 (arg -> PLUS arg .) ]
  ! POW             [ reduce using rule 45 (arg -> PLUS arg .) ]


state 215

    (46) arg -> MINUS arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 46 (arg -> MINUS arg .)
    WHILE           reduce using rule 46 (arg -> MINUS arg .)
    UNLESS          reduce using rule 46 (arg -> MINUS arg .)
    UNTIL           reduce using rule 46 (arg -> MINUS arg .)
    TERM            reduce using rule 46 (arg -> MINUS arg .)
    $end            reduce using rule 46 (arg -> MINUS arg .)
    COMMA           reduce using rule 46 (arg -> MINUS arg .)
    RBRACKET        reduce using rule 46 (arg -> MINUS arg .)
    THEN            reduce using rule 46 (arg -> MINUS arg .)
    DO              reduce using rule 46 (arg -> MINUS arg .)
    RESCUE          reduce using rule 46 (arg -> MINUS arg .)
    HASH_ROCKET     reduce using rule 46 (arg -> MINUS arg .)
    RKEY            reduce using rule 46 (arg -> MINUS arg .)
    RPAREN          reduce using rule 46 (arg -> MINUS arg .)
    WHEN            reduce using rule 46 (arg -> MINUS arg .)
    LKEY            reduce using rule 46 (arg -> MINUS arg .)
    END             reduce using rule 46 (arg -> MINUS arg .)
    ELSIF           reduce using rule 46 (arg -> MINUS arg .)
    ELSE            reduce using rule 46 (arg -> MINUS arg .)
    ENSURE          reduce using rule 46 (arg -> MINUS arg .)
    LBRACKET        reduce using rule 46 (arg -> MINUS arg .)
    NOT_SYMBOL      reduce using rule 46 (arg -> MINUS arg .)
    COMPLEMENT_OP   reduce using rule 46 (arg -> MINUS arg .)
    DEFINED_OP      reduce using rule 46 (arg -> MINUS arg .)
    NUMBER          reduce using rule 46 (arg -> MINUS arg .)
    LPAREN          reduce using rule 46 (arg -> MINUS arg .)
    UNARY_OP        reduce using rule 46 (arg -> MINUS arg .)
    RETURN          reduce using rule 46 (arg -> MINUS arg .)
    YIELD           reduce using rule 46 (arg -> MINUS arg .)
    CASE            reduce using rule 46 (arg -> MINUS arg .)
    FOR             reduce using rule 46 (arg -> MINUS arg .)
    BEGIN           reduce using rule 46 (arg -> MINUS arg .)
    CLASS           reduce using rule 46 (arg -> MINUS arg .)
    MODULE          reduce using rule 46 (arg -> MINUS arg .)
    DEF             reduce using rule 46 (arg -> MINUS arg .)
    VAR_GLOBAL      reduce using rule 46 (arg -> MINUS arg .)
    VAR_LOCAL       reduce using rule 46 (arg -> MINUS arg .)
    VAR_INSTANCE    reduce using rule 46 (arg -> MINUS arg .)
    VAR_CLASS       reduce using rule 46 (arg -> MINUS arg .)
    SYMBOL          reduce using rule 46 (arg -> MINUS arg .)
    STRING          reduce using rule 46 (arg -> MINUS arg .)
    IDENTIFIER      reduce using rule 46 (arg -> MINUS arg .)
    SUPER           reduce using rule 46 (arg -> MINUS arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! OR_SYMBOL       [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! GREATERTHAN     [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! LESSERTHAN      [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! EQUAL           [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! NOTEQUAL        [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! AND             [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! OR              [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! PLUS            [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! MINUS           [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! TIMES           [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! DIVIDE          [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! MOD             [ reduce using rule 46 (arg -> MINUS arg .) ]
  ! POW             [ reduce using rule 46 (arg -> MINUS arg .) ]


state 216

    (61) arg -> COMPLEMENT_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    WHILE           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    UNLESS          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    UNTIL           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    TERM            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    $end            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    COMMA           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    RBRACKET        reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    THEN            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    DO              reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    RESCUE          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    HASH_ROCKET     reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    RKEY            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    RPAREN          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    WHEN            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    LKEY            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    END             reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    ELSIF           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    ELSE            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    ENSURE          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    LBRACKET        reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    NOT_SYMBOL      reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    COMPLEMENT_OP   reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    DEFINED_OP      reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    NUMBER          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    LPAREN          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    UNARY_OP        reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    RETURN          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    YIELD           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    CASE            reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    FOR             reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    BEGIN           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    CLASS           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    MODULE          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    DEF             reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    VAR_GLOBAL      reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    VAR_LOCAL       reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    VAR_INSTANCE    reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    VAR_CLASS       reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    SYMBOL          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    STRING          reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    IDENTIFIER      reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    SUPER           reduce using rule 61 (arg -> COMPLEMENT_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! EQUAL           [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! AND             [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! OR              [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! PLUS            [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! MINUS           [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! TIMES           [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! DIVIDE          [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! MOD             [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]
  ! POW             [ reduce using rule 61 (arg -> COMPLEMENT_OP arg .) ]


state 217

    (235) math_operations -> NUMBER PLUS . NUMBER

    NUMBER          shift and go to state 348


state 218

    (236) math_operations -> NUMBER MINUS . NUMBER

    NUMBER          shift and go to state 349


state 219

    (237) math_operations -> NUMBER TIMES . NUMBER

    NUMBER          shift and go to state 350


state 220

    (238) math_operations -> NUMBER DIVIDE . NUMBER

    NUMBER          shift and go to state 351


state 221

    (239) math_operations -> NUMBER MOD . NUMBER

    NUMBER          shift and go to state 352


state 222

    (240) math_operations -> NUMBER POW . NUMBER

    NUMBER          shift and go to state 353


state 223

    (4) compstmt -> stmt term expr . term
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (135) term -> . TERM

    AND             shift and go to state 58
    OR              shift and go to state 59
    TERM            shift and go to state 57

    term                           shift and go to state 354

state 224

    (10) stmt -> stmt IF expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

    IF              reduce using rule 10 (stmt -> stmt IF expr .)
    WHILE           reduce using rule 10 (stmt -> stmt IF expr .)
    UNLESS          reduce using rule 10 (stmt -> stmt IF expr .)
    UNTIL           reduce using rule 10 (stmt -> stmt IF expr .)
    TERM            reduce using rule 10 (stmt -> stmt IF expr .)
    $end            reduce using rule 10 (stmt -> stmt IF expr .)
    RESCUE          reduce using rule 10 (stmt -> stmt IF expr .)
    RPAREN          reduce using rule 10 (stmt -> stmt IF expr .)
    WHEN            reduce using rule 10 (stmt -> stmt IF expr .)
    RKEY            reduce using rule 10 (stmt -> stmt IF expr .)
    LKEY            reduce using rule 10 (stmt -> stmt IF expr .)
    END             reduce using rule 10 (stmt -> stmt IF expr .)
    ELSIF           reduce using rule 10 (stmt -> stmt IF expr .)
    ELSE            reduce using rule 10 (stmt -> stmt IF expr .)
    ENSURE          reduce using rule 10 (stmt -> stmt IF expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59


state 225

    (11) stmt -> stmt WHILE expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

    IF              reduce using rule 11 (stmt -> stmt WHILE expr .)
    WHILE           reduce using rule 11 (stmt -> stmt WHILE expr .)
    UNLESS          reduce using rule 11 (stmt -> stmt WHILE expr .)
    UNTIL           reduce using rule 11 (stmt -> stmt WHILE expr .)
    TERM            reduce using rule 11 (stmt -> stmt WHILE expr .)
    $end            reduce using rule 11 (stmt -> stmt WHILE expr .)
    RESCUE          reduce using rule 11 (stmt -> stmt WHILE expr .)
    RPAREN          reduce using rule 11 (stmt -> stmt WHILE expr .)
    WHEN            reduce using rule 11 (stmt -> stmt WHILE expr .)
    RKEY            reduce using rule 11 (stmt -> stmt WHILE expr .)
    LKEY            reduce using rule 11 (stmt -> stmt WHILE expr .)
    END             reduce using rule 11 (stmt -> stmt WHILE expr .)
    ELSIF           reduce using rule 11 (stmt -> stmt WHILE expr .)
    ELSE            reduce using rule 11 (stmt -> stmt WHILE expr .)
    ENSURE          reduce using rule 11 (stmt -> stmt WHILE expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59


state 226

    (12) stmt -> stmt UNLESS expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

    IF              reduce using rule 12 (stmt -> stmt UNLESS expr .)
    WHILE           reduce using rule 12 (stmt -> stmt UNLESS expr .)
    UNLESS          reduce using rule 12 (stmt -> stmt UNLESS expr .)
    UNTIL           reduce using rule 12 (stmt -> stmt UNLESS expr .)
    TERM            reduce using rule 12 (stmt -> stmt UNLESS expr .)
    $end            reduce using rule 12 (stmt -> stmt UNLESS expr .)
    RESCUE          reduce using rule 12 (stmt -> stmt UNLESS expr .)
    RPAREN          reduce using rule 12 (stmt -> stmt UNLESS expr .)
    WHEN            reduce using rule 12 (stmt -> stmt UNLESS expr .)
    RKEY            reduce using rule 12 (stmt -> stmt UNLESS expr .)
    LKEY            reduce using rule 12 (stmt -> stmt UNLESS expr .)
    END             reduce using rule 12 (stmt -> stmt UNLESS expr .)
    ELSIF           reduce using rule 12 (stmt -> stmt UNLESS expr .)
    ELSE            reduce using rule 12 (stmt -> stmt UNLESS expr .)
    ENSURE          reduce using rule 12 (stmt -> stmt UNLESS expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59


state 227

    (13) stmt -> stmt UNTIL expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

    IF              reduce using rule 13 (stmt -> stmt UNTIL expr .)
    WHILE           reduce using rule 13 (stmt -> stmt UNTIL expr .)
    UNLESS          reduce using rule 13 (stmt -> stmt UNTIL expr .)
    UNTIL           reduce using rule 13 (stmt -> stmt UNTIL expr .)
    TERM            reduce using rule 13 (stmt -> stmt UNTIL expr .)
    $end            reduce using rule 13 (stmt -> stmt UNTIL expr .)
    RESCUE          reduce using rule 13 (stmt -> stmt UNTIL expr .)
    RPAREN          reduce using rule 13 (stmt -> stmt UNTIL expr .)
    WHEN            reduce using rule 13 (stmt -> stmt UNTIL expr .)
    RKEY            reduce using rule 13 (stmt -> stmt UNTIL expr .)
    LKEY            reduce using rule 13 (stmt -> stmt UNTIL expr .)
    END             reduce using rule 13 (stmt -> stmt UNTIL expr .)
    ELSIF           reduce using rule 13 (stmt -> stmt UNTIL expr .)
    ELSE            reduce using rule 13 (stmt -> stmt UNTIL expr .)
    ENSURE          reduce using rule 13 (stmt -> stmt UNTIL expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59


state 228

    (21) expr -> expr AND expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 21 (expr -> expr AND expr .)
    WHILE           reduce using rule 21 (expr -> expr AND expr .)
    UNLESS          reduce using rule 21 (expr -> expr AND expr .)
    UNTIL           reduce using rule 21 (expr -> expr AND expr .)
    TERM            reduce using rule 21 (expr -> expr AND expr .)
    $end            reduce using rule 21 (expr -> expr AND expr .)
    THEN            reduce using rule 21 (expr -> expr AND expr .)
    DO              reduce using rule 21 (expr -> expr AND expr .)
    RESCUE          reduce using rule 21 (expr -> expr AND expr .)
    RPAREN          reduce using rule 21 (expr -> expr AND expr .)
    WHEN            reduce using rule 21 (expr -> expr AND expr .)
    RKEY            reduce using rule 21 (expr -> expr AND expr .)
    LKEY            reduce using rule 21 (expr -> expr AND expr .)
    END             reduce using rule 21 (expr -> expr AND expr .)
    ELSIF           reduce using rule 21 (expr -> expr AND expr .)
    ELSE            reduce using rule 21 (expr -> expr AND expr .)
    ENSURE          reduce using rule 21 (expr -> expr AND expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59

  ! AND             [ reduce using rule 21 (expr -> expr AND expr .) ]
  ! OR              [ reduce using rule 21 (expr -> expr AND expr .) ]


state 229

    (22) expr -> expr OR expr .
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 22 (expr -> expr OR expr .)
    WHILE           reduce using rule 22 (expr -> expr OR expr .)
    UNLESS          reduce using rule 22 (expr -> expr OR expr .)
    UNTIL           reduce using rule 22 (expr -> expr OR expr .)
    TERM            reduce using rule 22 (expr -> expr OR expr .)
    $end            reduce using rule 22 (expr -> expr OR expr .)
    THEN            reduce using rule 22 (expr -> expr OR expr .)
    DO              reduce using rule 22 (expr -> expr OR expr .)
    RESCUE          reduce using rule 22 (expr -> expr OR expr .)
    RPAREN          reduce using rule 22 (expr -> expr OR expr .)
    WHEN            reduce using rule 22 (expr -> expr OR expr .)
    RKEY            reduce using rule 22 (expr -> expr OR expr .)
    LKEY            reduce using rule 22 (expr -> expr OR expr .)
    END             reduce using rule 22 (expr -> expr OR expr .)
    ELSIF           reduce using rule 22 (expr -> expr OR expr .)
    ELSE            reduce using rule 22 (expr -> expr OR expr .)
    ENSURE          reduce using rule 22 (expr -> expr OR expr .)
    AND             shift and go to state 58
    OR              shift and go to state 59

  ! AND             [ reduce using rule 22 (expr -> expr OR expr .) ]
  ! OR              [ reduce using rule 22 (expr -> expr OR expr .) ]


state 230

    (5) stmt -> call do LBRACKET . RBRACKET

    RBRACKET        shift and go to state 355


state 231

    (134) do -> term DO .

    LBRACKET        reduce using rule 134 (do -> term DO .)
    UNDEF           reduce using rule 134 (do -> term DO .)
    ALIAS           reduce using rule 134 (do -> term DO .)
    BEGIN           reduce using rule 134 (do -> term DO .)
    END             reduce using rule 134 (do -> term DO .)
    RETURN          reduce using rule 134 (do -> term DO .)
    YIELD           reduce using rule 134 (do -> term DO .)
    NOT             reduce using rule 134 (do -> term DO .)
    NOT_SYMBOL      reduce using rule 134 (do -> term DO .)
    SUPER           reduce using rule 134 (do -> term DO .)
    VAR_GLOBAL      reduce using rule 134 (do -> term DO .)
    VAR_LOCAL       reduce using rule 134 (do -> term DO .)
    VAR_INSTANCE    reduce using rule 134 (do -> term DO .)
    VAR_CLASS       reduce using rule 134 (do -> term DO .)
    LPAREN          reduce using rule 134 (do -> term DO .)
    UNARY_OP        reduce using rule 134 (do -> term DO .)
    LKEY            reduce using rule 134 (do -> term DO .)
    DEFINED_OP      reduce using rule 134 (do -> term DO .)
    IF              reduce using rule 134 (do -> term DO .)
    UNLESS          reduce using rule 134 (do -> term DO .)
    WHILE           reduce using rule 134 (do -> term DO .)
    UNTIL           reduce using rule 134 (do -> term DO .)
    CASE            reduce using rule 134 (do -> term DO .)
    FOR             reduce using rule 134 (do -> term DO .)
    CLASS           reduce using rule 134 (do -> term DO .)
    MODULE          reduce using rule 134 (do -> term DO .)
    DEF             reduce using rule 134 (do -> term DO .)
    TIMES           reduce using rule 134 (do -> term DO .)
    PLUS            reduce using rule 134 (do -> term DO .)
    MINUS           reduce using rule 134 (do -> term DO .)
    COMPLEMENT_OP   reduce using rule 134 (do -> term DO .)
    IDENTIFIER      reduce using rule 134 (do -> term DO .)
    NUMBER          reduce using rule 134 (do -> term DO .)
    SYMBOL          reduce using rule 134 (do -> term DO .)
    STRING          reduce using rule 134 (do -> term DO .)


state 232

    (6) stmt -> LBRACKET block_var RBRACKET .

    IF              reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    WHILE           reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    UNLESS          reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    UNTIL           reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    TERM            reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    $end            reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    RESCUE          reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    RPAREN          reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    WHEN            reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    RKEY            reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    LKEY            reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    END             reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    ELSIF           reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    ELSE            reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)
    ENSURE          reduce using rule 6 (stmt -> LBRACKET block_var RBRACKET .)


state 233

    (7) stmt -> LBRACKET OR_SYMBOL block_var . OR_SYMBOL RBRACKET compstmt END

    OR_SYMBOL       shift and go to state 356


state 234

    (80) primary -> LBRACKET args RBRACKET .

    LBRACKET        reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    DOT             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    UNARY_OP        reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    OR_SYMBOL       reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    BINARY_XOR_OP   reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    BINARY_AND_OP   reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    GREATERTHAN     reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    GREATERTHANEQUAL reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    LESSERTHAN      reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    LESSERTHANEQUAL reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    EQUAL           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    CASE_EQUALITY   reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    NOTEQUAL        reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    AND             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    OR              reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    PLUS            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    MINUS           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    TIMES           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    DIVIDE          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    MOD             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    POW             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    IF              reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    WHILE           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    UNLESS          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    UNTIL           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    TERM            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    $end            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    COMMA           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RBRACKET        reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    THEN            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    DO              reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RESCUE          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    HASH_ROCKET     reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RKEY            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RPAREN          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    WHEN            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    LKEY            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    END             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    ELSIF           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    ELSE            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    ENSURE          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    NOT_SYMBOL      reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    COMPLEMENT_OP   reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    DEFINED_OP      reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    NUMBER          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    LPAREN          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    RETURN          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    YIELD           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    CASE            reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    FOR             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    BEGIN           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    CLASS           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    MODULE          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    DEF             reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    VAR_GLOBAL      reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    VAR_LOCAL       reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    VAR_INSTANCE    reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    VAR_CLASS       reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    SYMBOL          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    STRING          reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    IDENTIFIER      reduce using rule 80 (primary -> LBRACKET args RBRACKET .)
    SUPER           reduce using rule 80 (primary -> LBRACKET args RBRACKET .)


state 235

    (81) primary -> LBRACKET args COMMA . RBRACKET

    RBRACKET        shift and go to state 357


state 236

    (40) arg -> lhs = . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    lhs                            shift and go to state 128
    arg                            shift and go to state 271
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 237

    (156) args -> arg COMMA . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 358
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 238

    (144) lhs -> primary DOT . IDENTIFIER
    (34) function -> primary DOT . operation LPAREN call_args RPAREN
    (36) function -> primary DOT . operation
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 277

    operation                      shift and go to state 359

state 239

    (75) primary -> primary UNARY_OP . IDENTIFIER
    (35) function -> primary UNARY_OP . operation LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP . operation
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 280

    operation                      shift and go to state 360

state 240

    (88) primary -> RETURN LPAREN . RPAREN
    (89) primary -> RETURN LPAREN . call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RPAREN          shift and go to state 285
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    call_args                      shift and go to state 286
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 241

    (91) primary -> YIELD LPAREN . RPAREN
    (92) primary -> YIELD LPAREN . call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RPAREN          shift and go to state 295
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    call_args                      shift and go to state 296
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 242

    (33) function -> operation LBRACKET . LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET

    LPAREN          shift and go to state 361


state 243

    (38) function -> SUPER LPAREN . call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    call_args                      shift and go to state 325
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 244

    (15) stmt -> END LKEY compstmt . RKEY

    RKEY            shift and go to state 362


state 245

    (211) fname -> LBRACKET RBRACKET .
    (212) fname -> LBRACKET RBRACKET . EQUAL_SYMBOL

    IF              reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    WHILE           reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    UNLESS          reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    UNTIL           reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    TERM            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    $end            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    RESCUE          reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    RPAREN          reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    WHEN            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    RKEY            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    LKEY            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    END             reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    ELSIF           reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    ELSE            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    ENSURE          reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    OR_SYMBOL       reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    BINARY_AND_OP   reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    BINARY_XOR_OP   reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    EQUAL           reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    CASE_EQUALITY   reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    GREATERTHAN     reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    GREATERTHANEQUAL reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    LESSERTHAN      reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    LESSERTHANEQUAL reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    PLUS            reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    MINUS           reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    TIMES           reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    MOD             reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    POW             reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    COMPLEMENT_OP   reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    OVERLOAD_PLUS   reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    OVERLOAD_MINUS  reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    LPAREN          reduce using rule 211 (fname -> LBRACKET RBRACKET .)
    EQUAL_SYMBOL    shift and go to state 363


state 246

    (9) stmt -> ALIAS fname fname .

    IF              reduce using rule 9 (stmt -> ALIAS fname fname .)
    WHILE           reduce using rule 9 (stmt -> ALIAS fname fname .)
    UNLESS          reduce using rule 9 (stmt -> ALIAS fname fname .)
    UNTIL           reduce using rule 9 (stmt -> ALIAS fname fname .)
    TERM            reduce using rule 9 (stmt -> ALIAS fname fname .)
    $end            reduce using rule 9 (stmt -> ALIAS fname fname .)
    RESCUE          reduce using rule 9 (stmt -> ALIAS fname fname .)
    RPAREN          reduce using rule 9 (stmt -> ALIAS fname fname .)
    WHEN            reduce using rule 9 (stmt -> ALIAS fname fname .)
    RKEY            reduce using rule 9 (stmt -> ALIAS fname fname .)
    LKEY            reduce using rule 9 (stmt -> ALIAS fname fname .)
    END             reduce using rule 9 (stmt -> ALIAS fname fname .)
    ELSIF           reduce using rule 9 (stmt -> ALIAS fname fname .)
    ELSE            reduce using rule 9 (stmt -> ALIAS fname fname .)
    ENSURE          reduce using rule 9 (stmt -> ALIAS fname fname .)


state 247

    (98) primary -> IF expr then . compstmt END
    (99) primary -> IF expr then . compstmt elsif END
    (100) primary -> IF expr then . compstmt elsif ELSE compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 364
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 248

    (129) then -> TERM .
    (131) then -> TERM . THEN

    LBRACKET        reduce using rule 129 (then -> TERM .)
    UNDEF           reduce using rule 129 (then -> TERM .)
    ALIAS           reduce using rule 129 (then -> TERM .)
    BEGIN           reduce using rule 129 (then -> TERM .)
    END             reduce using rule 129 (then -> TERM .)
    RETURN          reduce using rule 129 (then -> TERM .)
    YIELD           reduce using rule 129 (then -> TERM .)
    NOT             reduce using rule 129 (then -> TERM .)
    NOT_SYMBOL      reduce using rule 129 (then -> TERM .)
    SUPER           reduce using rule 129 (then -> TERM .)
    VAR_GLOBAL      reduce using rule 129 (then -> TERM .)
    VAR_LOCAL       reduce using rule 129 (then -> TERM .)
    VAR_INSTANCE    reduce using rule 129 (then -> TERM .)
    VAR_CLASS       reduce using rule 129 (then -> TERM .)
    LPAREN          reduce using rule 129 (then -> TERM .)
    UNARY_OP        reduce using rule 129 (then -> TERM .)
    LKEY            reduce using rule 129 (then -> TERM .)
    DEFINED_OP      reduce using rule 129 (then -> TERM .)
    IF              reduce using rule 129 (then -> TERM .)
    UNLESS          reduce using rule 129 (then -> TERM .)
    WHILE           reduce using rule 129 (then -> TERM .)
    UNTIL           reduce using rule 129 (then -> TERM .)
    CASE            reduce using rule 129 (then -> TERM .)
    FOR             reduce using rule 129 (then -> TERM .)
    CLASS           reduce using rule 129 (then -> TERM .)
    MODULE          reduce using rule 129 (then -> TERM .)
    DEF             reduce using rule 129 (then -> TERM .)
    TIMES           reduce using rule 129 (then -> TERM .)
    PLUS            reduce using rule 129 (then -> TERM .)
    MINUS           reduce using rule 129 (then -> TERM .)
    COMPLEMENT_OP   reduce using rule 129 (then -> TERM .)
    IDENTIFIER      reduce using rule 129 (then -> TERM .)
    NUMBER          reduce using rule 129 (then -> TERM .)
    SYMBOL          reduce using rule 129 (then -> TERM .)
    STRING          reduce using rule 129 (then -> TERM .)
    THEN            shift and go to state 365


state 249

    (130) then -> THEN .

    LBRACKET        reduce using rule 130 (then -> THEN .)
    UNDEF           reduce using rule 130 (then -> THEN .)
    ALIAS           reduce using rule 130 (then -> THEN .)
    BEGIN           reduce using rule 130 (then -> THEN .)
    END             reduce using rule 130 (then -> THEN .)
    RETURN          reduce using rule 130 (then -> THEN .)
    YIELD           reduce using rule 130 (then -> THEN .)
    NOT             reduce using rule 130 (then -> THEN .)
    NOT_SYMBOL      reduce using rule 130 (then -> THEN .)
    SUPER           reduce using rule 130 (then -> THEN .)
    VAR_GLOBAL      reduce using rule 130 (then -> THEN .)
    VAR_LOCAL       reduce using rule 130 (then -> THEN .)
    VAR_INSTANCE    reduce using rule 130 (then -> THEN .)
    VAR_CLASS       reduce using rule 130 (then -> THEN .)
    LPAREN          reduce using rule 130 (then -> THEN .)
    UNARY_OP        reduce using rule 130 (then -> THEN .)
    LKEY            reduce using rule 130 (then -> THEN .)
    DEFINED_OP      reduce using rule 130 (then -> THEN .)
    IF              reduce using rule 130 (then -> THEN .)
    UNLESS          reduce using rule 130 (then -> THEN .)
    WHILE           reduce using rule 130 (then -> THEN .)
    UNTIL           reduce using rule 130 (then -> THEN .)
    CASE            reduce using rule 130 (then -> THEN .)
    FOR             reduce using rule 130 (then -> THEN .)
    CLASS           reduce using rule 130 (then -> THEN .)
    MODULE          reduce using rule 130 (then -> THEN .)
    DEF             reduce using rule 130 (then -> THEN .)
    TIMES           reduce using rule 130 (then -> THEN .)
    PLUS            reduce using rule 130 (then -> THEN .)
    MINUS           reduce using rule 130 (then -> THEN .)
    COMPLEMENT_OP   reduce using rule 130 (then -> THEN .)
    IDENTIFIER      reduce using rule 130 (then -> THEN .)
    NUMBER          reduce using rule 130 (then -> THEN .)
    SYMBOL          reduce using rule 130 (then -> THEN .)
    STRING          reduce using rule 130 (then -> THEN .)


state 250

    (30) command -> primary DOT . operation call_args
    (144) lhs -> primary DOT . IDENTIFIER
    (34) function -> primary DOT . operation LPAREN call_args RPAREN
    (36) function -> primary DOT . operation
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 277

    operation                      shift and go to state 366

state 251

    (31) command -> primary UNARY_OP . operation call_args
    (75) primary -> primary UNARY_OP . IDENTIFIER
    (35) function -> primary UNARY_OP . operation LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP . operation
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 280

    operation                      shift and go to state 367

state 252

    (77) primary -> primary LBRACKET . RBRACKET
    (78) primary -> primary LBRACKET . args RBRACKET
    (142) lhs -> primary LBRACKET . RBRACKET
    (143) lhs -> primary LBRACKET . args RBRACKET
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    RBRACKET        shift and go to state 368
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    primary                        shift and go to state 129
    args                           shift and go to state 369
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 253

    (153) mlhs_item -> lhs .
    (16) stmt -> lhs . = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    COMMA           reduce using rule 153 (mlhs_item -> lhs .)
    =               shift and go to state 131
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 254

    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation
    (30) command -> primary . DOT operation call_args
    (31) command -> primary . UNARY_OP operation call_args
    (67) arg -> primary .

    LBRACKET        shift and go to state 147
    DOT             shift and go to state 148
    UNARY_OP        shift and go to state 370
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    IF              reduce using rule 67 (arg -> primary .)
    WHILE           reduce using rule 67 (arg -> primary .)
    UNLESS          reduce using rule 67 (arg -> primary .)
    UNTIL           reduce using rule 67 (arg -> primary .)
    TERM            reduce using rule 67 (arg -> primary .)
    RPAREN          reduce using rule 67 (arg -> primary .)


state 255

    (103) primary -> WHILE expr do . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 371
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 256

    (101) primary -> UNLESS expr then . compstmt END
    (102) primary -> UNLESS expr then . compstmt ELSE compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 372
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 257

    (104) primary -> UNTIL expr do . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 373
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 258

    (14) stmt -> BEGIN LKEY compstmt . RKEY

    RKEY            shift and go to state 374


state 259

    (155) args -> arg .
    (156) args -> arg . COMMA arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (166) assoc -> arg . HASH_ROCKET arg
    (26) expr -> arg .
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for COMMA resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! reduce/reduce conflict for RKEY resolved using rule 26 (expr -> arg .)
  ! reduce/reduce conflict for RPAREN resolved using rule 26 (expr -> arg .)
    COMMA           shift and go to state 237
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    HASH_ROCKET     shift and go to state 268
    IF              reduce using rule 26 (expr -> arg .)
    WHILE           reduce using rule 26 (expr -> arg .)
    UNLESS          reduce using rule 26 (expr -> arg .)
    UNTIL           reduce using rule 26 (expr -> arg .)
    TERM            reduce using rule 26 (expr -> arg .)
    RKEY            reduce using rule 26 (expr -> arg .)
    RPAREN          reduce using rule 26 (expr -> arg .)
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RKEY            [ reduce using rule 155 (args -> arg .) ]
  ! COMMA           [ reduce using rule 155 (args -> arg .) ]
  ! RPAREN          [ reduce using rule 155 (args -> arg .) ]
  ! AND             [ reduce using rule 26 (expr -> arg .) ]
  ! OR              [ reduce using rule 26 (expr -> arg .) ]


state 260

    (60) arg -> NOT_SYMBOL . arg
    (25) expr -> NOT_SYMBOL . command
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    SUPER           shift and go to state 115
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    IDENTIFIER      shift and go to state 21
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    arg                            shift and go to state 164
    command                        shift and go to state 163
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 375
    operation                      shift and go to state 113
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77

state 261

    (67) arg -> primary .
    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation
    (30) command -> primary . DOT operation call_args
    (31) command -> primary . UNARY_OP operation call_args

    COMMA           reduce using rule 67 (arg -> primary .)
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    HASH_ROCKET     reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    RKEY            reduce using rule 67 (arg -> primary .)
    IF              reduce using rule 67 (arg -> primary .)
    WHILE           reduce using rule 67 (arg -> primary .)
    UNLESS          reduce using rule 67 (arg -> primary .)
    UNTIL           reduce using rule 67 (arg -> primary .)
    TERM            reduce using rule 67 (arg -> primary .)
    LPAREN          reduce using rule 67 (arg -> primary .)
    RPAREN          reduce using rule 67 (arg -> primary .)
    LBRACKET        shift and go to state 147
    DOT             shift and go to state 148
    UNARY_OP        shift and go to state 370


state 262

    (108) primary -> BEGIN compstmt rescue . END
    (109) primary -> BEGIN compstmt rescue . ELSE compstmt END
    (110) primary -> BEGIN compstmt rescue . ENSURE compstmt END
    (111) primary -> BEGIN compstmt rescue . ELSE compstmt ENSURE compstmt END
    (124) rescue -> rescue . RESCUE args do compstmt
    (125) rescue -> rescue . RESCUE do compstmt

    END             shift and go to state 376
    ELSE            shift and go to state 377
    ENSURE          shift and go to state 378
    RESCUE          shift and go to state 379


state 263

    (122) rescue -> RESCUE . args do compstmt
    (123) rescue -> RESCUE . do compstmt
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (135) term -> . TERM
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    DO              shift and go to state 62
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    TERM            shift and go to state 57
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    args                           shift and go to state 380
    do                             shift and go to state 381
    arg                            shift and go to state 70
    term                           shift and go to state 61
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 264

    (83) primary -> LKEY args RKEY .

    LBRACKET        reduce using rule 83 (primary -> LKEY args RKEY .)
    DOT             reduce using rule 83 (primary -> LKEY args RKEY .)
    UNARY_OP        reduce using rule 83 (primary -> LKEY args RKEY .)
    RANGE_INCLUSIVE reduce using rule 83 (primary -> LKEY args RKEY .)
    RANGE_EXCLUSIVE reduce using rule 83 (primary -> LKEY args RKEY .)
    OR_SYMBOL       reduce using rule 83 (primary -> LKEY args RKEY .)
    BINARY_XOR_OP   reduce using rule 83 (primary -> LKEY args RKEY .)
    BINARY_AND_OP   reduce using rule 83 (primary -> LKEY args RKEY .)
    COMBINED_COMPARISON_OP reduce using rule 83 (primary -> LKEY args RKEY .)
    GREATERTHAN     reduce using rule 83 (primary -> LKEY args RKEY .)
    GREATERTHANEQUAL reduce using rule 83 (primary -> LKEY args RKEY .)
    LESSERTHAN      reduce using rule 83 (primary -> LKEY args RKEY .)
    LESSERTHANEQUAL reduce using rule 83 (primary -> LKEY args RKEY .)
    EQUAL           reduce using rule 83 (primary -> LKEY args RKEY .)
    CASE_EQUALITY   reduce using rule 83 (primary -> LKEY args RKEY .)
    NOTEQUAL        reduce using rule 83 (primary -> LKEY args RKEY .)
    MATCHED_STRINGS_OP reduce using rule 83 (primary -> LKEY args RKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 83 (primary -> LKEY args RKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 83 (primary -> LKEY args RKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 83 (primary -> LKEY args RKEY .)
    AND             reduce using rule 83 (primary -> LKEY args RKEY .)
    OR              reduce using rule 83 (primary -> LKEY args RKEY .)
    PLUS            reduce using rule 83 (primary -> LKEY args RKEY .)
    MINUS           reduce using rule 83 (primary -> LKEY args RKEY .)
    TIMES           reduce using rule 83 (primary -> LKEY args RKEY .)
    DIVIDE          reduce using rule 83 (primary -> LKEY args RKEY .)
    MOD             reduce using rule 83 (primary -> LKEY args RKEY .)
    POW             reduce using rule 83 (primary -> LKEY args RKEY .)
    IF              reduce using rule 83 (primary -> LKEY args RKEY .)
    WHILE           reduce using rule 83 (primary -> LKEY args RKEY .)
    UNLESS          reduce using rule 83 (primary -> LKEY args RKEY .)
    UNTIL           reduce using rule 83 (primary -> LKEY args RKEY .)
    TERM            reduce using rule 83 (primary -> LKEY args RKEY .)
    $end            reduce using rule 83 (primary -> LKEY args RKEY .)
    COMMA           reduce using rule 83 (primary -> LKEY args RKEY .)
    RBRACKET        reduce using rule 83 (primary -> LKEY args RKEY .)
    THEN            reduce using rule 83 (primary -> LKEY args RKEY .)
    DO              reduce using rule 83 (primary -> LKEY args RKEY .)
    RESCUE          reduce using rule 83 (primary -> LKEY args RKEY .)
    HASH_ROCKET     reduce using rule 83 (primary -> LKEY args RKEY .)
    RKEY            reduce using rule 83 (primary -> LKEY args RKEY .)
    RPAREN          reduce using rule 83 (primary -> LKEY args RKEY .)
    WHEN            reduce using rule 83 (primary -> LKEY args RKEY .)
    LKEY            reduce using rule 83 (primary -> LKEY args RKEY .)
    END             reduce using rule 83 (primary -> LKEY args RKEY .)
    ELSIF           reduce using rule 83 (primary -> LKEY args RKEY .)
    ELSE            reduce using rule 83 (primary -> LKEY args RKEY .)
    ENSURE          reduce using rule 83 (primary -> LKEY args RKEY .)
    NOT_SYMBOL      reduce using rule 83 (primary -> LKEY args RKEY .)
    COMPLEMENT_OP   reduce using rule 83 (primary -> LKEY args RKEY .)
    DEFINED_OP      reduce using rule 83 (primary -> LKEY args RKEY .)
    NUMBER          reduce using rule 83 (primary -> LKEY args RKEY .)
    LPAREN          reduce using rule 83 (primary -> LKEY args RKEY .)
    RETURN          reduce using rule 83 (primary -> LKEY args RKEY .)
    YIELD           reduce using rule 83 (primary -> LKEY args RKEY .)
    CASE            reduce using rule 83 (primary -> LKEY args RKEY .)
    FOR             reduce using rule 83 (primary -> LKEY args RKEY .)
    BEGIN           reduce using rule 83 (primary -> LKEY args RKEY .)
    CLASS           reduce using rule 83 (primary -> LKEY args RKEY .)
    MODULE          reduce using rule 83 (primary -> LKEY args RKEY .)
    DEF             reduce using rule 83 (primary -> LKEY args RKEY .)
    VAR_GLOBAL      reduce using rule 83 (primary -> LKEY args RKEY .)
    VAR_LOCAL       reduce using rule 83 (primary -> LKEY args RKEY .)
    VAR_INSTANCE    reduce using rule 83 (primary -> LKEY args RKEY .)
    VAR_CLASS       reduce using rule 83 (primary -> LKEY args RKEY .)
    SYMBOL          reduce using rule 83 (primary -> LKEY args RKEY .)
    STRING          reduce using rule 83 (primary -> LKEY args RKEY .)
    IDENTIFIER      reduce using rule 83 (primary -> LKEY args RKEY .)
    SUPER           reduce using rule 83 (primary -> LKEY args RKEY .)


state 265

    (85) primary -> LKEY args COMMA . RKEY

    RKEY            shift and go to state 382


state 266

    (84) primary -> LKEY assocs RKEY .

    LBRACKET        reduce using rule 84 (primary -> LKEY assocs RKEY .)
    DOT             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    UNARY_OP        reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RANGE_INCLUSIVE reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RANGE_EXCLUSIVE reduce using rule 84 (primary -> LKEY assocs RKEY .)
    OR_SYMBOL       reduce using rule 84 (primary -> LKEY assocs RKEY .)
    BINARY_XOR_OP   reduce using rule 84 (primary -> LKEY assocs RKEY .)
    BINARY_AND_OP   reduce using rule 84 (primary -> LKEY assocs RKEY .)
    COMBINED_COMPARISON_OP reduce using rule 84 (primary -> LKEY assocs RKEY .)
    GREATERTHAN     reduce using rule 84 (primary -> LKEY assocs RKEY .)
    GREATERTHANEQUAL reduce using rule 84 (primary -> LKEY assocs RKEY .)
    LESSERTHAN      reduce using rule 84 (primary -> LKEY assocs RKEY .)
    LESSERTHANEQUAL reduce using rule 84 (primary -> LKEY assocs RKEY .)
    EQUAL           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    CASE_EQUALITY   reduce using rule 84 (primary -> LKEY assocs RKEY .)
    NOTEQUAL        reduce using rule 84 (primary -> LKEY assocs RKEY .)
    MATCHED_STRINGS_OP reduce using rule 84 (primary -> LKEY assocs RKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 84 (primary -> LKEY assocs RKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 84 (primary -> LKEY assocs RKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 84 (primary -> LKEY assocs RKEY .)
    AND             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    OR              reduce using rule 84 (primary -> LKEY assocs RKEY .)
    PLUS            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    MINUS           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    TIMES           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    DIVIDE          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    MOD             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    POW             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    IF              reduce using rule 84 (primary -> LKEY assocs RKEY .)
    WHILE           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    UNLESS          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    UNTIL           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    TERM            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    $end            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    COMMA           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RBRACKET        reduce using rule 84 (primary -> LKEY assocs RKEY .)
    THEN            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    DO              reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RESCUE          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    HASH_ROCKET     reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RKEY            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RPAREN          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    WHEN            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    LKEY            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    END             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    ELSIF           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    ELSE            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    ENSURE          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    NOT_SYMBOL      reduce using rule 84 (primary -> LKEY assocs RKEY .)
    COMPLEMENT_OP   reduce using rule 84 (primary -> LKEY assocs RKEY .)
    DEFINED_OP      reduce using rule 84 (primary -> LKEY assocs RKEY .)
    NUMBER          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    LPAREN          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    RETURN          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    YIELD           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    CASE            reduce using rule 84 (primary -> LKEY assocs RKEY .)
    FOR             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    BEGIN           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    CLASS           reduce using rule 84 (primary -> LKEY assocs RKEY .)
    MODULE          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    DEF             reduce using rule 84 (primary -> LKEY assocs RKEY .)
    VAR_GLOBAL      reduce using rule 84 (primary -> LKEY assocs RKEY .)
    VAR_LOCAL       reduce using rule 84 (primary -> LKEY assocs RKEY .)
    VAR_INSTANCE    reduce using rule 84 (primary -> LKEY assocs RKEY .)
    VAR_CLASS       reduce using rule 84 (primary -> LKEY assocs RKEY .)
    SYMBOL          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    STRING          reduce using rule 84 (primary -> LKEY assocs RKEY .)
    IDENTIFIER      reduce using rule 84 (primary -> LKEY assocs RKEY .)
    SUPER           reduce using rule 84 (primary -> LKEY assocs RKEY .)


state 267

    (86) primary -> LKEY assocs COMMA . RKEY

    RKEY            shift and go to state 383


state 268

    (166) assoc -> arg HASH_ROCKET . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 384
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 269

    (165) assocs -> assoc COMMA . assoc
    (166) assoc -> . arg HASH_ROCKET arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    assoc                          shift and go to state 385
    arg                            shift and go to state 386
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 270

    (16) stmt -> lhs = command . LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET

    LBRACKET        shift and go to state 387


state 271

    (40) arg -> lhs = arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 40 (arg -> lhs = arg .)
    WHILE           reduce using rule 40 (arg -> lhs = arg .)
    UNLESS          reduce using rule 40 (arg -> lhs = arg .)
    UNTIL           reduce using rule 40 (arg -> lhs = arg .)
    TERM            reduce using rule 40 (arg -> lhs = arg .)
    $end            reduce using rule 40 (arg -> lhs = arg .)
    COMMA           reduce using rule 40 (arg -> lhs = arg .)
    RBRACKET        reduce using rule 40 (arg -> lhs = arg .)
    THEN            reduce using rule 40 (arg -> lhs = arg .)
    DO              reduce using rule 40 (arg -> lhs = arg .)
    RESCUE          reduce using rule 40 (arg -> lhs = arg .)
    HASH_ROCKET     reduce using rule 40 (arg -> lhs = arg .)
    RKEY            reduce using rule 40 (arg -> lhs = arg .)
    RPAREN          reduce using rule 40 (arg -> lhs = arg .)
    WHEN            reduce using rule 40 (arg -> lhs = arg .)
    LKEY            reduce using rule 40 (arg -> lhs = arg .)
    END             reduce using rule 40 (arg -> lhs = arg .)
    ELSIF           reduce using rule 40 (arg -> lhs = arg .)
    ELSE            reduce using rule 40 (arg -> lhs = arg .)
    ENSURE          reduce using rule 40 (arg -> lhs = arg .)
    LBRACKET        reduce using rule 40 (arg -> lhs = arg .)
    NOT_SYMBOL      reduce using rule 40 (arg -> lhs = arg .)
    COMPLEMENT_OP   reduce using rule 40 (arg -> lhs = arg .)
    DEFINED_OP      reduce using rule 40 (arg -> lhs = arg .)
    NUMBER          reduce using rule 40 (arg -> lhs = arg .)
    LPAREN          reduce using rule 40 (arg -> lhs = arg .)
    UNARY_OP        reduce using rule 40 (arg -> lhs = arg .)
    RETURN          reduce using rule 40 (arg -> lhs = arg .)
    YIELD           reduce using rule 40 (arg -> lhs = arg .)
    CASE            reduce using rule 40 (arg -> lhs = arg .)
    FOR             reduce using rule 40 (arg -> lhs = arg .)
    BEGIN           reduce using rule 40 (arg -> lhs = arg .)
    CLASS           reduce using rule 40 (arg -> lhs = arg .)
    MODULE          reduce using rule 40 (arg -> lhs = arg .)
    DEF             reduce using rule 40 (arg -> lhs = arg .)
    VAR_GLOBAL      reduce using rule 40 (arg -> lhs = arg .)
    VAR_LOCAL       reduce using rule 40 (arg -> lhs = arg .)
    VAR_INSTANCE    reduce using rule 40 (arg -> lhs = arg .)
    VAR_CLASS       reduce using rule 40 (arg -> lhs = arg .)
    SYMBOL          reduce using rule 40 (arg -> lhs = arg .)
    STRING          reduce using rule 40 (arg -> lhs = arg .)
    IDENTIFIER      reduce using rule 40 (arg -> lhs = arg .)
    SUPER           reduce using rule 40 (arg -> lhs = arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! OR_SYMBOL       [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! GREATERTHAN     [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! LESSERTHAN      [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! EQUAL           [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! NOTEQUAL        [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! AND             [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! OR              [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! PLUS            [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! MINUS           [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! TIMES           [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! DIVIDE          [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! MOD             [ reduce using rule 40 (arg -> lhs = arg .) ]
  ! POW             [ reduce using rule 40 (arg -> lhs = arg .) ]


state 272

    (41) arg -> lhs op_asgn arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 41 (arg -> lhs op_asgn arg .)
    WHILE           reduce using rule 41 (arg -> lhs op_asgn arg .)
    UNLESS          reduce using rule 41 (arg -> lhs op_asgn arg .)
    UNTIL           reduce using rule 41 (arg -> lhs op_asgn arg .)
    TERM            reduce using rule 41 (arg -> lhs op_asgn arg .)
    $end            reduce using rule 41 (arg -> lhs op_asgn arg .)
    COMMA           reduce using rule 41 (arg -> lhs op_asgn arg .)
    RBRACKET        reduce using rule 41 (arg -> lhs op_asgn arg .)
    THEN            reduce using rule 41 (arg -> lhs op_asgn arg .)
    DO              reduce using rule 41 (arg -> lhs op_asgn arg .)
    RESCUE          reduce using rule 41 (arg -> lhs op_asgn arg .)
    HASH_ROCKET     reduce using rule 41 (arg -> lhs op_asgn arg .)
    RKEY            reduce using rule 41 (arg -> lhs op_asgn arg .)
    RPAREN          reduce using rule 41 (arg -> lhs op_asgn arg .)
    WHEN            reduce using rule 41 (arg -> lhs op_asgn arg .)
    LKEY            reduce using rule 41 (arg -> lhs op_asgn arg .)
    END             reduce using rule 41 (arg -> lhs op_asgn arg .)
    ELSIF           reduce using rule 41 (arg -> lhs op_asgn arg .)
    ELSE            reduce using rule 41 (arg -> lhs op_asgn arg .)
    ENSURE          reduce using rule 41 (arg -> lhs op_asgn arg .)
    LBRACKET        reduce using rule 41 (arg -> lhs op_asgn arg .)
    NOT_SYMBOL      reduce using rule 41 (arg -> lhs op_asgn arg .)
    COMPLEMENT_OP   reduce using rule 41 (arg -> lhs op_asgn arg .)
    DEFINED_OP      reduce using rule 41 (arg -> lhs op_asgn arg .)
    NUMBER          reduce using rule 41 (arg -> lhs op_asgn arg .)
    LPAREN          reduce using rule 41 (arg -> lhs op_asgn arg .)
    UNARY_OP        reduce using rule 41 (arg -> lhs op_asgn arg .)
    RETURN          reduce using rule 41 (arg -> lhs op_asgn arg .)
    YIELD           reduce using rule 41 (arg -> lhs op_asgn arg .)
    CASE            reduce using rule 41 (arg -> lhs op_asgn arg .)
    FOR             reduce using rule 41 (arg -> lhs op_asgn arg .)
    BEGIN           reduce using rule 41 (arg -> lhs op_asgn arg .)
    CLASS           reduce using rule 41 (arg -> lhs op_asgn arg .)
    MODULE          reduce using rule 41 (arg -> lhs op_asgn arg .)
    DEF             reduce using rule 41 (arg -> lhs op_asgn arg .)
    VAR_GLOBAL      reduce using rule 41 (arg -> lhs op_asgn arg .)
    VAR_LOCAL       reduce using rule 41 (arg -> lhs op_asgn arg .)
    VAR_INSTANCE    reduce using rule 41 (arg -> lhs op_asgn arg .)
    VAR_CLASS       reduce using rule 41 (arg -> lhs op_asgn arg .)
    SYMBOL          reduce using rule 41 (arg -> lhs op_asgn arg .)
    STRING          reduce using rule 41 (arg -> lhs op_asgn arg .)
    IDENTIFIER      reduce using rule 41 (arg -> lhs op_asgn arg .)
    SUPER           reduce using rule 41 (arg -> lhs op_asgn arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! OR_SYMBOL       [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! GREATERTHAN     [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! LESSERTHAN      [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! EQUAL           [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! NOTEQUAL        [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! AND             [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! OR              [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! PLUS            [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! MINUS           [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! TIMES           [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! DIVIDE          [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! MOD             [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]
  ! POW             [ reduce using rule 41 (arg -> lhs op_asgn arg .) ]


state 273

    (95) primary -> function LKEY compstmt . LKEY

    LKEY            shift and go to state 388


state 274

    (96) primary -> function LKEY OR_SYMBOL . OR_SYMBOL compstmt LKEY
    (97) primary -> function LKEY OR_SYMBOL . block_var OR_SYMBOL compstmt LKEY
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    OR_SYMBOL       shift and go to state 389
    TIMES           shift and go to state 44
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    function                       shift and go to state 77
    block_var                      shift and go to state 390
    lhs                            shift and go to state 202
    mlhs                           shift and go to state 69
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    mlhs_item                      shift and go to state 43
    literal                        shift and go to state 36
    operation                      shift and go to state 80

state 275

    (142) lhs -> primary LBRACKET RBRACKET .
    (77) primary -> primary LBRACKET RBRACKET .

  ! reduce/reduce conflict for LBRACKET resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for OR_SYMBOL resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for TIMES resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for IF resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for WHILE resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for UNLESS resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for UNTIL resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for COMMA resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for RPAREN resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for LKEY resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for DEFINED_OP resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for NUMBER resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for LPAREN resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for RETURN resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for YIELD resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for CASE resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for FOR resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for BEGIN resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for CLASS resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for MODULE resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for DEF resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for VAR_GLOBAL resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for VAR_LOCAL resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for VAR_INSTANCE resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for VAR_CLASS resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for STRING resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
  ! reduce/reduce conflict for SUPER resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
    =               reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    PLUS_EQUAL      reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    MINUS_EQUAL     reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    TIMES_EQUAL     reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    DIVIDE_EQUAL    reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    MOD_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    POW_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    SINGLE_AND_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    SINGLE_OR_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    XOR_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    BINARY_LEFT_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    BINARY_RIGHT_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    AND_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    OR_EQUAL        reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    IN              reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DOT             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    UNARY_OP        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    OR_SYMBOL       reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_XOR_OP   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_AND_OP   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    GREATERTHAN     reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    GREATERTHANEQUAL reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LESSERTHAN      reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LESSERTHANEQUAL reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    EQUAL           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    CASE_EQUALITY   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    NOTEQUAL        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    AND             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    OR              reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    PLUS            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MINUS           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    TIMES           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MOD             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    POW             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    IF              reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    WHILE           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    UNLESS          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    UNTIL           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    TERM            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    $end            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    COMMA           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RESCUE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    HASH_ROCKET     reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RKEY            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RPAREN          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    WHEN            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LKEY            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    END             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    ELSIF           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    ELSE            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    ENSURE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    THEN            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DO              reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    NOT_SYMBOL      reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    COMPLEMENT_OP   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DEFINED_OP      reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    NUMBER          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LPAREN          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RETURN          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    YIELD           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    CASE            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    FOR             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BEGIN           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    CLASS           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MODULE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DEF             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    VAR_GLOBAL      reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    VAR_LOCAL       reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    VAR_INSTANCE    reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    VAR_CLASS       reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    SYMBOL          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    STRING          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    IDENTIFIER      reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    SUPER           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)

  ! COMMA           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! RBRACKET        [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! RPAREN          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! OR_SYMBOL       [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! TIMES           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! VAR_GLOBAL      [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! VAR_LOCAL       [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! VAR_INSTANCE    [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! VAR_CLASS       [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! LPAREN          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! UNARY_OP        [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! LBRACKET        [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! LKEY            [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! RETURN          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! YIELD           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! DEFINED_OP      [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! IF              [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! UNLESS          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! WHILE           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! UNTIL           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! CASE            [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! FOR             [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! BEGIN           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! CLASS           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! MODULE          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! DEF             [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! NUMBER          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! SYMBOL          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! STRING          [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! IDENTIFIER      [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]
  ! SUPER           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]


state 276

    (143) lhs -> primary LBRACKET args . RBRACKET
    (78) primary -> primary LBRACKET args . RBRACKET

    RBRACKET        shift and go to state 391


state 277

    (144) lhs -> primary DOT IDENTIFIER .
    (213) operation -> IDENTIFIER .
    (214) operation -> IDENTIFIER . NOT_SYMBOL
    (215) operation -> IDENTIFIER . OPTIONAL_SYMBOL

  ! reduce/reduce conflict for LPAREN resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for SUPER resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for DEFINED_OP resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for LKEY resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for RETURN resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for YIELD resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for UNLESS resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for UNTIL resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for CASE resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for BEGIN resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for CLASS resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for DEF resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for NUMBER resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for STRING resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for VAR_GLOBAL resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for VAR_LOCAL resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for VAR_INSTANCE resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for VAR_CLASS resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for OR_SYMBOL resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 144 (lhs -> primary DOT IDENTIFIER .)
  ! shift/reduce conflict for NOT_SYMBOL resolved as shift
    =               reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    PLUS_EQUAL      reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    MINUS_EQUAL     reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    TIMES_EQUAL     reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    DIVIDE_EQUAL    reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    MOD_EQUAL       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    POW_EQUAL       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    SINGLE_AND_EQUAL reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    SINGLE_OR_EQUAL reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    XOR_EQUAL       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    BINARY_LEFT_EQUAL reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    BINARY_RIGHT_EQUAL reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    AND_EQUAL       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    OR_EQUAL        reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    COMMA           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    RBRACKET        reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    IN              reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    RPAREN          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    OR_SYMBOL       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    TIMES           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    VAR_GLOBAL      reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    VAR_LOCAL       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    VAR_INSTANCE    reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    VAR_CLASS       reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    LPAREN          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    UNARY_OP        reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    LBRACKET        reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    LKEY            reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    RETURN          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    YIELD           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    DEFINED_OP      reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    IF              reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    UNLESS          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    WHILE           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    UNTIL           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    CASE            reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    FOR             reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    BEGIN           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    CLASS           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    MODULE          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    DEF             reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    NUMBER          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    SYMBOL          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    STRING          reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    IDENTIFIER      reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    SUPER           reduce using rule 144 (lhs -> primary DOT IDENTIFIER .)
    BINARY_AND_OP   reduce using rule 213 (operation -> IDENTIFIER .)
    PLUS            reduce using rule 213 (operation -> IDENTIFIER .)
    MINUS           reduce using rule 213 (operation -> IDENTIFIER .)
    COMPLEMENT_OP   reduce using rule 213 (operation -> IDENTIFIER .)
    DO              reduce using rule 213 (operation -> IDENTIFIER .)
    TERM            reduce using rule 213 (operation -> IDENTIFIER .)
    DOT             reduce using rule 213 (operation -> IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 213 (operation -> IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 213 (operation -> IDENTIFIER .)
    BINARY_XOR_OP   reduce using rule 213 (operation -> IDENTIFIER .)
    COMBINED_COMPARISON_OP reduce using rule 213 (operation -> IDENTIFIER .)
    GREATERTHAN     reduce using rule 213 (operation -> IDENTIFIER .)
    GREATERTHANEQUAL reduce using rule 213 (operation -> IDENTIFIER .)
    LESSERTHAN      reduce using rule 213 (operation -> IDENTIFIER .)
    LESSERTHANEQUAL reduce using rule 213 (operation -> IDENTIFIER .)
    EQUAL           reduce using rule 213 (operation -> IDENTIFIER .)
    CASE_EQUALITY   reduce using rule 213 (operation -> IDENTIFIER .)
    NOTEQUAL        reduce using rule 213 (operation -> IDENTIFIER .)
    MATCHED_STRINGS_OP reduce using rule 213 (operation -> IDENTIFIER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 213 (operation -> IDENTIFIER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 213 (operation -> IDENTIFIER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 213 (operation -> IDENTIFIER .)
    AND             reduce using rule 213 (operation -> IDENTIFIER .)
    OR              reduce using rule 213 (operation -> IDENTIFIER .)
    DIVIDE          reduce using rule 213 (operation -> IDENTIFIER .)
    MOD             reduce using rule 213 (operation -> IDENTIFIER .)
    POW             reduce using rule 213 (operation -> IDENTIFIER .)
    $end            reduce using rule 213 (operation -> IDENTIFIER .)
    RESCUE          reduce using rule 213 (operation -> IDENTIFIER .)
    WHEN            reduce using rule 213 (operation -> IDENTIFIER .)
    RKEY            reduce using rule 213 (operation -> IDENTIFIER .)
    HASH_ROCKET     reduce using rule 213 (operation -> IDENTIFIER .)
    END             reduce using rule 213 (operation -> IDENTIFIER .)
    ELSIF           reduce using rule 213 (operation -> IDENTIFIER .)
    ELSE            reduce using rule 213 (operation -> IDENTIFIER .)
    ENSURE          reduce using rule 213 (operation -> IDENTIFIER .)
    THEN            reduce using rule 213 (operation -> IDENTIFIER .)
    NOT_SYMBOL      shift and go to state 150
    OPTIONAL_SYMBOL shift and go to state 151

  ! LPAREN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! SUPER           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NOT_SYMBOL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DEFINED_OP      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNARY_OP        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LKEY            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RETURN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! YIELD           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNLESS          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNTIL           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CASE            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BEGIN           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CLASS           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DEF             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NUMBER          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! SYMBOL          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! STRING          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_GLOBAL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_LOCAL       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_INSTANCE    [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_CLASS       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! OR_SYMBOL       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RBRACKET        [ reduce using rule 213 (operation -> IDENTIFIER .) ]


state 278

    (34) function -> primary DOT operation . LPAREN call_args RPAREN
    (36) function -> primary DOT operation .
    (30) command -> primary DOT operation . call_args
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    LPAREN          shift and go to state 392
    DO              reduce using rule 36 (function -> primary DOT operation .)
    TERM            reduce using rule 36 (function -> primary DOT operation .)
    DOT             reduce using rule 36 (function -> primary DOT operation .)
    RANGE_INCLUSIVE reduce using rule 36 (function -> primary DOT operation .)
    RANGE_EXCLUSIVE reduce using rule 36 (function -> primary DOT operation .)
    OR_SYMBOL       reduce using rule 36 (function -> primary DOT operation .)
    BINARY_XOR_OP   reduce using rule 36 (function -> primary DOT operation .)
    COMBINED_COMPARISON_OP reduce using rule 36 (function -> primary DOT operation .)
    GREATERTHAN     reduce using rule 36 (function -> primary DOT operation .)
    GREATERTHANEQUAL reduce using rule 36 (function -> primary DOT operation .)
    LESSERTHAN      reduce using rule 36 (function -> primary DOT operation .)
    LESSERTHANEQUAL reduce using rule 36 (function -> primary DOT operation .)
    EQUAL           reduce using rule 36 (function -> primary DOT operation .)
    CASE_EQUALITY   reduce using rule 36 (function -> primary DOT operation .)
    NOTEQUAL        reduce using rule 36 (function -> primary DOT operation .)
    MATCHED_STRINGS_OP reduce using rule 36 (function -> primary DOT operation .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 36 (function -> primary DOT operation .)
    BINARY_LEFT_SHIFT_OP reduce using rule 36 (function -> primary DOT operation .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 36 (function -> primary DOT operation .)
    AND             reduce using rule 36 (function -> primary DOT operation .)
    OR              reduce using rule 36 (function -> primary DOT operation .)
    DIVIDE          reduce using rule 36 (function -> primary DOT operation .)
    MOD             reduce using rule 36 (function -> primary DOT operation .)
    POW             reduce using rule 36 (function -> primary DOT operation .)
    $end            reduce using rule 36 (function -> primary DOT operation .)
    RESCUE          reduce using rule 36 (function -> primary DOT operation .)
    RPAREN          reduce using rule 36 (function -> primary DOT operation .)
    WHEN            reduce using rule 36 (function -> primary DOT operation .)
    RKEY            reduce using rule 36 (function -> primary DOT operation .)
    COMMA           reduce using rule 36 (function -> primary DOT operation .)
    HASH_ROCKET     reduce using rule 36 (function -> primary DOT operation .)
    END             reduce using rule 36 (function -> primary DOT operation .)
    ELSIF           reduce using rule 36 (function -> primary DOT operation .)
    ELSE            reduce using rule 36 (function -> primary DOT operation .)
    ENSURE          reduce using rule 36 (function -> primary DOT operation .)
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! LBRACKET        [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! UNARY_OP        [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! BINARY_AND_OP   [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! PLUS            [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! MINUS           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! TIMES           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! IF              [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! WHILE           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! UNLESS          [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! UNTIL           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! LPAREN          [ reduce using rule 36 (function -> primary DOT operation .) ]

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 393
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 279

    (35) function -> primary UNARY_OP operation . LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP operation .
    (31) command -> primary UNARY_OP operation . call_args
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    LPAREN          shift and go to state 394
    DO              reduce using rule 37 (function -> primary UNARY_OP operation .)
    TERM            reduce using rule 37 (function -> primary UNARY_OP operation .)
    DOT             reduce using rule 37 (function -> primary UNARY_OP operation .)
    RANGE_INCLUSIVE reduce using rule 37 (function -> primary UNARY_OP operation .)
    RANGE_EXCLUSIVE reduce using rule 37 (function -> primary UNARY_OP operation .)
    OR_SYMBOL       reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_XOR_OP   reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMBINED_COMPARISON_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    GREATERTHAN     reduce using rule 37 (function -> primary UNARY_OP operation .)
    GREATERTHANEQUAL reduce using rule 37 (function -> primary UNARY_OP operation .)
    LESSERTHAN      reduce using rule 37 (function -> primary UNARY_OP operation .)
    LESSERTHANEQUAL reduce using rule 37 (function -> primary UNARY_OP operation .)
    EQUAL           reduce using rule 37 (function -> primary UNARY_OP operation .)
    CASE_EQUALITY   reduce using rule 37 (function -> primary UNARY_OP operation .)
    NOTEQUAL        reduce using rule 37 (function -> primary UNARY_OP operation .)
    MATCHED_STRINGS_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_LEFT_SHIFT_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    AND             reduce using rule 37 (function -> primary UNARY_OP operation .)
    OR              reduce using rule 37 (function -> primary UNARY_OP operation .)
    DIVIDE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    MOD             reduce using rule 37 (function -> primary UNARY_OP operation .)
    POW             reduce using rule 37 (function -> primary UNARY_OP operation .)
    $end            reduce using rule 37 (function -> primary UNARY_OP operation .)
    RESCUE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    RPAREN          reduce using rule 37 (function -> primary UNARY_OP operation .)
    WHEN            reduce using rule 37 (function -> primary UNARY_OP operation .)
    RKEY            reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMMA           reduce using rule 37 (function -> primary UNARY_OP operation .)
    HASH_ROCKET     reduce using rule 37 (function -> primary UNARY_OP operation .)
    END             reduce using rule 37 (function -> primary UNARY_OP operation .)
    ELSIF           reduce using rule 37 (function -> primary UNARY_OP operation .)
    ELSE            reduce using rule 37 (function -> primary UNARY_OP operation .)
    ENSURE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! LBRACKET        [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! UNARY_OP        [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! BINARY_AND_OP   [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! PLUS            [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! MINUS           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! TIMES           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! IF              [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! WHILE           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! UNLESS          [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! UNTIL           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! LPAREN          [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 395
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 280

    (75) primary -> primary UNARY_OP IDENTIFIER .
    (213) operation -> IDENTIFIER .
    (214) operation -> IDENTIFIER . NOT_SYMBOL
    (215) operation -> IDENTIFIER . OPTIONAL_SYMBOL

  ! reduce/reduce conflict for LPAREN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for TIMES resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for BINARY_AND_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for SUPER resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for PLUS resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for MINUS resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for NOT_SYMBOL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for COMPLEMENT_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for DEFINED_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for LBRACKET resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for LKEY resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RETURN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for YIELD resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for IF resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for UNLESS resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for WHILE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for UNTIL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for CASE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for FOR resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for BEGIN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for CLASS resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for MODULE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for DEF resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for NUMBER resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for STRING resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for VAR_GLOBAL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for VAR_LOCAL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for VAR_INSTANCE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for VAR_CLASS resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for DO resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for TERM resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for DOT resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RANGE_INCLUSIVE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RANGE_EXCLUSIVE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for OR_SYMBOL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for BINARY_XOR_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for COMBINED_COMPARISON_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for GREATERTHAN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for GREATERTHANEQUAL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for LESSERTHAN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for LESSERTHANEQUAL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for EQUAL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for CASE_EQUALITY resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for NOTEQUAL resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for MATCHED_STRINGS_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for BINARY_LEFT_SHIFT_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for AND resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for OR resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for MOD resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for POW resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for $end resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RESCUE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for WHEN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RKEY resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for END resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for ELSIF resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for ELSE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for ENSURE resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for HASH_ROCKET resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! reduce/reduce conflict for THEN resolved using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
  ! shift/reduce conflict for NOT_SYMBOL resolved as shift
    LBRACKET        reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    DOT             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    UNARY_OP        reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RANGE_INCLUSIVE reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RANGE_EXCLUSIVE reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    OR_SYMBOL       reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    BINARY_XOR_OP   reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    BINARY_AND_OP   reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    COMBINED_COMPARISON_OP reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    GREATERTHAN     reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    GREATERTHANEQUAL reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    LESSERTHAN      reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    LESSERTHANEQUAL reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    EQUAL           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    CASE_EQUALITY   reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    NOTEQUAL        reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    MATCHED_STRINGS_OP reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    AND             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    OR              reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    PLUS            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    MINUS           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    TIMES           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    DIVIDE          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    MOD             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    POW             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    IF              reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    WHILE           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    UNLESS          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    UNTIL           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    TERM            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    $end            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    COMMA           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RBRACKET        reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    THEN            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    DO              reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RESCUE          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    HASH_ROCKET     reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RKEY            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RPAREN          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    WHEN            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    LKEY            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    END             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    ELSIF           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    ELSE            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    ENSURE          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    COMPLEMENT_OP   reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    DEFINED_OP      reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    NUMBER          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    LPAREN          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    RETURN          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    YIELD           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    CASE            reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    FOR             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    BEGIN           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    CLASS           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    MODULE          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    DEF             reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    VAR_GLOBAL      reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    VAR_LOCAL       reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    VAR_INSTANCE    reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    VAR_CLASS       reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    SYMBOL          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    STRING          reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    IDENTIFIER      reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    SUPER           reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .)
    NOT_SYMBOL      shift and go to state 150
    OPTIONAL_SYMBOL shift and go to state 151

  ! NOT_SYMBOL      [ reduce using rule 75 (primary -> primary UNARY_OP IDENTIFIER .) ]
  ! LPAREN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! TIMES           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BINARY_AND_OP   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! SUPER           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! PLUS            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MINUS           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NOT_SYMBOL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! COMPLEMENT_OP   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DEFINED_OP      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IDENTIFIER      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNARY_OP        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LBRACKET        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LKEY            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RETURN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! YIELD           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! IF              [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNLESS          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! WHILE           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! UNTIL           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CASE            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! FOR             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BEGIN           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CLASS           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MODULE          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DEF             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NUMBER          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! SYMBOL          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! STRING          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_GLOBAL      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_LOCAL       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_INSTANCE    [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! VAR_CLASS       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DO              [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! TERM            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DOT             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RANGE_INCLUSIVE [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! OR_SYMBOL       [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BINARY_XOR_OP   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! GREATERTHAN     [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! GREATERTHANEQUAL [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LESSERTHAN      [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! LESSERTHANEQUAL [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! EQUAL           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! CASE_EQUALITY   [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! NOTEQUAL        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! AND             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! OR              [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! DIVIDE          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! MOD             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! POW             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! $end            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RESCUE          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RPAREN          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! WHEN            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RKEY            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! END             [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! ELSIF           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! ELSE            [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! ENSURE          [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! RBRACKET        [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! HASH_ROCKET     [ reduce using rule 213 (operation -> IDENTIFIER .) ]
  ! THEN            [ reduce using rule 213 (operation -> IDENTIFIER .) ]


state 281

    (18) expr -> mlhs = mrhs .

    AND             reduce using rule 18 (expr -> mlhs = mrhs .)
    OR              reduce using rule 18 (expr -> mlhs = mrhs .)
    IF              reduce using rule 18 (expr -> mlhs = mrhs .)
    WHILE           reduce using rule 18 (expr -> mlhs = mrhs .)
    UNLESS          reduce using rule 18 (expr -> mlhs = mrhs .)
    UNTIL           reduce using rule 18 (expr -> mlhs = mrhs .)
    TERM            reduce using rule 18 (expr -> mlhs = mrhs .)
    $end            reduce using rule 18 (expr -> mlhs = mrhs .)
    THEN            reduce using rule 18 (expr -> mlhs = mrhs .)
    DO              reduce using rule 18 (expr -> mlhs = mrhs .)
    RESCUE          reduce using rule 18 (expr -> mlhs = mrhs .)
    RPAREN          reduce using rule 18 (expr -> mlhs = mrhs .)
    WHEN            reduce using rule 18 (expr -> mlhs = mrhs .)
    RKEY            reduce using rule 18 (expr -> mlhs = mrhs .)
    LKEY            reduce using rule 18 (expr -> mlhs = mrhs .)
    END             reduce using rule 18 (expr -> mlhs = mrhs .)
    ELSIF           reduce using rule 18 (expr -> mlhs = mrhs .)
    ELSE            reduce using rule 18 (expr -> mlhs = mrhs .)
    ENSURE          reduce using rule 18 (expr -> mlhs = mrhs .)


state 282

    (136) mrhs -> args .
    (137) mrhs -> args . COMMA
    (138) mrhs -> args . TIMES
    (139) mrhs -> args . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    AND             reduce using rule 136 (mrhs -> args .)
    OR              reduce using rule 136 (mrhs -> args .)
    TERM            reduce using rule 136 (mrhs -> args .)
    $end            reduce using rule 136 (mrhs -> args .)
    THEN            reduce using rule 136 (mrhs -> args .)
    DO              reduce using rule 136 (mrhs -> args .)
    RESCUE          reduce using rule 136 (mrhs -> args .)
    RPAREN          reduce using rule 136 (mrhs -> args .)
    WHEN            reduce using rule 136 (mrhs -> args .)
    RKEY            reduce using rule 136 (mrhs -> args .)
    END             reduce using rule 136 (mrhs -> args .)
    ELSIF           reduce using rule 136 (mrhs -> args .)
    ELSE            reduce using rule 136 (mrhs -> args .)
    ENSURE          reduce using rule 136 (mrhs -> args .)
    COMMA           shift and go to state 396
    TIMES           shift and go to state 397
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

  ! IF              [ reduce using rule 136 (mrhs -> args .) ]
  ! WHILE           [ reduce using rule 136 (mrhs -> args .) ]
  ! UNLESS          [ reduce using rule 136 (mrhs -> args .) ]
  ! UNTIL           [ reduce using rule 136 (mrhs -> args .) ]
  ! LKEY            [ reduce using rule 136 (mrhs -> args .) ]

    arg                            shift and go to state 398
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 283

    (140) mrhs -> TIMES . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 399
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 284

    (87) primary -> RETURN .
    (88) primary -> RETURN . LPAREN RPAREN
    (89) primary -> RETURN . LPAREN call_args RPAREN
    (19) expr -> RETURN . call_args
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    DOT             reduce using rule 87 (primary -> RETURN .)
    COMMA           reduce using rule 87 (primary -> RETURN .)
    RANGE_INCLUSIVE reduce using rule 87 (primary -> RETURN .)
    RANGE_EXCLUSIVE reduce using rule 87 (primary -> RETURN .)
    OR_SYMBOL       reduce using rule 87 (primary -> RETURN .)
    BINARY_XOR_OP   reduce using rule 87 (primary -> RETURN .)
    COMBINED_COMPARISON_OP reduce using rule 87 (primary -> RETURN .)
    GREATERTHAN     reduce using rule 87 (primary -> RETURN .)
    GREATERTHANEQUAL reduce using rule 87 (primary -> RETURN .)
    LESSERTHAN      reduce using rule 87 (primary -> RETURN .)
    LESSERTHANEQUAL reduce using rule 87 (primary -> RETURN .)
    EQUAL           reduce using rule 87 (primary -> RETURN .)
    CASE_EQUALITY   reduce using rule 87 (primary -> RETURN .)
    NOTEQUAL        reduce using rule 87 (primary -> RETURN .)
    MATCHED_STRINGS_OP reduce using rule 87 (primary -> RETURN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 87 (primary -> RETURN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 87 (primary -> RETURN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 87 (primary -> RETURN .)
    AND             reduce using rule 87 (primary -> RETURN .)
    OR              reduce using rule 87 (primary -> RETURN .)
    HASH_ROCKET     reduce using rule 87 (primary -> RETURN .)
    DIVIDE          reduce using rule 87 (primary -> RETURN .)
    MOD             reduce using rule 87 (primary -> RETURN .)
    POW             reduce using rule 87 (primary -> RETURN .)
    RPAREN          reduce using rule 87 (primary -> RETURN .)
    TERM            reduce using rule 87 (primary -> RETURN .)
    LPAREN          shift and go to state 154
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! UNARY_OP        [ reduce using rule 87 (primary -> RETURN .) ]
  ! LBRACKET        [ reduce using rule 87 (primary -> RETURN .) ]
  ! BINARY_AND_OP   [ reduce using rule 87 (primary -> RETURN .) ]
  ! PLUS            [ reduce using rule 87 (primary -> RETURN .) ]
  ! MINUS           [ reduce using rule 87 (primary -> RETURN .) ]
  ! TIMES           [ reduce using rule 87 (primary -> RETURN .) ]
  ! IF              [ reduce using rule 87 (primary -> RETURN .) ]
  ! WHILE           [ reduce using rule 87 (primary -> RETURN .) ]
  ! UNLESS          [ reduce using rule 87 (primary -> RETURN .) ]
  ! UNTIL           [ reduce using rule 87 (primary -> RETURN .) ]
  ! LPAREN          [ reduce using rule 87 (primary -> RETURN .) ]

    call_args                      shift and go to state 153
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 285

    (88) primary -> RETURN LPAREN RPAREN .

    LBRACKET        reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    DOT             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    UNARY_OP        reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RANGE_INCLUSIVE reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    OR_SYMBOL       reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    BINARY_XOR_OP   reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    BINARY_AND_OP   reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    GREATERTHANEQUAL reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    LESSERTHAN      reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    LESSERTHANEQUAL reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    EQUAL           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    CASE_EQUALITY   reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    AND             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    OR              reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    PLUS            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    MINUS           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    TIMES           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    DIVIDE          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    MOD             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    POW             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    IF              reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    WHILE           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    UNLESS          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    UNTIL           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    TERM            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    $end            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    COMMA           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RBRACKET        reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    THEN            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    DO              reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RESCUE          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    HASH_ROCKET     reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RKEY            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RPAREN          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    WHEN            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    LKEY            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    END             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    ELSIF           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    ELSE            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    ENSURE          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    NOT_SYMBOL      reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    COMPLEMENT_OP   reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    DEFINED_OP      reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    NUMBER          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    LPAREN          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    RETURN          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    YIELD           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    CASE            reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    FOR             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    BEGIN           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    CLASS           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    MODULE          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    DEF             reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    VAR_GLOBAL      reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    VAR_LOCAL       reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    VAR_INSTANCE    reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    VAR_CLASS       reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    SYMBOL          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    STRING          reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)
    SUPER           reduce using rule 88 (primary -> RETURN LPAREN RPAREN .)


state 286

    (89) primary -> RETURN LPAREN call_args . RPAREN

    RPAREN          shift and go to state 400


state 287

    (179) call_args -> TIMES . arg
    (180) call_args -> TIMES . arg COMMA BINARY_AND_OP arg
    (151) mlhs -> TIMES . lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 293
    lhs                            shift and go to state 401
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 288

    (182) call_args -> command .
    (28) call -> command .
    (24) expr -> command .

  ! reduce/reduce conflict for TERM resolved using rule 24 (expr -> command .)
  ! reduce/reduce conflict for RPAREN resolved using rule 24 (expr -> command .)
    DO              reduce using rule 28 (call -> command .)
    AND             reduce using rule 24 (expr -> command .)
    OR              reduce using rule 24 (expr -> command .)
    IF              reduce using rule 24 (expr -> command .)
    WHILE           reduce using rule 24 (expr -> command .)
    UNLESS          reduce using rule 24 (expr -> command .)
    UNTIL           reduce using rule 24 (expr -> command .)
    TERM            reduce using rule 24 (expr -> command .)
    RPAREN          reduce using rule 24 (expr -> command .)

  ! RPAREN          [ reduce using rule 182 (call_args -> command .) ]
  ! TERM            [ reduce using rule 28 (call -> command .) ]


state 289

    (90) primary -> YIELD .
    (91) primary -> YIELD . LPAREN RPAREN
    (92) primary -> YIELD . LPAREN call_args RPAREN
    (20) expr -> YIELD . call_args
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    DOT             reduce using rule 90 (primary -> YIELD .)
    COMMA           reduce using rule 90 (primary -> YIELD .)
    RANGE_INCLUSIVE reduce using rule 90 (primary -> YIELD .)
    RANGE_EXCLUSIVE reduce using rule 90 (primary -> YIELD .)
    OR_SYMBOL       reduce using rule 90 (primary -> YIELD .)
    BINARY_XOR_OP   reduce using rule 90 (primary -> YIELD .)
    COMBINED_COMPARISON_OP reduce using rule 90 (primary -> YIELD .)
    GREATERTHAN     reduce using rule 90 (primary -> YIELD .)
    GREATERTHANEQUAL reduce using rule 90 (primary -> YIELD .)
    LESSERTHAN      reduce using rule 90 (primary -> YIELD .)
    LESSERTHANEQUAL reduce using rule 90 (primary -> YIELD .)
    EQUAL           reduce using rule 90 (primary -> YIELD .)
    CASE_EQUALITY   reduce using rule 90 (primary -> YIELD .)
    NOTEQUAL        reduce using rule 90 (primary -> YIELD .)
    MATCHED_STRINGS_OP reduce using rule 90 (primary -> YIELD .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 90 (primary -> YIELD .)
    BINARY_LEFT_SHIFT_OP reduce using rule 90 (primary -> YIELD .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 90 (primary -> YIELD .)
    AND             reduce using rule 90 (primary -> YIELD .)
    OR              reduce using rule 90 (primary -> YIELD .)
    HASH_ROCKET     reduce using rule 90 (primary -> YIELD .)
    DIVIDE          reduce using rule 90 (primary -> YIELD .)
    MOD             reduce using rule 90 (primary -> YIELD .)
    POW             reduce using rule 90 (primary -> YIELD .)
    RPAREN          reduce using rule 90 (primary -> YIELD .)
    TERM            reduce using rule 90 (primary -> YIELD .)
    LPAREN          shift and go to state 161
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! UNARY_OP        [ reduce using rule 90 (primary -> YIELD .) ]
  ! LBRACKET        [ reduce using rule 90 (primary -> YIELD .) ]
  ! BINARY_AND_OP   [ reduce using rule 90 (primary -> YIELD .) ]
  ! PLUS            [ reduce using rule 90 (primary -> YIELD .) ]
  ! MINUS           [ reduce using rule 90 (primary -> YIELD .) ]
  ! TIMES           [ reduce using rule 90 (primary -> YIELD .) ]
  ! IF              [ reduce using rule 90 (primary -> YIELD .) ]
  ! WHILE           [ reduce using rule 90 (primary -> YIELD .) ]
  ! UNLESS          [ reduce using rule 90 (primary -> YIELD .) ]
  ! UNTIL           [ reduce using rule 90 (primary -> YIELD .) ]
  ! LPAREN          [ reduce using rule 90 (primary -> YIELD .) ]

    call_args                      shift and go to state 160
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 290

    (94) primary -> function .
    (95) primary -> function . LKEY compstmt LKEY
    (96) primary -> function . LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> function . LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (27) call -> function .

  ! reduce/reduce conflict for TERM resolved using rule 27 (call -> function .)
    DOT             reduce using rule 94 (primary -> function .)
    UNARY_OP        reduce using rule 94 (primary -> function .)
    LBRACKET        reduce using rule 94 (primary -> function .)
    COMMA           reduce using rule 94 (primary -> function .)
    RANGE_INCLUSIVE reduce using rule 94 (primary -> function .)
    RANGE_EXCLUSIVE reduce using rule 94 (primary -> function .)
    OR_SYMBOL       reduce using rule 94 (primary -> function .)
    BINARY_XOR_OP   reduce using rule 94 (primary -> function .)
    BINARY_AND_OP   reduce using rule 94 (primary -> function .)
    COMBINED_COMPARISON_OP reduce using rule 94 (primary -> function .)
    GREATERTHAN     reduce using rule 94 (primary -> function .)
    GREATERTHANEQUAL reduce using rule 94 (primary -> function .)
    LESSERTHAN      reduce using rule 94 (primary -> function .)
    LESSERTHANEQUAL reduce using rule 94 (primary -> function .)
    EQUAL           reduce using rule 94 (primary -> function .)
    CASE_EQUALITY   reduce using rule 94 (primary -> function .)
    NOTEQUAL        reduce using rule 94 (primary -> function .)
    MATCHED_STRINGS_OP reduce using rule 94 (primary -> function .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 94 (primary -> function .)
    BINARY_LEFT_SHIFT_OP reduce using rule 94 (primary -> function .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 94 (primary -> function .)
    AND             reduce using rule 94 (primary -> function .)
    OR              reduce using rule 94 (primary -> function .)
    HASH_ROCKET     reduce using rule 94 (primary -> function .)
    PLUS            reduce using rule 94 (primary -> function .)
    MINUS           reduce using rule 94 (primary -> function .)
    TIMES           reduce using rule 94 (primary -> function .)
    DIVIDE          reduce using rule 94 (primary -> function .)
    MOD             reduce using rule 94 (primary -> function .)
    POW             reduce using rule 94 (primary -> function .)
    RPAREN          reduce using rule 94 (primary -> function .)
    IF              reduce using rule 94 (primary -> function .)
    WHILE           reduce using rule 94 (primary -> function .)
    UNLESS          reduce using rule 94 (primary -> function .)
    UNTIL           reduce using rule 94 (primary -> function .)
    LPAREN          reduce using rule 94 (primary -> function .)
    LKEY            shift and go to state 146
    DO              reduce using rule 27 (call -> function .)
    TERM            reduce using rule 27 (call -> function .)

  ! TERM            [ reduce using rule 94 (primary -> function .) ]


state 291

    (168) call_args -> args COMMA . assocs
    (169) call_args -> args COMMA . TIMES arg
    (170) call_args -> args COMMA . BINARY_AND_OP arg
    (171) call_args -> args COMMA . assocs COMMA TIMES arg
    (172) call_args -> args COMMA . assocs COMMA BINARY_AND_OP arg
    (173) call_args -> args COMMA . TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> args COMMA . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (166) assoc -> . arg HASH_ROCKET arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 403
    BINARY_AND_OP   shift and go to state 404
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    assocs                         shift and go to state 402
    arg                            shift and go to state 386
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 292

    (176) call_args -> assocs COMMA . TIMES arg
    (177) call_args -> assocs COMMA . BINARY_AND_OP arg
    (178) call_args -> assocs COMMA . TIMES arg COMMA BINARY_AND_OP arg

    TIMES           shift and go to state 405
    BINARY_AND_OP   shift and go to state 406


state 293

    (179) call_args -> TIMES arg .
    (180) call_args -> TIMES arg . COMMA BINARY_AND_OP arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 179 (call_args -> TIMES arg .)
    WHILE           reduce using rule 179 (call_args -> TIMES arg .)
    UNLESS          reduce using rule 179 (call_args -> TIMES arg .)
    UNTIL           reduce using rule 179 (call_args -> TIMES arg .)
    TERM            reduce using rule 179 (call_args -> TIMES arg .)
    $end            reduce using rule 179 (call_args -> TIMES arg .)
    THEN            reduce using rule 179 (call_args -> TIMES arg .)
    DO              reduce using rule 179 (call_args -> TIMES arg .)
    RESCUE          reduce using rule 179 (call_args -> TIMES arg .)
    RPAREN          reduce using rule 179 (call_args -> TIMES arg .)
    WHEN            reduce using rule 179 (call_args -> TIMES arg .)
    RKEY            reduce using rule 179 (call_args -> TIMES arg .)
    LKEY            reduce using rule 179 (call_args -> TIMES arg .)
    END             reduce using rule 179 (call_args -> TIMES arg .)
    ELSIF           reduce using rule 179 (call_args -> TIMES arg .)
    ELSE            reduce using rule 179 (call_args -> TIMES arg .)
    ENSURE          reduce using rule 179 (call_args -> TIMES arg .)
    LBRACKET        reduce using rule 179 (call_args -> TIMES arg .)
    RBRACKET        reduce using rule 179 (call_args -> TIMES arg .)
    COMMA           shift and go to state 407
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 179 (call_args -> TIMES arg .) ]
  ! OR              [ reduce using rule 179 (call_args -> TIMES arg .) ]


state 294

    (181) call_args -> BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    WHILE           reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    UNLESS          reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    UNTIL           reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    TERM            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    $end            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    THEN            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    DO              reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    RESCUE          reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    RPAREN          reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    WHEN            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    RKEY            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    LKEY            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    END             reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    ELSIF           reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    ELSE            reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    ENSURE          reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 181 (call_args -> BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 181 (call_args -> BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 181 (call_args -> BINARY_AND_OP arg .) ]


state 295

    (91) primary -> YIELD LPAREN RPAREN .

    LBRACKET        reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    DOT             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    UNARY_OP        reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RANGE_INCLUSIVE reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    OR_SYMBOL       reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    BINARY_XOR_OP   reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    BINARY_AND_OP   reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    GREATERTHAN     reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    GREATERTHANEQUAL reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    LESSERTHAN      reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    LESSERTHANEQUAL reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    EQUAL           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    CASE_EQUALITY   reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    AND             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    OR              reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    PLUS            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    MINUS           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    TIMES           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    DIVIDE          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    MOD             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    POW             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    IF              reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    WHILE           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    UNLESS          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    UNTIL           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    TERM            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    $end            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    COMMA           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RBRACKET        reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    THEN            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    DO              reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RESCUE          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    HASH_ROCKET     reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RKEY            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RPAREN          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    WHEN            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    LKEY            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    END             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    ELSIF           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    ELSE            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    ENSURE          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    NOT_SYMBOL      reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    COMPLEMENT_OP   reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    DEFINED_OP      reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    NUMBER          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    LPAREN          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    RETURN          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    YIELD           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    CASE            reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    FOR             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    BEGIN           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    CLASS           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    MODULE          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    DEF             reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    VAR_GLOBAL      reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    VAR_LOCAL       reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    VAR_INSTANCE    reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    VAR_CLASS       reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    SYMBOL          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    STRING          reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    IDENTIFIER      reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)
    SUPER           reduce using rule 91 (primary -> YIELD LPAREN RPAREN .)


state 296

    (92) primary -> YIELD LPAREN call_args . RPAREN

    RPAREN          shift and go to state 408


state 297

    (42) arg -> arg RANGE_INCLUSIVE arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    WHILE           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    UNLESS          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    UNTIL           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    TERM            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    $end            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    COMMA           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    RBRACKET        reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    THEN            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    DO              reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    RESCUE          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    HASH_ROCKET     reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    RKEY            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    RPAREN          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    WHEN            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    LKEY            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    END             reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    ELSIF           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    ELSE            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    ENSURE          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    LBRACKET        reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    NOT_SYMBOL      reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    COMPLEMENT_OP   reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    DEFINED_OP      reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    NUMBER          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    LPAREN          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    UNARY_OP        reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    RETURN          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    YIELD           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    CASE            reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    FOR             reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    BEGIN           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    CLASS           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    MODULE          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    DEF             reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    VAR_GLOBAL      reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    VAR_LOCAL       reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    VAR_INSTANCE    reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    VAR_CLASS       reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    SYMBOL          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    STRING          reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    IDENTIFIER      reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    SUPER           reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! OR_SYMBOL       [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! GREATERTHAN     [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! LESSERTHAN      [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! EQUAL           [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! NOTEQUAL        [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! AND             [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! OR              [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! PLUS            [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! MINUS           [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! TIMES           [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! DIVIDE          [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! MOD             [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]
  ! POW             [ reduce using rule 42 (arg -> arg RANGE_INCLUSIVE arg .) ]


state 298

    (43) arg -> arg RANGE_EXCLUSIVE arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    WHILE           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    UNLESS          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    UNTIL           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    TERM            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    $end            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    COMMA           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    RBRACKET        reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    THEN            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    DO              reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    RESCUE          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    HASH_ROCKET     reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    RKEY            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    RPAREN          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    WHEN            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    LKEY            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    END             reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    ELSIF           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    ELSE            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    ENSURE          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    LBRACKET        reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    NOT_SYMBOL      reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    COMPLEMENT_OP   reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    DEFINED_OP      reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    NUMBER          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    LPAREN          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    UNARY_OP        reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    RETURN          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    YIELD           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    CASE            reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    FOR             reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    BEGIN           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    CLASS           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    MODULE          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    DEF             reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    VAR_GLOBAL      reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    VAR_LOCAL       reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    VAR_INSTANCE    reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    VAR_CLASS       reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    SYMBOL          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    STRING          reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    IDENTIFIER      reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    SUPER           reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! OR_SYMBOL       [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! GREATERTHAN     [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! LESSERTHAN      [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! EQUAL           [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! NOTEQUAL        [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! AND             [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! OR              [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! PLUS            [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! MINUS           [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! TIMES           [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! DIVIDE          [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! MOD             [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]
  ! POW             [ reduce using rule 43 (arg -> arg RANGE_EXCLUSIVE arg .) ]


state 299

    (47) arg -> arg OR_SYMBOL arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    WHILE           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    UNLESS          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    UNTIL           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    TERM            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    $end            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    COMMA           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    RBRACKET        reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    THEN            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    DO              reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    RESCUE          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    HASH_ROCKET     reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    RKEY            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    RPAREN          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    WHEN            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    LKEY            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    END             reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    ELSIF           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    ELSE            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    ENSURE          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    LBRACKET        reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    NOT_SYMBOL      reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    COMPLEMENT_OP   reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    DEFINED_OP      reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    NUMBER          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    LPAREN          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    UNARY_OP        reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    RETURN          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    YIELD           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    CASE            reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    FOR             reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    BEGIN           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    CLASS           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    MODULE          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    DEF             reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    VAR_GLOBAL      reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    VAR_LOCAL       reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    VAR_INSTANCE    reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    VAR_CLASS       reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    SYMBOL          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    STRING          reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    IDENTIFIER      reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    SUPER           reduce using rule 47 (arg -> arg OR_SYMBOL arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! OR_SYMBOL       [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! GREATERTHAN     [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! LESSERTHAN      [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! EQUAL           [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! NOTEQUAL        [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! AND             [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! OR              [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! PLUS            [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! MINUS           [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! TIMES           [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! DIVIDE          [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! MOD             [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]
  ! POW             [ reduce using rule 47 (arg -> arg OR_SYMBOL arg .) ]


state 300

    (48) arg -> arg BINARY_XOR_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    WHILE           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    UNLESS          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    UNTIL           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    TERM            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    $end            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    COMMA           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    RBRACKET        reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    THEN            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    DO              reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    RESCUE          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    HASH_ROCKET     reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    RKEY            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    RPAREN          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    WHEN            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    LKEY            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    END             reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    ELSIF           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    ELSE            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    ENSURE          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    LBRACKET        reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    NOT_SYMBOL      reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    COMPLEMENT_OP   reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    DEFINED_OP      reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    NUMBER          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    LPAREN          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    UNARY_OP        reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    RETURN          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    YIELD           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    CASE            reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    FOR             reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    BEGIN           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    CLASS           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    MODULE          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    DEF             reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    VAR_GLOBAL      reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    VAR_LOCAL       reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    VAR_INSTANCE    reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    VAR_CLASS       reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    SYMBOL          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    STRING          reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    IDENTIFIER      reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    SUPER           reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! EQUAL           [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! AND             [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! OR              [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! PLUS            [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! MINUS           [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! TIMES           [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! DIVIDE          [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! MOD             [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]
  ! POW             [ reduce using rule 48 (arg -> arg BINARY_XOR_OP arg .) ]


state 301

    (49) arg -> arg BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    WHILE           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    UNLESS          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    UNTIL           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    TERM            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    $end            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    COMMA           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    THEN            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    DO              reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    RESCUE          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    HASH_ROCKET     reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    RKEY            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    RPAREN          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    WHEN            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    LKEY            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    END             reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    ELSIF           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    ELSE            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    ENSURE          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    NOT_SYMBOL      reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    COMPLEMENT_OP   reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    DEFINED_OP      reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    NUMBER          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    LPAREN          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    UNARY_OP        reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    RETURN          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    YIELD           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    CASE            reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    FOR             reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    BEGIN           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    CLASS           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    MODULE          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    DEF             reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    VAR_GLOBAL      reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    VAR_LOCAL       reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    VAR_INSTANCE    reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    VAR_CLASS       reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    SYMBOL          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    STRING          reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    IDENTIFIER      reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    SUPER           reduce using rule 49 (arg -> arg BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! EQUAL           [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! AND             [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! PLUS            [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! MINUS           [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! TIMES           [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! DIVIDE          [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! MOD             [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]
  ! POW             [ reduce using rule 49 (arg -> arg BINARY_AND_OP arg .) ]


state 302

    (50) arg -> arg COMBINED_COMPARISON_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    WHILE           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    UNLESS          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    UNTIL           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    TERM            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    $end            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    COMMA           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    RBRACKET        reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    THEN            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    DO              reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    RESCUE          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    HASH_ROCKET     reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    RKEY            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    RPAREN          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    WHEN            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    LKEY            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    END             reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    ELSIF           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    ELSE            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    ENSURE          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    LBRACKET        reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    NOT_SYMBOL      reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    COMPLEMENT_OP   reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    DEFINED_OP      reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    NUMBER          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    LPAREN          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    UNARY_OP        reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    RETURN          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    YIELD           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    CASE            reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    FOR             reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    BEGIN           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    CLASS           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    MODULE          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    DEF             reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    VAR_GLOBAL      reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    VAR_LOCAL       reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    VAR_INSTANCE    reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    VAR_CLASS       reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    SYMBOL          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    STRING          reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    IDENTIFIER      reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    SUPER           reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! EQUAL           [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! AND             [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! OR              [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! PLUS            [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! MINUS           [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! TIMES           [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! DIVIDE          [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! MOD             [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]
  ! POW             [ reduce using rule 50 (arg -> arg COMBINED_COMPARISON_OP arg .) ]


state 303

    (51) arg -> arg GREATERTHAN arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    WHILE           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    UNLESS          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    UNTIL           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    TERM            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    $end            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    COMMA           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    RBRACKET        reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    THEN            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    DO              reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    RESCUE          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    HASH_ROCKET     reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    RKEY            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    RPAREN          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    WHEN            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    LKEY            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    END             reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    ELSIF           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    ELSE            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    ENSURE          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    LBRACKET        reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    NOT_SYMBOL      reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    COMPLEMENT_OP   reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    DEFINED_OP      reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    NUMBER          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    LPAREN          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    UNARY_OP        reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    RETURN          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    YIELD           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    CASE            reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    FOR             reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    BEGIN           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    CLASS           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    MODULE          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    DEF             reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    VAR_GLOBAL      reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    VAR_LOCAL       reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    VAR_INSTANCE    reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    VAR_CLASS       reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    SYMBOL          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    STRING          reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    IDENTIFIER      reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    SUPER           reduce using rule 51 (arg -> arg GREATERTHAN arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! OR_SYMBOL       [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! GREATERTHAN     [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! LESSERTHAN      [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! EQUAL           [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! NOTEQUAL        [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! AND             [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! OR              [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! PLUS            [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! MINUS           [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! TIMES           [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! DIVIDE          [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! MOD             [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]
  ! POW             [ reduce using rule 51 (arg -> arg GREATERTHAN arg .) ]


state 304

    (52) arg -> arg GREATERTHANEQUAL arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    WHILE           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    UNLESS          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    UNTIL           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    TERM            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    $end            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    COMMA           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    RBRACKET        reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    THEN            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    DO              reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    RESCUE          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    HASH_ROCKET     reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    RKEY            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    RPAREN          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    WHEN            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    LKEY            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    END             reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    ELSIF           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    ELSE            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    ENSURE          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    LBRACKET        reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    NOT_SYMBOL      reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    COMPLEMENT_OP   reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    DEFINED_OP      reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    NUMBER          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    LPAREN          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    UNARY_OP        reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    RETURN          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    YIELD           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    CASE            reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    FOR             reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    BEGIN           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    CLASS           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    MODULE          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    DEF             reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    VAR_GLOBAL      reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    VAR_LOCAL       reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    VAR_INSTANCE    reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    VAR_CLASS       reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    SYMBOL          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    STRING          reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    IDENTIFIER      reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    SUPER           reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! OR_SYMBOL       [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! GREATERTHAN     [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! LESSERTHAN      [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! EQUAL           [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! NOTEQUAL        [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! AND             [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! OR              [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! PLUS            [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! MINUS           [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! TIMES           [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! DIVIDE          [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! MOD             [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]
  ! POW             [ reduce using rule 52 (arg -> arg GREATERTHANEQUAL arg .) ]


state 305

    (53) arg -> arg LESSERTHAN arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    WHILE           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    UNLESS          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    UNTIL           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    TERM            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    $end            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    COMMA           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    RBRACKET        reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    THEN            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    DO              reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    RESCUE          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    HASH_ROCKET     reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    RKEY            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    RPAREN          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    WHEN            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    LKEY            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    END             reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    ELSIF           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    ELSE            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    ENSURE          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    LBRACKET        reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    NOT_SYMBOL      reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    COMPLEMENT_OP   reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    DEFINED_OP      reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    NUMBER          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    LPAREN          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    UNARY_OP        reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    RETURN          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    YIELD           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    CASE            reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    FOR             reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    BEGIN           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    CLASS           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    MODULE          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    DEF             reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    VAR_GLOBAL      reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    VAR_LOCAL       reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    VAR_INSTANCE    reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    VAR_CLASS       reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    SYMBOL          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    STRING          reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    IDENTIFIER      reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    SUPER           reduce using rule 53 (arg -> arg LESSERTHAN arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! OR_SYMBOL       [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! GREATERTHAN     [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! LESSERTHAN      [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! EQUAL           [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! NOTEQUAL        [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! AND             [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! OR              [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! PLUS            [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! MINUS           [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! TIMES           [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! DIVIDE          [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! MOD             [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]
  ! POW             [ reduce using rule 53 (arg -> arg LESSERTHAN arg .) ]


state 306

    (54) arg -> arg LESSERTHANEQUAL arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    WHILE           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    UNLESS          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    UNTIL           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    TERM            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    $end            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    COMMA           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    RBRACKET        reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    THEN            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    DO              reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    RESCUE          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    HASH_ROCKET     reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    RKEY            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    RPAREN          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    WHEN            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    LKEY            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    END             reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    ELSIF           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    ELSE            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    ENSURE          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    LBRACKET        reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    NOT_SYMBOL      reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    COMPLEMENT_OP   reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    DEFINED_OP      reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    NUMBER          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    LPAREN          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    UNARY_OP        reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    RETURN          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    YIELD           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    CASE            reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    FOR             reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    BEGIN           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    CLASS           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    MODULE          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    DEF             reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    VAR_GLOBAL      reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    VAR_LOCAL       reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    VAR_INSTANCE    reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    VAR_CLASS       reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    SYMBOL          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    STRING          reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    IDENTIFIER      reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    SUPER           reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! OR_SYMBOL       [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! GREATERTHAN     [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! LESSERTHAN      [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! EQUAL           [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! NOTEQUAL        [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! AND             [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! OR              [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! PLUS            [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! MINUS           [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! TIMES           [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! DIVIDE          [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! MOD             [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]
  ! POW             [ reduce using rule 54 (arg -> arg LESSERTHANEQUAL arg .) ]


state 307

    (55) arg -> arg EQUAL arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 55 (arg -> arg EQUAL arg .)
    WHILE           reduce using rule 55 (arg -> arg EQUAL arg .)
    UNLESS          reduce using rule 55 (arg -> arg EQUAL arg .)
    UNTIL           reduce using rule 55 (arg -> arg EQUAL arg .)
    TERM            reduce using rule 55 (arg -> arg EQUAL arg .)
    $end            reduce using rule 55 (arg -> arg EQUAL arg .)
    COMMA           reduce using rule 55 (arg -> arg EQUAL arg .)
    RBRACKET        reduce using rule 55 (arg -> arg EQUAL arg .)
    THEN            reduce using rule 55 (arg -> arg EQUAL arg .)
    DO              reduce using rule 55 (arg -> arg EQUAL arg .)
    RESCUE          reduce using rule 55 (arg -> arg EQUAL arg .)
    HASH_ROCKET     reduce using rule 55 (arg -> arg EQUAL arg .)
    RKEY            reduce using rule 55 (arg -> arg EQUAL arg .)
    RPAREN          reduce using rule 55 (arg -> arg EQUAL arg .)
    WHEN            reduce using rule 55 (arg -> arg EQUAL arg .)
    LKEY            reduce using rule 55 (arg -> arg EQUAL arg .)
    END             reduce using rule 55 (arg -> arg EQUAL arg .)
    ELSIF           reduce using rule 55 (arg -> arg EQUAL arg .)
    ELSE            reduce using rule 55 (arg -> arg EQUAL arg .)
    ENSURE          reduce using rule 55 (arg -> arg EQUAL arg .)
    LBRACKET        reduce using rule 55 (arg -> arg EQUAL arg .)
    NOT_SYMBOL      reduce using rule 55 (arg -> arg EQUAL arg .)
    COMPLEMENT_OP   reduce using rule 55 (arg -> arg EQUAL arg .)
    DEFINED_OP      reduce using rule 55 (arg -> arg EQUAL arg .)
    NUMBER          reduce using rule 55 (arg -> arg EQUAL arg .)
    LPAREN          reduce using rule 55 (arg -> arg EQUAL arg .)
    UNARY_OP        reduce using rule 55 (arg -> arg EQUAL arg .)
    RETURN          reduce using rule 55 (arg -> arg EQUAL arg .)
    YIELD           reduce using rule 55 (arg -> arg EQUAL arg .)
    CASE            reduce using rule 55 (arg -> arg EQUAL arg .)
    FOR             reduce using rule 55 (arg -> arg EQUAL arg .)
    BEGIN           reduce using rule 55 (arg -> arg EQUAL arg .)
    CLASS           reduce using rule 55 (arg -> arg EQUAL arg .)
    MODULE          reduce using rule 55 (arg -> arg EQUAL arg .)
    DEF             reduce using rule 55 (arg -> arg EQUAL arg .)
    VAR_GLOBAL      reduce using rule 55 (arg -> arg EQUAL arg .)
    VAR_LOCAL       reduce using rule 55 (arg -> arg EQUAL arg .)
    VAR_INSTANCE    reduce using rule 55 (arg -> arg EQUAL arg .)
    VAR_CLASS       reduce using rule 55 (arg -> arg EQUAL arg .)
    SYMBOL          reduce using rule 55 (arg -> arg EQUAL arg .)
    STRING          reduce using rule 55 (arg -> arg EQUAL arg .)
    IDENTIFIER      reduce using rule 55 (arg -> arg EQUAL arg .)
    SUPER           reduce using rule 55 (arg -> arg EQUAL arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! OR_SYMBOL       [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! GREATERTHAN     [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! LESSERTHAN      [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! EQUAL           [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! NOTEQUAL        [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! AND             [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! OR              [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! PLUS            [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! MINUS           [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! TIMES           [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! DIVIDE          [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! MOD             [ reduce using rule 55 (arg -> arg EQUAL arg .) ]
  ! POW             [ reduce using rule 55 (arg -> arg EQUAL arg .) ]


state 308

    (56) arg -> arg CASE_EQUALITY arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    WHILE           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    UNLESS          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    UNTIL           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    TERM            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    $end            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    COMMA           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    RBRACKET        reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    THEN            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    DO              reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    RESCUE          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    HASH_ROCKET     reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    RKEY            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    RPAREN          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    WHEN            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    LKEY            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    END             reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    ELSIF           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    ELSE            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    ENSURE          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    LBRACKET        reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    NOT_SYMBOL      reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    COMPLEMENT_OP   reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    DEFINED_OP      reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    NUMBER          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    LPAREN          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    UNARY_OP        reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    RETURN          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    YIELD           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    CASE            reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    FOR             reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    BEGIN           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    CLASS           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    MODULE          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    DEF             reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    VAR_GLOBAL      reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    VAR_LOCAL       reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    VAR_INSTANCE    reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    VAR_CLASS       reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    SYMBOL          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    STRING          reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    IDENTIFIER      reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    SUPER           reduce using rule 56 (arg -> arg CASE_EQUALITY arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! OR_SYMBOL       [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! GREATERTHAN     [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! LESSERTHAN      [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! EQUAL           [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! NOTEQUAL        [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! AND             [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! OR              [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! PLUS            [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! MINUS           [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! TIMES           [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! DIVIDE          [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! MOD             [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]
  ! POW             [ reduce using rule 56 (arg -> arg CASE_EQUALITY arg .) ]


state 309

    (57) arg -> arg NOTEQUAL arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    WHILE           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    UNLESS          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    UNTIL           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    TERM            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    $end            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    COMMA           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    RBRACKET        reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    THEN            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    DO              reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    RESCUE          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    HASH_ROCKET     reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    RKEY            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    RPAREN          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    WHEN            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    LKEY            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    END             reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    ELSIF           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    ELSE            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    ENSURE          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    LBRACKET        reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    NOT_SYMBOL      reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    COMPLEMENT_OP   reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    DEFINED_OP      reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    NUMBER          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    LPAREN          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    UNARY_OP        reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    RETURN          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    YIELD           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    CASE            reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    FOR             reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    BEGIN           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    CLASS           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    MODULE          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    DEF             reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    VAR_GLOBAL      reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    VAR_LOCAL       reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    VAR_INSTANCE    reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    VAR_CLASS       reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    SYMBOL          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    STRING          reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    IDENTIFIER      reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    SUPER           reduce using rule 57 (arg -> arg NOTEQUAL arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! OR_SYMBOL       [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! GREATERTHAN     [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! LESSERTHAN      [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! EQUAL           [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! NOTEQUAL        [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! AND             [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! OR              [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! PLUS            [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! MINUS           [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! TIMES           [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! DIVIDE          [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! MOD             [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]
  ! POW             [ reduce using rule 57 (arg -> arg NOTEQUAL arg .) ]


state 310

    (58) arg -> arg MATCHED_STRINGS_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    WHILE           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    UNLESS          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    UNTIL           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    TERM            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    $end            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    COMMA           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    RBRACKET        reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    THEN            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    DO              reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    RESCUE          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    HASH_ROCKET     reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    RKEY            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    RPAREN          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    WHEN            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    LKEY            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    END             reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    ELSIF           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    ELSE            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    ENSURE          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    LBRACKET        reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    NOT_SYMBOL      reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    COMPLEMENT_OP   reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    DEFINED_OP      reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    NUMBER          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    LPAREN          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    UNARY_OP        reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    RETURN          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    YIELD           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    CASE            reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    FOR             reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    BEGIN           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    CLASS           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    MODULE          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    DEF             reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    VAR_GLOBAL      reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    VAR_LOCAL       reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    VAR_INSTANCE    reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    VAR_CLASS       reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    SYMBOL          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    STRING          reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    IDENTIFIER      reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    SUPER           reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! EQUAL           [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! AND             [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! OR              [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! PLUS            [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! MINUS           [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! TIMES           [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! DIVIDE          [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! MOD             [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]
  ! POW             [ reduce using rule 58 (arg -> arg MATCHED_STRINGS_OP arg .) ]


state 311

    (59) arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    WHILE           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    UNLESS          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    UNTIL           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    TERM            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    $end            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    COMMA           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    RBRACKET        reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    THEN            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    DO              reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    RESCUE          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    HASH_ROCKET     reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    RKEY            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    RPAREN          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    WHEN            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    LKEY            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    END             reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    ELSIF           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    ELSE            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    ENSURE          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    LBRACKET        reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    NOT_SYMBOL      reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    COMPLEMENT_OP   reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    DEFINED_OP      reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    NUMBER          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    LPAREN          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    UNARY_OP        reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    RETURN          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    YIELD           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    CASE            reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    FOR             reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    BEGIN           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    CLASS           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    MODULE          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    DEF             reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    VAR_GLOBAL      reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    VAR_LOCAL       reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    VAR_INSTANCE    reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    VAR_CLASS       reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    SYMBOL          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    STRING          reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    IDENTIFIER      reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    SUPER           reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! EQUAL           [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! AND             [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! OR              [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! PLUS            [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! MINUS           [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! TIMES           [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! DIVIDE          [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! MOD             [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]
  ! POW             [ reduce using rule 59 (arg -> arg OPPOSITE_MATCHED_STRINGS_OP arg .) ]


state 312

    (62) arg -> arg BINARY_LEFT_SHIFT_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    WHILE           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    UNLESS          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    UNTIL           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    TERM            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    $end            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    COMMA           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    RBRACKET        reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    THEN            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    DO              reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    RESCUE          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    HASH_ROCKET     reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    RKEY            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    RPAREN          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    WHEN            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    LKEY            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    END             reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    ELSIF           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    ELSE            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    ENSURE          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    LBRACKET        reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    NOT_SYMBOL      reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    COMPLEMENT_OP   reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    DEFINED_OP      reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    NUMBER          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    LPAREN          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    UNARY_OP        reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    RETURN          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    YIELD           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    CASE            reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    FOR             reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    BEGIN           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    CLASS           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    MODULE          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    DEF             reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    VAR_GLOBAL      reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    VAR_LOCAL       reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    VAR_INSTANCE    reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    VAR_CLASS       reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    SYMBOL          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    STRING          reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    IDENTIFIER      reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    SUPER           reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! EQUAL           [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! AND             [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! OR              [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! PLUS            [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! MINUS           [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! TIMES           [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! DIVIDE          [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! MOD             [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]
  ! POW             [ reduce using rule 62 (arg -> arg BINARY_LEFT_SHIFT_OP arg .) ]


state 313

    (63) arg -> arg BINARY_RIGHT_SHIFT_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    WHILE           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    UNLESS          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    UNTIL           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    TERM            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    $end            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    COMMA           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    RBRACKET        reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    THEN            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    DO              reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    RESCUE          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    HASH_ROCKET     reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    RKEY            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    RPAREN          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    WHEN            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    LKEY            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    END             reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    ELSIF           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    ELSE            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    ENSURE          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    LBRACKET        reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    NOT_SYMBOL      reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    COMPLEMENT_OP   reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    DEFINED_OP      reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    NUMBER          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    LPAREN          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    UNARY_OP        reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    RETURN          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    YIELD           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    CASE            reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    FOR             reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    BEGIN           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    CLASS           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    MODULE          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    DEF             reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    VAR_GLOBAL      reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    VAR_LOCAL       reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    VAR_INSTANCE    reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    VAR_CLASS       reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    SYMBOL          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    STRING          reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    IDENTIFIER      reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    SUPER           reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! OR_SYMBOL       [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! GREATERTHAN     [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! LESSERTHAN      [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! EQUAL           [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! NOTEQUAL        [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! AND             [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! OR              [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! PLUS            [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! MINUS           [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! TIMES           [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! DIVIDE          [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! MOD             [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]
  ! POW             [ reduce using rule 63 (arg -> arg BINARY_RIGHT_SHIFT_OP arg .) ]


state 314

    (64) arg -> arg AND arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 64 (arg -> arg AND arg .)
    WHILE           reduce using rule 64 (arg -> arg AND arg .)
    UNLESS          reduce using rule 64 (arg -> arg AND arg .)
    UNTIL           reduce using rule 64 (arg -> arg AND arg .)
    TERM            reduce using rule 64 (arg -> arg AND arg .)
    $end            reduce using rule 64 (arg -> arg AND arg .)
    COMMA           reduce using rule 64 (arg -> arg AND arg .)
    RBRACKET        reduce using rule 64 (arg -> arg AND arg .)
    THEN            reduce using rule 64 (arg -> arg AND arg .)
    DO              reduce using rule 64 (arg -> arg AND arg .)
    RESCUE          reduce using rule 64 (arg -> arg AND arg .)
    HASH_ROCKET     reduce using rule 64 (arg -> arg AND arg .)
    RKEY            reduce using rule 64 (arg -> arg AND arg .)
    RPAREN          reduce using rule 64 (arg -> arg AND arg .)
    WHEN            reduce using rule 64 (arg -> arg AND arg .)
    LKEY            reduce using rule 64 (arg -> arg AND arg .)
    END             reduce using rule 64 (arg -> arg AND arg .)
    ELSIF           reduce using rule 64 (arg -> arg AND arg .)
    ELSE            reduce using rule 64 (arg -> arg AND arg .)
    ENSURE          reduce using rule 64 (arg -> arg AND arg .)
    LBRACKET        reduce using rule 64 (arg -> arg AND arg .)
    NOT_SYMBOL      reduce using rule 64 (arg -> arg AND arg .)
    COMPLEMENT_OP   reduce using rule 64 (arg -> arg AND arg .)
    DEFINED_OP      reduce using rule 64 (arg -> arg AND arg .)
    NUMBER          reduce using rule 64 (arg -> arg AND arg .)
    LPAREN          reduce using rule 64 (arg -> arg AND arg .)
    UNARY_OP        reduce using rule 64 (arg -> arg AND arg .)
    RETURN          reduce using rule 64 (arg -> arg AND arg .)
    YIELD           reduce using rule 64 (arg -> arg AND arg .)
    CASE            reduce using rule 64 (arg -> arg AND arg .)
    FOR             reduce using rule 64 (arg -> arg AND arg .)
    BEGIN           reduce using rule 64 (arg -> arg AND arg .)
    CLASS           reduce using rule 64 (arg -> arg AND arg .)
    MODULE          reduce using rule 64 (arg -> arg AND arg .)
    DEF             reduce using rule 64 (arg -> arg AND arg .)
    VAR_GLOBAL      reduce using rule 64 (arg -> arg AND arg .)
    VAR_LOCAL       reduce using rule 64 (arg -> arg AND arg .)
    VAR_INSTANCE    reduce using rule 64 (arg -> arg AND arg .)
    VAR_CLASS       reduce using rule 64 (arg -> arg AND arg .)
    SYMBOL          reduce using rule 64 (arg -> arg AND arg .)
    STRING          reduce using rule 64 (arg -> arg AND arg .)
    IDENTIFIER      reduce using rule 64 (arg -> arg AND arg .)
    SUPER           reduce using rule 64 (arg -> arg AND arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! OR_SYMBOL       [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! GREATERTHAN     [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! LESSERTHAN      [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! EQUAL           [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! NOTEQUAL        [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! AND             [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! OR              [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! PLUS            [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! MINUS           [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! TIMES           [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! DIVIDE          [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! MOD             [ reduce using rule 64 (arg -> arg AND arg .) ]
  ! POW             [ reduce using rule 64 (arg -> arg AND arg .) ]


state 315

    (65) arg -> arg OR arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 65 (arg -> arg OR arg .)
    WHILE           reduce using rule 65 (arg -> arg OR arg .)
    UNLESS          reduce using rule 65 (arg -> arg OR arg .)
    UNTIL           reduce using rule 65 (arg -> arg OR arg .)
    TERM            reduce using rule 65 (arg -> arg OR arg .)
    $end            reduce using rule 65 (arg -> arg OR arg .)
    COMMA           reduce using rule 65 (arg -> arg OR arg .)
    RBRACKET        reduce using rule 65 (arg -> arg OR arg .)
    THEN            reduce using rule 65 (arg -> arg OR arg .)
    DO              reduce using rule 65 (arg -> arg OR arg .)
    RESCUE          reduce using rule 65 (arg -> arg OR arg .)
    HASH_ROCKET     reduce using rule 65 (arg -> arg OR arg .)
    RKEY            reduce using rule 65 (arg -> arg OR arg .)
    RPAREN          reduce using rule 65 (arg -> arg OR arg .)
    WHEN            reduce using rule 65 (arg -> arg OR arg .)
    LKEY            reduce using rule 65 (arg -> arg OR arg .)
    END             reduce using rule 65 (arg -> arg OR arg .)
    ELSIF           reduce using rule 65 (arg -> arg OR arg .)
    ELSE            reduce using rule 65 (arg -> arg OR arg .)
    ENSURE          reduce using rule 65 (arg -> arg OR arg .)
    LBRACKET        reduce using rule 65 (arg -> arg OR arg .)
    NOT_SYMBOL      reduce using rule 65 (arg -> arg OR arg .)
    COMPLEMENT_OP   reduce using rule 65 (arg -> arg OR arg .)
    DEFINED_OP      reduce using rule 65 (arg -> arg OR arg .)
    NUMBER          reduce using rule 65 (arg -> arg OR arg .)
    LPAREN          reduce using rule 65 (arg -> arg OR arg .)
    UNARY_OP        reduce using rule 65 (arg -> arg OR arg .)
    RETURN          reduce using rule 65 (arg -> arg OR arg .)
    YIELD           reduce using rule 65 (arg -> arg OR arg .)
    CASE            reduce using rule 65 (arg -> arg OR arg .)
    FOR             reduce using rule 65 (arg -> arg OR arg .)
    BEGIN           reduce using rule 65 (arg -> arg OR arg .)
    CLASS           reduce using rule 65 (arg -> arg OR arg .)
    MODULE          reduce using rule 65 (arg -> arg OR arg .)
    DEF             reduce using rule 65 (arg -> arg OR arg .)
    VAR_GLOBAL      reduce using rule 65 (arg -> arg OR arg .)
    VAR_LOCAL       reduce using rule 65 (arg -> arg OR arg .)
    VAR_INSTANCE    reduce using rule 65 (arg -> arg OR arg .)
    VAR_CLASS       reduce using rule 65 (arg -> arg OR arg .)
    SYMBOL          reduce using rule 65 (arg -> arg OR arg .)
    STRING          reduce using rule 65 (arg -> arg OR arg .)
    IDENTIFIER      reduce using rule 65 (arg -> arg OR arg .)
    SUPER           reduce using rule 65 (arg -> arg OR arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! OR_SYMBOL       [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! GREATERTHAN     [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! LESSERTHAN      [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! EQUAL           [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! NOTEQUAL        [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! AND             [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! OR              [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! PLUS            [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! MINUS           [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! TIMES           [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! DIVIDE          [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! MOD             [ reduce using rule 65 (arg -> arg OR arg .) ]
  ! POW             [ reduce using rule 65 (arg -> arg OR arg .) ]


state 316

    (229) math_operations -> arg PLUS arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 229 (math_operations -> arg PLUS arg .)
    WHILE           reduce using rule 229 (math_operations -> arg PLUS arg .)
    UNLESS          reduce using rule 229 (math_operations -> arg PLUS arg .)
    UNTIL           reduce using rule 229 (math_operations -> arg PLUS arg .)
    TERM            reduce using rule 229 (math_operations -> arg PLUS arg .)
    $end            reduce using rule 229 (math_operations -> arg PLUS arg .)
    COMMA           reduce using rule 229 (math_operations -> arg PLUS arg .)
    RBRACKET        reduce using rule 229 (math_operations -> arg PLUS arg .)
    THEN            reduce using rule 229 (math_operations -> arg PLUS arg .)
    DO              reduce using rule 229 (math_operations -> arg PLUS arg .)
    RESCUE          reduce using rule 229 (math_operations -> arg PLUS arg .)
    HASH_ROCKET     reduce using rule 229 (math_operations -> arg PLUS arg .)
    RKEY            reduce using rule 229 (math_operations -> arg PLUS arg .)
    RPAREN          reduce using rule 229 (math_operations -> arg PLUS arg .)
    WHEN            reduce using rule 229 (math_operations -> arg PLUS arg .)
    LKEY            reduce using rule 229 (math_operations -> arg PLUS arg .)
    END             reduce using rule 229 (math_operations -> arg PLUS arg .)
    ELSIF           reduce using rule 229 (math_operations -> arg PLUS arg .)
    ELSE            reduce using rule 229 (math_operations -> arg PLUS arg .)
    ENSURE          reduce using rule 229 (math_operations -> arg PLUS arg .)
    LBRACKET        reduce using rule 229 (math_operations -> arg PLUS arg .)
    NOT_SYMBOL      reduce using rule 229 (math_operations -> arg PLUS arg .)
    COMPLEMENT_OP   reduce using rule 229 (math_operations -> arg PLUS arg .)
    DEFINED_OP      reduce using rule 229 (math_operations -> arg PLUS arg .)
    NUMBER          reduce using rule 229 (math_operations -> arg PLUS arg .)
    LPAREN          reduce using rule 229 (math_operations -> arg PLUS arg .)
    UNARY_OP        reduce using rule 229 (math_operations -> arg PLUS arg .)
    RETURN          reduce using rule 229 (math_operations -> arg PLUS arg .)
    YIELD           reduce using rule 229 (math_operations -> arg PLUS arg .)
    CASE            reduce using rule 229 (math_operations -> arg PLUS arg .)
    FOR             reduce using rule 229 (math_operations -> arg PLUS arg .)
    BEGIN           reduce using rule 229 (math_operations -> arg PLUS arg .)
    CLASS           reduce using rule 229 (math_operations -> arg PLUS arg .)
    MODULE          reduce using rule 229 (math_operations -> arg PLUS arg .)
    DEF             reduce using rule 229 (math_operations -> arg PLUS arg .)
    VAR_GLOBAL      reduce using rule 229 (math_operations -> arg PLUS arg .)
    VAR_LOCAL       reduce using rule 229 (math_operations -> arg PLUS arg .)
    VAR_INSTANCE    reduce using rule 229 (math_operations -> arg PLUS arg .)
    VAR_CLASS       reduce using rule 229 (math_operations -> arg PLUS arg .)
    SYMBOL          reduce using rule 229 (math_operations -> arg PLUS arg .)
    STRING          reduce using rule 229 (math_operations -> arg PLUS arg .)
    IDENTIFIER      reduce using rule 229 (math_operations -> arg PLUS arg .)
    SUPER           reduce using rule 229 (math_operations -> arg PLUS arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! OR_SYMBOL       [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! GREATERTHAN     [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! LESSERTHAN      [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! EQUAL           [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! NOTEQUAL        [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! AND             [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! OR              [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! PLUS            [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! MINUS           [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! TIMES           [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! DIVIDE          [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! MOD             [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]
  ! POW             [ reduce using rule 229 (math_operations -> arg PLUS arg .) ]


state 317

    (230) math_operations -> arg MINUS arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 230 (math_operations -> arg MINUS arg .)
    WHILE           reduce using rule 230 (math_operations -> arg MINUS arg .)
    UNLESS          reduce using rule 230 (math_operations -> arg MINUS arg .)
    UNTIL           reduce using rule 230 (math_operations -> arg MINUS arg .)
    TERM            reduce using rule 230 (math_operations -> arg MINUS arg .)
    $end            reduce using rule 230 (math_operations -> arg MINUS arg .)
    COMMA           reduce using rule 230 (math_operations -> arg MINUS arg .)
    RBRACKET        reduce using rule 230 (math_operations -> arg MINUS arg .)
    THEN            reduce using rule 230 (math_operations -> arg MINUS arg .)
    DO              reduce using rule 230 (math_operations -> arg MINUS arg .)
    RESCUE          reduce using rule 230 (math_operations -> arg MINUS arg .)
    HASH_ROCKET     reduce using rule 230 (math_operations -> arg MINUS arg .)
    RKEY            reduce using rule 230 (math_operations -> arg MINUS arg .)
    RPAREN          reduce using rule 230 (math_operations -> arg MINUS arg .)
    WHEN            reduce using rule 230 (math_operations -> arg MINUS arg .)
    LKEY            reduce using rule 230 (math_operations -> arg MINUS arg .)
    END             reduce using rule 230 (math_operations -> arg MINUS arg .)
    ELSIF           reduce using rule 230 (math_operations -> arg MINUS arg .)
    ELSE            reduce using rule 230 (math_operations -> arg MINUS arg .)
    ENSURE          reduce using rule 230 (math_operations -> arg MINUS arg .)
    LBRACKET        reduce using rule 230 (math_operations -> arg MINUS arg .)
    NOT_SYMBOL      reduce using rule 230 (math_operations -> arg MINUS arg .)
    COMPLEMENT_OP   reduce using rule 230 (math_operations -> arg MINUS arg .)
    DEFINED_OP      reduce using rule 230 (math_operations -> arg MINUS arg .)
    NUMBER          reduce using rule 230 (math_operations -> arg MINUS arg .)
    LPAREN          reduce using rule 230 (math_operations -> arg MINUS arg .)
    UNARY_OP        reduce using rule 230 (math_operations -> arg MINUS arg .)
    RETURN          reduce using rule 230 (math_operations -> arg MINUS arg .)
    YIELD           reduce using rule 230 (math_operations -> arg MINUS arg .)
    CASE            reduce using rule 230 (math_operations -> arg MINUS arg .)
    FOR             reduce using rule 230 (math_operations -> arg MINUS arg .)
    BEGIN           reduce using rule 230 (math_operations -> arg MINUS arg .)
    CLASS           reduce using rule 230 (math_operations -> arg MINUS arg .)
    MODULE          reduce using rule 230 (math_operations -> arg MINUS arg .)
    DEF             reduce using rule 230 (math_operations -> arg MINUS arg .)
    VAR_GLOBAL      reduce using rule 230 (math_operations -> arg MINUS arg .)
    VAR_LOCAL       reduce using rule 230 (math_operations -> arg MINUS arg .)
    VAR_INSTANCE    reduce using rule 230 (math_operations -> arg MINUS arg .)
    VAR_CLASS       reduce using rule 230 (math_operations -> arg MINUS arg .)
    SYMBOL          reduce using rule 230 (math_operations -> arg MINUS arg .)
    STRING          reduce using rule 230 (math_operations -> arg MINUS arg .)
    IDENTIFIER      reduce using rule 230 (math_operations -> arg MINUS arg .)
    SUPER           reduce using rule 230 (math_operations -> arg MINUS arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! OR_SYMBOL       [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! GREATERTHAN     [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! LESSERTHAN      [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! EQUAL           [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! NOTEQUAL        [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! AND             [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! OR              [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! PLUS            [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! MINUS           [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! TIMES           [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! DIVIDE          [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! MOD             [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]
  ! POW             [ reduce using rule 230 (math_operations -> arg MINUS arg .) ]


state 318

    (231) math_operations -> arg TIMES arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 231 (math_operations -> arg TIMES arg .)
    WHILE           reduce using rule 231 (math_operations -> arg TIMES arg .)
    UNLESS          reduce using rule 231 (math_operations -> arg TIMES arg .)
    UNTIL           reduce using rule 231 (math_operations -> arg TIMES arg .)
    TERM            reduce using rule 231 (math_operations -> arg TIMES arg .)
    $end            reduce using rule 231 (math_operations -> arg TIMES arg .)
    COMMA           reduce using rule 231 (math_operations -> arg TIMES arg .)
    RBRACKET        reduce using rule 231 (math_operations -> arg TIMES arg .)
    THEN            reduce using rule 231 (math_operations -> arg TIMES arg .)
    DO              reduce using rule 231 (math_operations -> arg TIMES arg .)
    RESCUE          reduce using rule 231 (math_operations -> arg TIMES arg .)
    HASH_ROCKET     reduce using rule 231 (math_operations -> arg TIMES arg .)
    RKEY            reduce using rule 231 (math_operations -> arg TIMES arg .)
    RPAREN          reduce using rule 231 (math_operations -> arg TIMES arg .)
    WHEN            reduce using rule 231 (math_operations -> arg TIMES arg .)
    LKEY            reduce using rule 231 (math_operations -> arg TIMES arg .)
    END             reduce using rule 231 (math_operations -> arg TIMES arg .)
    ELSIF           reduce using rule 231 (math_operations -> arg TIMES arg .)
    ELSE            reduce using rule 231 (math_operations -> arg TIMES arg .)
    ENSURE          reduce using rule 231 (math_operations -> arg TIMES arg .)
    LBRACKET        reduce using rule 231 (math_operations -> arg TIMES arg .)
    NOT_SYMBOL      reduce using rule 231 (math_operations -> arg TIMES arg .)
    COMPLEMENT_OP   reduce using rule 231 (math_operations -> arg TIMES arg .)
    DEFINED_OP      reduce using rule 231 (math_operations -> arg TIMES arg .)
    NUMBER          reduce using rule 231 (math_operations -> arg TIMES arg .)
    LPAREN          reduce using rule 231 (math_operations -> arg TIMES arg .)
    UNARY_OP        reduce using rule 231 (math_operations -> arg TIMES arg .)
    RETURN          reduce using rule 231 (math_operations -> arg TIMES arg .)
    YIELD           reduce using rule 231 (math_operations -> arg TIMES arg .)
    CASE            reduce using rule 231 (math_operations -> arg TIMES arg .)
    FOR             reduce using rule 231 (math_operations -> arg TIMES arg .)
    BEGIN           reduce using rule 231 (math_operations -> arg TIMES arg .)
    CLASS           reduce using rule 231 (math_operations -> arg TIMES arg .)
    MODULE          reduce using rule 231 (math_operations -> arg TIMES arg .)
    DEF             reduce using rule 231 (math_operations -> arg TIMES arg .)
    VAR_GLOBAL      reduce using rule 231 (math_operations -> arg TIMES arg .)
    VAR_LOCAL       reduce using rule 231 (math_operations -> arg TIMES arg .)
    VAR_INSTANCE    reduce using rule 231 (math_operations -> arg TIMES arg .)
    VAR_CLASS       reduce using rule 231 (math_operations -> arg TIMES arg .)
    SYMBOL          reduce using rule 231 (math_operations -> arg TIMES arg .)
    STRING          reduce using rule 231 (math_operations -> arg TIMES arg .)
    IDENTIFIER      reduce using rule 231 (math_operations -> arg TIMES arg .)
    SUPER           reduce using rule 231 (math_operations -> arg TIMES arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! OR_SYMBOL       [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! GREATERTHAN     [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! LESSERTHAN      [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! EQUAL           [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! NOTEQUAL        [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! AND             [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! OR              [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! PLUS            [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! MINUS           [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! TIMES           [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! DIVIDE          [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! MOD             [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]
  ! POW             [ reduce using rule 231 (math_operations -> arg TIMES arg .) ]


state 319

    (232) math_operations -> arg DIVIDE arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    WHILE           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    UNLESS          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    UNTIL           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    TERM            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    $end            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    COMMA           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    RBRACKET        reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    THEN            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    DO              reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    RESCUE          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    HASH_ROCKET     reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    RKEY            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    RPAREN          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    WHEN            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    LKEY            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    END             reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    ELSIF           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    ELSE            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    ENSURE          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    LBRACKET        reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    NOT_SYMBOL      reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    COMPLEMENT_OP   reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    DEFINED_OP      reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    NUMBER          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    LPAREN          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    UNARY_OP        reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    RETURN          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    YIELD           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    CASE            reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    FOR             reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    BEGIN           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    CLASS           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    MODULE          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    DEF             reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    VAR_GLOBAL      reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    VAR_LOCAL       reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    VAR_INSTANCE    reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    VAR_CLASS       reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    SYMBOL          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    STRING          reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    IDENTIFIER      reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    SUPER           reduce using rule 232 (math_operations -> arg DIVIDE arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! OR_SYMBOL       [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! GREATERTHAN     [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! LESSERTHAN      [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! EQUAL           [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! NOTEQUAL        [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! AND             [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! OR              [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! PLUS            [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! MINUS           [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! TIMES           [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! DIVIDE          [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! MOD             [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]
  ! POW             [ reduce using rule 232 (math_operations -> arg DIVIDE arg .) ]


state 320

    (233) math_operations -> arg MOD arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 233 (math_operations -> arg MOD arg .)
    WHILE           reduce using rule 233 (math_operations -> arg MOD arg .)
    UNLESS          reduce using rule 233 (math_operations -> arg MOD arg .)
    UNTIL           reduce using rule 233 (math_operations -> arg MOD arg .)
    TERM            reduce using rule 233 (math_operations -> arg MOD arg .)
    $end            reduce using rule 233 (math_operations -> arg MOD arg .)
    COMMA           reduce using rule 233 (math_operations -> arg MOD arg .)
    RBRACKET        reduce using rule 233 (math_operations -> arg MOD arg .)
    THEN            reduce using rule 233 (math_operations -> arg MOD arg .)
    DO              reduce using rule 233 (math_operations -> arg MOD arg .)
    RESCUE          reduce using rule 233 (math_operations -> arg MOD arg .)
    HASH_ROCKET     reduce using rule 233 (math_operations -> arg MOD arg .)
    RKEY            reduce using rule 233 (math_operations -> arg MOD arg .)
    RPAREN          reduce using rule 233 (math_operations -> arg MOD arg .)
    WHEN            reduce using rule 233 (math_operations -> arg MOD arg .)
    LKEY            reduce using rule 233 (math_operations -> arg MOD arg .)
    END             reduce using rule 233 (math_operations -> arg MOD arg .)
    ELSIF           reduce using rule 233 (math_operations -> arg MOD arg .)
    ELSE            reduce using rule 233 (math_operations -> arg MOD arg .)
    ENSURE          reduce using rule 233 (math_operations -> arg MOD arg .)
    LBRACKET        reduce using rule 233 (math_operations -> arg MOD arg .)
    NOT_SYMBOL      reduce using rule 233 (math_operations -> arg MOD arg .)
    COMPLEMENT_OP   reduce using rule 233 (math_operations -> arg MOD arg .)
    DEFINED_OP      reduce using rule 233 (math_operations -> arg MOD arg .)
    NUMBER          reduce using rule 233 (math_operations -> arg MOD arg .)
    LPAREN          reduce using rule 233 (math_operations -> arg MOD arg .)
    UNARY_OP        reduce using rule 233 (math_operations -> arg MOD arg .)
    RETURN          reduce using rule 233 (math_operations -> arg MOD arg .)
    YIELD           reduce using rule 233 (math_operations -> arg MOD arg .)
    CASE            reduce using rule 233 (math_operations -> arg MOD arg .)
    FOR             reduce using rule 233 (math_operations -> arg MOD arg .)
    BEGIN           reduce using rule 233 (math_operations -> arg MOD arg .)
    CLASS           reduce using rule 233 (math_operations -> arg MOD arg .)
    MODULE          reduce using rule 233 (math_operations -> arg MOD arg .)
    DEF             reduce using rule 233 (math_operations -> arg MOD arg .)
    VAR_GLOBAL      reduce using rule 233 (math_operations -> arg MOD arg .)
    VAR_LOCAL       reduce using rule 233 (math_operations -> arg MOD arg .)
    VAR_INSTANCE    reduce using rule 233 (math_operations -> arg MOD arg .)
    VAR_CLASS       reduce using rule 233 (math_operations -> arg MOD arg .)
    SYMBOL          reduce using rule 233 (math_operations -> arg MOD arg .)
    STRING          reduce using rule 233 (math_operations -> arg MOD arg .)
    IDENTIFIER      reduce using rule 233 (math_operations -> arg MOD arg .)
    SUPER           reduce using rule 233 (math_operations -> arg MOD arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! OR_SYMBOL       [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! GREATERTHAN     [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! LESSERTHAN      [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! EQUAL           [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! NOTEQUAL        [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! AND             [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! OR              [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! PLUS            [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! MINUS           [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! TIMES           [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! DIVIDE          [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! MOD             [ reduce using rule 233 (math_operations -> arg MOD arg .) ]
  ! POW             [ reduce using rule 233 (math_operations -> arg MOD arg .) ]


state 321

    (234) math_operations -> arg POW arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for RANGE_INCLUSIVE resolved as shift
  ! shift/reduce conflict for RANGE_EXCLUSIVE resolved as shift
  ! shift/reduce conflict for OR_SYMBOL resolved as shift
  ! shift/reduce conflict for BINARY_XOR_OP resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for COMBINED_COMPARISON_OP resolved as shift
  ! shift/reduce conflict for GREATERTHAN resolved as shift
  ! shift/reduce conflict for GREATERTHANEQUAL resolved as shift
  ! shift/reduce conflict for LESSERTHAN resolved as shift
  ! shift/reduce conflict for LESSERTHANEQUAL resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for CASE_EQUALITY resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP resolved as shift
  ! shift/reduce conflict for BINARY_LEFT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for BINARY_RIGHT_SHIFT_OP resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for POW resolved as shift
    IF              reduce using rule 234 (math_operations -> arg POW arg .)
    WHILE           reduce using rule 234 (math_operations -> arg POW arg .)
    UNLESS          reduce using rule 234 (math_operations -> arg POW arg .)
    UNTIL           reduce using rule 234 (math_operations -> arg POW arg .)
    TERM            reduce using rule 234 (math_operations -> arg POW arg .)
    $end            reduce using rule 234 (math_operations -> arg POW arg .)
    COMMA           reduce using rule 234 (math_operations -> arg POW arg .)
    RBRACKET        reduce using rule 234 (math_operations -> arg POW arg .)
    THEN            reduce using rule 234 (math_operations -> arg POW arg .)
    DO              reduce using rule 234 (math_operations -> arg POW arg .)
    RESCUE          reduce using rule 234 (math_operations -> arg POW arg .)
    HASH_ROCKET     reduce using rule 234 (math_operations -> arg POW arg .)
    RKEY            reduce using rule 234 (math_operations -> arg POW arg .)
    RPAREN          reduce using rule 234 (math_operations -> arg POW arg .)
    WHEN            reduce using rule 234 (math_operations -> arg POW arg .)
    LKEY            reduce using rule 234 (math_operations -> arg POW arg .)
    END             reduce using rule 234 (math_operations -> arg POW arg .)
    ELSIF           reduce using rule 234 (math_operations -> arg POW arg .)
    ELSE            reduce using rule 234 (math_operations -> arg POW arg .)
    ENSURE          reduce using rule 234 (math_operations -> arg POW arg .)
    LBRACKET        reduce using rule 234 (math_operations -> arg POW arg .)
    NOT_SYMBOL      reduce using rule 234 (math_operations -> arg POW arg .)
    COMPLEMENT_OP   reduce using rule 234 (math_operations -> arg POW arg .)
    DEFINED_OP      reduce using rule 234 (math_operations -> arg POW arg .)
    NUMBER          reduce using rule 234 (math_operations -> arg POW arg .)
    LPAREN          reduce using rule 234 (math_operations -> arg POW arg .)
    UNARY_OP        reduce using rule 234 (math_operations -> arg POW arg .)
    RETURN          reduce using rule 234 (math_operations -> arg POW arg .)
    YIELD           reduce using rule 234 (math_operations -> arg POW arg .)
    CASE            reduce using rule 234 (math_operations -> arg POW arg .)
    FOR             reduce using rule 234 (math_operations -> arg POW arg .)
    BEGIN           reduce using rule 234 (math_operations -> arg POW arg .)
    CLASS           reduce using rule 234 (math_operations -> arg POW arg .)
    MODULE          reduce using rule 234 (math_operations -> arg POW arg .)
    DEF             reduce using rule 234 (math_operations -> arg POW arg .)
    VAR_GLOBAL      reduce using rule 234 (math_operations -> arg POW arg .)
    VAR_LOCAL       reduce using rule 234 (math_operations -> arg POW arg .)
    VAR_INSTANCE    reduce using rule 234 (math_operations -> arg POW arg .)
    VAR_CLASS       reduce using rule 234 (math_operations -> arg POW arg .)
    SYMBOL          reduce using rule 234 (math_operations -> arg POW arg .)
    STRING          reduce using rule 234 (math_operations -> arg POW arg .)
    IDENTIFIER      reduce using rule 234 (math_operations -> arg POW arg .)
    SUPER           reduce using rule 234 (math_operations -> arg POW arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! RANGE_INCLUSIVE [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! RANGE_EXCLUSIVE [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! OR_SYMBOL       [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! BINARY_XOR_OP   [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! BINARY_AND_OP   [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! COMBINED_COMPARISON_OP [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! GREATERTHAN     [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! GREATERTHANEQUAL [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! LESSERTHAN      [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! LESSERTHANEQUAL [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! EQUAL           [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! CASE_EQUALITY   [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! NOTEQUAL        [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! MATCHED_STRINGS_OP [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! OPPOSITE_MATCHED_STRINGS_OP [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! BINARY_LEFT_SHIFT_OP [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! BINARY_RIGHT_SHIFT_OP [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! AND             [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! OR              [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! PLUS            [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! MINUS           [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! TIMES           [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! DIVIDE          [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! MOD             [ reduce using rule 234 (math_operations -> arg POW arg .) ]
  ! POW             [ reduce using rule 234 (math_operations -> arg POW arg .) ]


state 322

    (33) function -> operation LBRACKET LPAREN . LBRACKET call_args RBRACKET RPAREN RBRACKET
    (72) primary -> LPAREN . compstmt RPAREN
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 409
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    operation                      shift and go to state 28
    compstmt                       shift and go to state 192
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 323

    (72) primary -> LPAREN compstmt RPAREN .

    LBRACKET        reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    DOT             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    UNARY_OP        reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RANGE_INCLUSIVE reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    OR_SYMBOL       reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    BINARY_XOR_OP   reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    BINARY_AND_OP   reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    GREATERTHAN     reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    GREATERTHANEQUAL reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    LESSERTHAN      reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    LESSERTHANEQUAL reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    EQUAL           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    CASE_EQUALITY   reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    NOTEQUAL        reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    AND             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    OR              reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    PLUS            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    MINUS           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    TIMES           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    DIVIDE          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    MOD             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    POW             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    IF              reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    WHILE           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    UNLESS          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    UNTIL           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    TERM            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    $end            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    COMMA           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RBRACKET        reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    THEN            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    DO              reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RESCUE          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    HASH_ROCKET     reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RKEY            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RPAREN          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    WHEN            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    LKEY            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    END             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    ELSIF           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    ELSE            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    ENSURE          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    NOT_SYMBOL      reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    COMPLEMENT_OP   reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    DEFINED_OP      reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    NUMBER          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    LPAREN          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    RETURN          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    YIELD           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    CASE            reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    FOR             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    BEGIN           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    CLASS           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    MODULE          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    DEF             reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    VAR_GLOBAL      reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    VAR_LOCAL       reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    VAR_INSTANCE    reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    VAR_CLASS       reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    SYMBOL          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    STRING          reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    IDENTIFIER      reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)
    SUPER           reduce using rule 72 (primary -> LPAREN compstmt RPAREN .)


state 324

    (154) mlhs_item -> LPAREN mlhs RPAREN .

    COMMA           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    TIMES           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    VAR_GLOBAL      reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    VAR_LOCAL       reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    VAR_INSTANCE    reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    VAR_CLASS       reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    LPAREN          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    UNARY_OP        reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    LBRACKET        reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    LKEY            reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    RETURN          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    YIELD           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    DEFINED_OP      reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    IF              reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    UNLESS          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    WHILE           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    UNTIL           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    CASE            reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    FOR             reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    BEGIN           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    CLASS           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    MODULE          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    DEF             reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    NUMBER          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    SYMBOL          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    STRING          reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    IDENTIFIER      reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)
    SUPER           reduce using rule 154 (mlhs_item -> LPAREN mlhs RPAREN .)


state 325

    (38) function -> SUPER LPAREN call_args . RPAREN

    RPAREN          shift and go to state 410


state 326

    (93) primary -> DEFINED_OP LPAREN arg . LPAREN
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg
    (26) expr -> arg .

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    LPAREN          shift and go to state 411
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189
    IF              reduce using rule 26 (expr -> arg .)
    WHILE           reduce using rule 26 (expr -> arg .)
    UNLESS          reduce using rule 26 (expr -> arg .)
    UNTIL           reduce using rule 26 (expr -> arg .)
    TERM            reduce using rule 26 (expr -> arg .)
    RPAREN          reduce using rule 26 (expr -> arg .)

  ! AND             [ reduce using rule 26 (expr -> arg .) ]
  ! OR              [ reduce using rule 26 (expr -> arg .) ]


state 327

    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (16) stmt -> lhs . = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (153) mlhs_item -> lhs .
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

    =               shift and go to state 412
    COMMA           reduce using rule 153 (mlhs_item -> lhs .)
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

    op_asgn                        shift and go to state 132

state 328

    (79) primary -> LBRACKET . RBRACKET
    (80) primary -> LBRACKET . args RBRACKET
    (81) primary -> LBRACKET . args COMMA RBRACKET
    (6) stmt -> LBRACKET . block_var RBRACKET
    (7) stmt -> LBRACKET . OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    RBRACKET        shift and go to state 65
    OR_SYMBOL       shift and go to state 66
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    TIMES           shift and go to state 44
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    args                           shift and go to state 67
    block_var                      shift and go to state 64
    arg                            shift and go to state 70
    lhs                            shift and go to state 68
    mlhs                           shift and go to state 69
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    mlhs_item                      shift and go to state 43
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 329

    (108) primary -> BEGIN . compstmt rescue END
    (109) primary -> BEGIN . compstmt rescue ELSE compstmt END
    (110) primary -> BEGIN . compstmt rescue ENSURE compstmt END
    (111) primary -> BEGIN . compstmt rescue ELSE compstmt ENSURE compstmt END
    (14) stmt -> BEGIN . LKEY compstmt RKEY
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LKEY            shift and go to state 121
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 122
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 330

    (105) primary -> CASE compstmt when . END
    (106) primary -> CASE compstmt when . ELSE compstmt END
    (121) when -> when . WHEN when_args then compstmt

    END             shift and go to state 413
    ELSE            shift and go to state 414
    WHEN            shift and go to state 415


state 331

    (120) when -> WHEN . when_args then compstmt
    (126) when_args -> . args
    (127) when_args -> . args COMMA TIMES arg
    (128) when_args -> . TIMES arg
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 418
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    when_args                      shift and go to state 416
    args                           shift and go to state 417
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 332

    (107) primary -> FOR block_var IN . expr do compstmt END
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 419
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 333

    (93) primary -> DEFINED_OP LPAREN . arg LPAREN
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 420
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 334

    (112) primary -> CLASS IDENTIFIER compstmt . END

    END             shift and go to state 421


state 335

    (113) primary -> CLASS IDENTIFIER LESSERTHAN . IDENTIFIER compstmt END

    IDENTIFIER      shift and go to state 422


state 336

    (114) primary -> MODULE IDENTIFIER compstmt . END

    END             shift and go to state 423


state 337

    (115) primary -> DEF fname argdecl . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 424
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 338

    (157) argdecl -> LPAREN . arglist RPAREN
    (159) arglist -> . IDENTIFIER
    (160) arglist -> . IDENTIFIER COMMA IDENTIFIER
    (161) arglist -> . IDENTIFIER COMMA & IDENTIFIER

    IDENTIFIER      shift and go to state 340

    arglist                        shift and go to state 425

state 339

    (158) argdecl -> arglist . term
    (135) term -> . TERM

    TERM            shift and go to state 57

    term                           shift and go to state 426

state 340

    (159) arglist -> IDENTIFIER .
    (160) arglist -> IDENTIFIER . COMMA IDENTIFIER
    (161) arglist -> IDENTIFIER . COMMA & IDENTIFIER

    TERM            reduce using rule 159 (arglist -> IDENTIFIER .)
    RPAREN          reduce using rule 159 (arglist -> IDENTIFIER .)
    COMMA           shift and go to state 427


state 341

    (116) primary -> DEF singleton DOT . fname argdecl compstmt END
    (187) fname -> . IDENTIFIER
    (188) fname -> . RANGE_INCLUSIVE
    (189) fname -> . OR_SYMBOL
    (190) fname -> . BINARY_AND_OP
    (191) fname -> . BINARY_XOR_OP
    (192) fname -> . COMBINED_COMPARISON_OP
    (193) fname -> . EQUAL
    (194) fname -> . CASE_EQUALITY
    (195) fname -> . MATCHED_STRINGS_OP
    (196) fname -> . GREATERTHAN
    (197) fname -> . GREATERTHANEQUAL
    (198) fname -> . LESSERTHAN
    (199) fname -> . LESSERTHANEQUAL
    (200) fname -> . PLUS
    (201) fname -> . MINUS
    (202) fname -> . TIMES
    (203) fname -> . DIVIDE
    (204) fname -> . MOD
    (205) fname -> . POW
    (206) fname -> . BINARY_RIGHT_SHIFT_OP
    (207) fname -> . BINARY_LEFT_SHIFT_OP
    (208) fname -> . COMPLEMENT_OP
    (209) fname -> . OVERLOAD_PLUS
    (210) fname -> . OVERLOAD_MINUS
    (211) fname -> . LBRACKET RBRACKET
    (212) fname -> . LBRACKET RBRACKET EQUAL_SYMBOL

    IDENTIFIER      shift and go to state 84
    RANGE_INCLUSIVE shift and go to state 85
    OR_SYMBOL       shift and go to state 86
    BINARY_AND_OP   shift and go to state 87
    BINARY_XOR_OP   shift and go to state 88
    COMBINED_COMPARISON_OP shift and go to state 89
    EQUAL           shift and go to state 90
    CASE_EQUALITY   shift and go to state 91
    MATCHED_STRINGS_OP shift and go to state 92
    GREATERTHAN     shift and go to state 93
    GREATERTHANEQUAL shift and go to state 94
    LESSERTHAN      shift and go to state 95
    LESSERTHANEQUAL shift and go to state 96
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 100
    MOD             shift and go to state 101
    POW             shift and go to state 102
    BINARY_RIGHT_SHIFT_OP shift and go to state 103
    BINARY_LEFT_SHIFT_OP shift and go to state 104
    COMPLEMENT_OP   shift and go to state 105
    OVERLOAD_PLUS   shift and go to state 106
    OVERLOAD_MINUS  shift and go to state 107
    LBRACKET        shift and go to state 108

    fname                          shift and go to state 428

state 342

    (117) primary -> DEF singleton UNARY_OP . fname argdecl compstmt END
    (187) fname -> . IDENTIFIER
    (188) fname -> . RANGE_INCLUSIVE
    (189) fname -> . OR_SYMBOL
    (190) fname -> . BINARY_AND_OP
    (191) fname -> . BINARY_XOR_OP
    (192) fname -> . COMBINED_COMPARISON_OP
    (193) fname -> . EQUAL
    (194) fname -> . CASE_EQUALITY
    (195) fname -> . MATCHED_STRINGS_OP
    (196) fname -> . GREATERTHAN
    (197) fname -> . GREATERTHANEQUAL
    (198) fname -> . LESSERTHAN
    (199) fname -> . LESSERTHANEQUAL
    (200) fname -> . PLUS
    (201) fname -> . MINUS
    (202) fname -> . TIMES
    (203) fname -> . DIVIDE
    (204) fname -> . MOD
    (205) fname -> . POW
    (206) fname -> . BINARY_RIGHT_SHIFT_OP
    (207) fname -> . BINARY_LEFT_SHIFT_OP
    (208) fname -> . COMPLEMENT_OP
    (209) fname -> . OVERLOAD_PLUS
    (210) fname -> . OVERLOAD_MINUS
    (211) fname -> . LBRACKET RBRACKET
    (212) fname -> . LBRACKET RBRACKET EQUAL_SYMBOL

    IDENTIFIER      shift and go to state 84
    RANGE_INCLUSIVE shift and go to state 85
    OR_SYMBOL       shift and go to state 86
    BINARY_AND_OP   shift and go to state 87
    BINARY_XOR_OP   shift and go to state 88
    COMBINED_COMPARISON_OP shift and go to state 89
    EQUAL           shift and go to state 90
    CASE_EQUALITY   shift and go to state 91
    MATCHED_STRINGS_OP shift and go to state 92
    GREATERTHAN     shift and go to state 93
    GREATERTHANEQUAL shift and go to state 94
    LESSERTHAN      shift and go to state 95
    LESSERTHANEQUAL shift and go to state 96
    PLUS            shift and go to state 97
    MINUS           shift and go to state 98
    TIMES           shift and go to state 99
    DIVIDE          shift and go to state 100
    MOD             shift and go to state 101
    POW             shift and go to state 102
    BINARY_RIGHT_SHIFT_OP shift and go to state 103
    BINARY_LEFT_SHIFT_OP shift and go to state 104
    COMPLEMENT_OP   shift and go to state 105
    OVERLOAD_PLUS   shift and go to state 106
    OVERLOAD_MINUS  shift and go to state 107
    LBRACKET        shift and go to state 108

    fname                          shift and go to state 429

state 343

    (163) singleton -> LPAREN expr . RPAREN
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr

    RPAREN          shift and go to state 430
    AND             shift and go to state 58
    OR              shift and go to state 59


state 344

    (147) mlhs -> mlhs_item COMMA mlhs_item . TIMES
    (148) mlhs -> mlhs_item COMMA mlhs_item . lhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 431
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    lhs                            shift and go to state 432
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 345

    (152) mult_mlhs_item -> COMMA . mlhs_item
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    LPAREN          shift and go to state 116
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    mlhs_item                      shift and go to state 433
    lhs                            shift and go to state 346
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 346

    (153) mlhs_item -> lhs .

    TIMES           reduce using rule 153 (mlhs_item -> lhs .)
    VAR_GLOBAL      reduce using rule 153 (mlhs_item -> lhs .)
    VAR_LOCAL       reduce using rule 153 (mlhs_item -> lhs .)
    VAR_INSTANCE    reduce using rule 153 (mlhs_item -> lhs .)
    VAR_CLASS       reduce using rule 153 (mlhs_item -> lhs .)
    LPAREN          reduce using rule 153 (mlhs_item -> lhs .)
    UNARY_OP        reduce using rule 153 (mlhs_item -> lhs .)
    LBRACKET        reduce using rule 153 (mlhs_item -> lhs .)
    LKEY            reduce using rule 153 (mlhs_item -> lhs .)
    RETURN          reduce using rule 153 (mlhs_item -> lhs .)
    YIELD           reduce using rule 153 (mlhs_item -> lhs .)
    DEFINED_OP      reduce using rule 153 (mlhs_item -> lhs .)
    IF              reduce using rule 153 (mlhs_item -> lhs .)
    UNLESS          reduce using rule 153 (mlhs_item -> lhs .)
    WHILE           reduce using rule 153 (mlhs_item -> lhs .)
    UNTIL           reduce using rule 153 (mlhs_item -> lhs .)
    CASE            reduce using rule 153 (mlhs_item -> lhs .)
    FOR             reduce using rule 153 (mlhs_item -> lhs .)
    BEGIN           reduce using rule 153 (mlhs_item -> lhs .)
    CLASS           reduce using rule 153 (mlhs_item -> lhs .)
    MODULE          reduce using rule 153 (mlhs_item -> lhs .)
    DEF             reduce using rule 153 (mlhs_item -> lhs .)
    NUMBER          reduce using rule 153 (mlhs_item -> lhs .)
    SYMBOL          reduce using rule 153 (mlhs_item -> lhs .)
    STRING          reduce using rule 153 (mlhs_item -> lhs .)
    IDENTIFIER      reduce using rule 153 (mlhs_item -> lhs .)
    SUPER           reduce using rule 153 (mlhs_item -> lhs .)


state 347

    (149) mlhs -> mlhs_item COMMA mult_mlhs_item . TIMES
    (150) mlhs -> mlhs_item COMMA mult_mlhs_item . lhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 434
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    lhs                            shift and go to state 435
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 348

    (235) math_operations -> NUMBER PLUS NUMBER .

    RANGE_INCLUSIVE reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    OR_SYMBOL       reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    BINARY_XOR_OP   reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    BINARY_AND_OP   reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    GREATERTHAN     reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    GREATERTHANEQUAL reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    LESSERTHAN      reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    LESSERTHANEQUAL reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    EQUAL           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    CASE_EQUALITY   reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    NOTEQUAL        reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    AND             reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    OR              reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    PLUS            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    MINUS           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    TIMES           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    DIVIDE          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    MOD             reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    POW             reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    IF              reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    WHILE           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    UNLESS          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    UNTIL           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    TERM            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    $end            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    COMMA           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    RBRACKET        reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    THEN            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    DO              reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    RESCUE          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    HASH_ROCKET     reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    RKEY            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    RPAREN          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    WHEN            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    LKEY            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    END             reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    ELSIF           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    ELSE            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    ENSURE          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    LBRACKET        reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    NOT_SYMBOL      reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    COMPLEMENT_OP   reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    DEFINED_OP      reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    NUMBER          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    LPAREN          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    UNARY_OP        reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    RETURN          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    YIELD           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    CASE            reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    FOR             reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    BEGIN           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    CLASS           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    MODULE          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    DEF             reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    VAR_GLOBAL      reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    VAR_LOCAL       reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    VAR_INSTANCE    reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    VAR_CLASS       reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    SYMBOL          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    STRING          reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    IDENTIFIER      reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)
    SUPER           reduce using rule 235 (math_operations -> NUMBER PLUS NUMBER .)


state 349

    (236) math_operations -> NUMBER MINUS NUMBER .

    RANGE_INCLUSIVE reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    OR_SYMBOL       reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    BINARY_XOR_OP   reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    BINARY_AND_OP   reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    GREATERTHAN     reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    GREATERTHANEQUAL reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    LESSERTHAN      reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    LESSERTHANEQUAL reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    EQUAL           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    CASE_EQUALITY   reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    NOTEQUAL        reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    AND             reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    OR              reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    PLUS            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    MINUS           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    TIMES           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    DIVIDE          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    MOD             reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    POW             reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    IF              reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    WHILE           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    UNLESS          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    UNTIL           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    TERM            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    $end            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    COMMA           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    RBRACKET        reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    THEN            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    DO              reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    RESCUE          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    HASH_ROCKET     reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    RKEY            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    RPAREN          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    WHEN            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    LKEY            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    END             reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    ELSIF           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    ELSE            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    ENSURE          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    LBRACKET        reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    NOT_SYMBOL      reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    COMPLEMENT_OP   reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    DEFINED_OP      reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    NUMBER          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    LPAREN          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    UNARY_OP        reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    RETURN          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    YIELD           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    CASE            reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    FOR             reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    BEGIN           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    CLASS           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    MODULE          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    DEF             reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    VAR_GLOBAL      reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    VAR_LOCAL       reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    VAR_INSTANCE    reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    VAR_CLASS       reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    SYMBOL          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    STRING          reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    IDENTIFIER      reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)
    SUPER           reduce using rule 236 (math_operations -> NUMBER MINUS NUMBER .)


state 350

    (237) math_operations -> NUMBER TIMES NUMBER .

    RANGE_INCLUSIVE reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    OR_SYMBOL       reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    BINARY_XOR_OP   reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    BINARY_AND_OP   reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    GREATERTHAN     reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    GREATERTHANEQUAL reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    LESSERTHAN      reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    LESSERTHANEQUAL reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    EQUAL           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    CASE_EQUALITY   reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    NOTEQUAL        reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    AND             reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    OR              reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    PLUS            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    MINUS           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    TIMES           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    DIVIDE          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    MOD             reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    POW             reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    IF              reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    WHILE           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    UNLESS          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    UNTIL           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    TERM            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    $end            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    COMMA           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    RBRACKET        reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    THEN            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    DO              reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    RESCUE          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    HASH_ROCKET     reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    RKEY            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    RPAREN          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    WHEN            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    LKEY            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    END             reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    ELSIF           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    ELSE            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    ENSURE          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    LBRACKET        reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    NOT_SYMBOL      reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    COMPLEMENT_OP   reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    DEFINED_OP      reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    NUMBER          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    LPAREN          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    UNARY_OP        reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    RETURN          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    YIELD           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    CASE            reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    FOR             reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    BEGIN           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    CLASS           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    MODULE          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    DEF             reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    VAR_GLOBAL      reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    VAR_LOCAL       reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    VAR_INSTANCE    reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    VAR_CLASS       reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    SYMBOL          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    STRING          reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    IDENTIFIER      reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)
    SUPER           reduce using rule 237 (math_operations -> NUMBER TIMES NUMBER .)


state 351

    (238) math_operations -> NUMBER DIVIDE NUMBER .

    RANGE_INCLUSIVE reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    OR_SYMBOL       reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    BINARY_XOR_OP   reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    BINARY_AND_OP   reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    GREATERTHAN     reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    GREATERTHANEQUAL reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    LESSERTHAN      reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    LESSERTHANEQUAL reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    EQUAL           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    CASE_EQUALITY   reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    NOTEQUAL        reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    AND             reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    OR              reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    PLUS            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    MINUS           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    TIMES           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    DIVIDE          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    MOD             reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    POW             reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    IF              reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    WHILE           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    UNLESS          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    UNTIL           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    TERM            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    $end            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    COMMA           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    RBRACKET        reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    THEN            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    DO              reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    RESCUE          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    HASH_ROCKET     reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    RKEY            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    RPAREN          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    WHEN            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    LKEY            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    END             reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    ELSIF           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    ELSE            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    ENSURE          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    LBRACKET        reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    NOT_SYMBOL      reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    COMPLEMENT_OP   reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    DEFINED_OP      reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    NUMBER          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    LPAREN          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    UNARY_OP        reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    RETURN          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    YIELD           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    CASE            reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    FOR             reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    BEGIN           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    CLASS           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    MODULE          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    DEF             reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    VAR_GLOBAL      reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    VAR_LOCAL       reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    VAR_INSTANCE    reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    VAR_CLASS       reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    SYMBOL          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    STRING          reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    IDENTIFIER      reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)
    SUPER           reduce using rule 238 (math_operations -> NUMBER DIVIDE NUMBER .)


state 352

    (239) math_operations -> NUMBER MOD NUMBER .

    RANGE_INCLUSIVE reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    OR_SYMBOL       reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    BINARY_XOR_OP   reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    BINARY_AND_OP   reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    GREATERTHAN     reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    GREATERTHANEQUAL reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    LESSERTHAN      reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    LESSERTHANEQUAL reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    EQUAL           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    CASE_EQUALITY   reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    NOTEQUAL        reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    AND             reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    OR              reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    PLUS            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    MINUS           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    TIMES           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    DIVIDE          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    MOD             reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    POW             reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    IF              reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    WHILE           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    UNLESS          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    UNTIL           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    TERM            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    $end            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    COMMA           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    RBRACKET        reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    THEN            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    DO              reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    RESCUE          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    HASH_ROCKET     reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    RKEY            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    RPAREN          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    WHEN            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    LKEY            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    END             reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    ELSIF           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    ELSE            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    ENSURE          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    LBRACKET        reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    NOT_SYMBOL      reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    COMPLEMENT_OP   reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    DEFINED_OP      reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    NUMBER          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    LPAREN          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    UNARY_OP        reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    RETURN          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    YIELD           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    CASE            reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    FOR             reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    BEGIN           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    CLASS           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    MODULE          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    DEF             reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    VAR_GLOBAL      reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    VAR_LOCAL       reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    VAR_INSTANCE    reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    VAR_CLASS       reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    SYMBOL          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    STRING          reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    IDENTIFIER      reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)
    SUPER           reduce using rule 239 (math_operations -> NUMBER MOD NUMBER .)


state 353

    (240) math_operations -> NUMBER POW NUMBER .

    RANGE_INCLUSIVE reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    RANGE_EXCLUSIVE reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    OR_SYMBOL       reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    BINARY_XOR_OP   reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    BINARY_AND_OP   reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    COMBINED_COMPARISON_OP reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    GREATERTHAN     reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    GREATERTHANEQUAL reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    LESSERTHAN      reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    LESSERTHANEQUAL reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    EQUAL           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    CASE_EQUALITY   reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    NOTEQUAL        reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    MATCHED_STRINGS_OP reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    BINARY_LEFT_SHIFT_OP reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    AND             reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    OR              reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    PLUS            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    MINUS           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    TIMES           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    DIVIDE          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    MOD             reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    POW             reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    IF              reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    WHILE           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    UNLESS          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    UNTIL           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    TERM            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    $end            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    COMMA           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    RBRACKET        reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    THEN            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    DO              reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    RESCUE          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    HASH_ROCKET     reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    RKEY            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    RPAREN          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    WHEN            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    LKEY            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    END             reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    ELSIF           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    ELSE            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    ENSURE          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    LBRACKET        reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    NOT_SYMBOL      reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    COMPLEMENT_OP   reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    DEFINED_OP      reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    NUMBER          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    LPAREN          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    UNARY_OP        reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    RETURN          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    YIELD           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    CASE            reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    FOR             reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    BEGIN           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    CLASS           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    MODULE          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    DEF             reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    VAR_GLOBAL      reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    VAR_LOCAL       reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    VAR_INSTANCE    reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    VAR_CLASS       reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    SYMBOL          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    STRING          reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    IDENTIFIER      reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)
    SUPER           reduce using rule 240 (math_operations -> NUMBER POW NUMBER .)


state 354

    (4) compstmt -> stmt term expr term .

    $end            reduce using rule 4 (compstmt -> stmt term expr term .)
    RESCUE          reduce using rule 4 (compstmt -> stmt term expr term .)
    RPAREN          reduce using rule 4 (compstmt -> stmt term expr term .)
    WHEN            reduce using rule 4 (compstmt -> stmt term expr term .)
    RKEY            reduce using rule 4 (compstmt -> stmt term expr term .)
    LKEY            reduce using rule 4 (compstmt -> stmt term expr term .)
    END             reduce using rule 4 (compstmt -> stmt term expr term .)
    ELSIF           reduce using rule 4 (compstmt -> stmt term expr term .)
    ELSE            reduce using rule 4 (compstmt -> stmt term expr term .)
    ENSURE          reduce using rule 4 (compstmt -> stmt term expr term .)


state 355

    (5) stmt -> call do LBRACKET RBRACKET .

    IF              reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    WHILE           reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    UNLESS          reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    UNTIL           reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    TERM            reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    $end            reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    RESCUE          reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    RPAREN          reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    WHEN            reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    RKEY            reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    LKEY            reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    END             reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    ELSIF           reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    ELSE            reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)
    ENSURE          reduce using rule 5 (stmt -> call do LBRACKET RBRACKET .)


state 356

    (7) stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL . RBRACKET compstmt END

    RBRACKET        shift and go to state 436


state 357

    (81) primary -> LBRACKET args COMMA RBRACKET .

    LBRACKET        reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    DOT             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    UNARY_OP        reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    OR_SYMBOL       reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    BINARY_XOR_OP   reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    BINARY_AND_OP   reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    GREATERTHAN     reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    GREATERTHANEQUAL reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    LESSERTHAN      reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    LESSERTHANEQUAL reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    EQUAL           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    CASE_EQUALITY   reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    NOTEQUAL        reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    AND             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    OR              reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    PLUS            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    MINUS           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    TIMES           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    DIVIDE          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    MOD             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    POW             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    IF              reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    WHILE           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    UNLESS          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    UNTIL           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    TERM            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    $end            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    COMMA           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RBRACKET        reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    THEN            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    DO              reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RESCUE          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    HASH_ROCKET     reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RKEY            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RPAREN          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    WHEN            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    LKEY            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    END             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    ELSIF           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    ELSE            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    ENSURE          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    NOT_SYMBOL      reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    COMPLEMENT_OP   reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    DEFINED_OP      reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    NUMBER          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    LPAREN          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    RETURN          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    YIELD           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    CASE            reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    FOR             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    BEGIN           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    CLASS           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    MODULE          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    DEF             reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    VAR_GLOBAL      reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    VAR_LOCAL       reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    VAR_INSTANCE    reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    VAR_CLASS       reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    SYMBOL          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    STRING          reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    IDENTIFIER      reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)
    SUPER           reduce using rule 81 (primary -> LBRACKET args COMMA RBRACKET .)


state 358

    (156) args -> arg COMMA arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
    RBRACKET        reduce using rule 156 (args -> arg COMMA arg .)
    COMMA           reduce using rule 156 (args -> arg COMMA arg .)
    RKEY            reduce using rule 156 (args -> arg COMMA arg .)
    IF              reduce using rule 156 (args -> arg COMMA arg .)
    WHILE           reduce using rule 156 (args -> arg COMMA arg .)
    UNLESS          reduce using rule 156 (args -> arg COMMA arg .)
    UNTIL           reduce using rule 156 (args -> arg COMMA arg .)
    TERM            reduce using rule 156 (args -> arg COMMA arg .)
    $end            reduce using rule 156 (args -> arg COMMA arg .)
    THEN            reduce using rule 156 (args -> arg COMMA arg .)
    DO              reduce using rule 156 (args -> arg COMMA arg .)
    RESCUE          reduce using rule 156 (args -> arg COMMA arg .)
    RPAREN          reduce using rule 156 (args -> arg COMMA arg .)
    WHEN            reduce using rule 156 (args -> arg COMMA arg .)
    LKEY            reduce using rule 156 (args -> arg COMMA arg .)
    END             reduce using rule 156 (args -> arg COMMA arg .)
    ELSIF           reduce using rule 156 (args -> arg COMMA arg .)
    ELSE            reduce using rule 156 (args -> arg COMMA arg .)
    ENSURE          reduce using rule 156 (args -> arg COMMA arg .)
    LBRACKET        reduce using rule 156 (args -> arg COMMA arg .)
    NOT_SYMBOL      reduce using rule 156 (args -> arg COMMA arg .)
    COMPLEMENT_OP   reduce using rule 156 (args -> arg COMMA arg .)
    DEFINED_OP      reduce using rule 156 (args -> arg COMMA arg .)
    NUMBER          reduce using rule 156 (args -> arg COMMA arg .)
    LPAREN          reduce using rule 156 (args -> arg COMMA arg .)
    UNARY_OP        reduce using rule 156 (args -> arg COMMA arg .)
    RETURN          reduce using rule 156 (args -> arg COMMA arg .)
    YIELD           reduce using rule 156 (args -> arg COMMA arg .)
    CASE            reduce using rule 156 (args -> arg COMMA arg .)
    FOR             reduce using rule 156 (args -> arg COMMA arg .)
    BEGIN           reduce using rule 156 (args -> arg COMMA arg .)
    CLASS           reduce using rule 156 (args -> arg COMMA arg .)
    MODULE          reduce using rule 156 (args -> arg COMMA arg .)
    DEF             reduce using rule 156 (args -> arg COMMA arg .)
    VAR_GLOBAL      reduce using rule 156 (args -> arg COMMA arg .)
    VAR_LOCAL       reduce using rule 156 (args -> arg COMMA arg .)
    VAR_INSTANCE    reduce using rule 156 (args -> arg COMMA arg .)
    VAR_CLASS       reduce using rule 156 (args -> arg COMMA arg .)
    SYMBOL          reduce using rule 156 (args -> arg COMMA arg .)
    STRING          reduce using rule 156 (args -> arg COMMA arg .)
    IDENTIFIER      reduce using rule 156 (args -> arg COMMA arg .)
    SUPER           reduce using rule 156 (args -> arg COMMA arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 156 (args -> arg COMMA arg .) ]
  ! OR              [ reduce using rule 156 (args -> arg COMMA arg .) ]
  ! TIMES           [ reduce using rule 156 (args -> arg COMMA arg .) ]
  ! PLUS            [ reduce using rule 156 (args -> arg COMMA arg .) ]
  ! MINUS           [ reduce using rule 156 (args -> arg COMMA arg .) ]


state 359

    (34) function -> primary DOT operation . LPAREN call_args RPAREN
    (36) function -> primary DOT operation .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 437
    LKEY            reduce using rule 36 (function -> primary DOT operation .)
    LBRACKET        reduce using rule 36 (function -> primary DOT operation .)
    DOT             reduce using rule 36 (function -> primary DOT operation .)
    UNARY_OP        reduce using rule 36 (function -> primary DOT operation .)
    COMMA           reduce using rule 36 (function -> primary DOT operation .)
    RANGE_INCLUSIVE reduce using rule 36 (function -> primary DOT operation .)
    RANGE_EXCLUSIVE reduce using rule 36 (function -> primary DOT operation .)
    OR_SYMBOL       reduce using rule 36 (function -> primary DOT operation .)
    BINARY_XOR_OP   reduce using rule 36 (function -> primary DOT operation .)
    BINARY_AND_OP   reduce using rule 36 (function -> primary DOT operation .)
    COMBINED_COMPARISON_OP reduce using rule 36 (function -> primary DOT operation .)
    GREATERTHAN     reduce using rule 36 (function -> primary DOT operation .)
    GREATERTHANEQUAL reduce using rule 36 (function -> primary DOT operation .)
    LESSERTHAN      reduce using rule 36 (function -> primary DOT operation .)
    LESSERTHANEQUAL reduce using rule 36 (function -> primary DOT operation .)
    EQUAL           reduce using rule 36 (function -> primary DOT operation .)
    CASE_EQUALITY   reduce using rule 36 (function -> primary DOT operation .)
    NOTEQUAL        reduce using rule 36 (function -> primary DOT operation .)
    MATCHED_STRINGS_OP reduce using rule 36 (function -> primary DOT operation .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 36 (function -> primary DOT operation .)
    BINARY_LEFT_SHIFT_OP reduce using rule 36 (function -> primary DOT operation .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 36 (function -> primary DOT operation .)
    AND             reduce using rule 36 (function -> primary DOT operation .)
    OR              reduce using rule 36 (function -> primary DOT operation .)
    PLUS            reduce using rule 36 (function -> primary DOT operation .)
    MINUS           reduce using rule 36 (function -> primary DOT operation .)
    TIMES           reduce using rule 36 (function -> primary DOT operation .)
    DIVIDE          reduce using rule 36 (function -> primary DOT operation .)
    MOD             reduce using rule 36 (function -> primary DOT operation .)
    POW             reduce using rule 36 (function -> primary DOT operation .)
    RBRACKET        reduce using rule 36 (function -> primary DOT operation .)
    HASH_ROCKET     reduce using rule 36 (function -> primary DOT operation .)
    RKEY            reduce using rule 36 (function -> primary DOT operation .)
    IF              reduce using rule 36 (function -> primary DOT operation .)
    WHILE           reduce using rule 36 (function -> primary DOT operation .)
    UNLESS          reduce using rule 36 (function -> primary DOT operation .)
    UNTIL           reduce using rule 36 (function -> primary DOT operation .)
    TERM            reduce using rule 36 (function -> primary DOT operation .)
    $end            reduce using rule 36 (function -> primary DOT operation .)
    RESCUE          reduce using rule 36 (function -> primary DOT operation .)
    RPAREN          reduce using rule 36 (function -> primary DOT operation .)
    WHEN            reduce using rule 36 (function -> primary DOT operation .)
    END             reduce using rule 36 (function -> primary DOT operation .)
    ELSIF           reduce using rule 36 (function -> primary DOT operation .)
    ELSE            reduce using rule 36 (function -> primary DOT operation .)
    ENSURE          reduce using rule 36 (function -> primary DOT operation .)
    THEN            reduce using rule 36 (function -> primary DOT operation .)
    DO              reduce using rule 36 (function -> primary DOT operation .)
    NOT_SYMBOL      reduce using rule 36 (function -> primary DOT operation .)
    COMPLEMENT_OP   reduce using rule 36 (function -> primary DOT operation .)
    DEFINED_OP      reduce using rule 36 (function -> primary DOT operation .)
    NUMBER          reduce using rule 36 (function -> primary DOT operation .)
    RETURN          reduce using rule 36 (function -> primary DOT operation .)
    YIELD           reduce using rule 36 (function -> primary DOT operation .)
    CASE            reduce using rule 36 (function -> primary DOT operation .)
    FOR             reduce using rule 36 (function -> primary DOT operation .)
    BEGIN           reduce using rule 36 (function -> primary DOT operation .)
    CLASS           reduce using rule 36 (function -> primary DOT operation .)
    MODULE          reduce using rule 36 (function -> primary DOT operation .)
    DEF             reduce using rule 36 (function -> primary DOT operation .)
    VAR_GLOBAL      reduce using rule 36 (function -> primary DOT operation .)
    VAR_LOCAL       reduce using rule 36 (function -> primary DOT operation .)
    VAR_INSTANCE    reduce using rule 36 (function -> primary DOT operation .)
    VAR_CLASS       reduce using rule 36 (function -> primary DOT operation .)
    SYMBOL          reduce using rule 36 (function -> primary DOT operation .)
    STRING          reduce using rule 36 (function -> primary DOT operation .)
    IDENTIFIER      reduce using rule 36 (function -> primary DOT operation .)
    SUPER           reduce using rule 36 (function -> primary DOT operation .)

  ! LPAREN          [ reduce using rule 36 (function -> primary DOT operation .) ]


state 360

    (35) function -> primary UNARY_OP operation . LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP operation .

  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 438
    LKEY            reduce using rule 37 (function -> primary UNARY_OP operation .)
    LBRACKET        reduce using rule 37 (function -> primary UNARY_OP operation .)
    DOT             reduce using rule 37 (function -> primary UNARY_OP operation .)
    UNARY_OP        reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMMA           reduce using rule 37 (function -> primary UNARY_OP operation .)
    RANGE_INCLUSIVE reduce using rule 37 (function -> primary UNARY_OP operation .)
    RANGE_EXCLUSIVE reduce using rule 37 (function -> primary UNARY_OP operation .)
    OR_SYMBOL       reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_XOR_OP   reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_AND_OP   reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMBINED_COMPARISON_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    GREATERTHAN     reduce using rule 37 (function -> primary UNARY_OP operation .)
    GREATERTHANEQUAL reduce using rule 37 (function -> primary UNARY_OP operation .)
    LESSERTHAN      reduce using rule 37 (function -> primary UNARY_OP operation .)
    LESSERTHANEQUAL reduce using rule 37 (function -> primary UNARY_OP operation .)
    EQUAL           reduce using rule 37 (function -> primary UNARY_OP operation .)
    CASE_EQUALITY   reduce using rule 37 (function -> primary UNARY_OP operation .)
    NOTEQUAL        reduce using rule 37 (function -> primary UNARY_OP operation .)
    MATCHED_STRINGS_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_LEFT_SHIFT_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    AND             reduce using rule 37 (function -> primary UNARY_OP operation .)
    OR              reduce using rule 37 (function -> primary UNARY_OP operation .)
    PLUS            reduce using rule 37 (function -> primary UNARY_OP operation .)
    MINUS           reduce using rule 37 (function -> primary UNARY_OP operation .)
    TIMES           reduce using rule 37 (function -> primary UNARY_OP operation .)
    DIVIDE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    MOD             reduce using rule 37 (function -> primary UNARY_OP operation .)
    POW             reduce using rule 37 (function -> primary UNARY_OP operation .)
    RBRACKET        reduce using rule 37 (function -> primary UNARY_OP operation .)
    HASH_ROCKET     reduce using rule 37 (function -> primary UNARY_OP operation .)
    RKEY            reduce using rule 37 (function -> primary UNARY_OP operation .)
    IF              reduce using rule 37 (function -> primary UNARY_OP operation .)
    WHILE           reduce using rule 37 (function -> primary UNARY_OP operation .)
    UNLESS          reduce using rule 37 (function -> primary UNARY_OP operation .)
    UNTIL           reduce using rule 37 (function -> primary UNARY_OP operation .)
    TERM            reduce using rule 37 (function -> primary UNARY_OP operation .)
    $end            reduce using rule 37 (function -> primary UNARY_OP operation .)
    RESCUE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    RPAREN          reduce using rule 37 (function -> primary UNARY_OP operation .)
    WHEN            reduce using rule 37 (function -> primary UNARY_OP operation .)
    END             reduce using rule 37 (function -> primary UNARY_OP operation .)
    ELSIF           reduce using rule 37 (function -> primary UNARY_OP operation .)
    ELSE            reduce using rule 37 (function -> primary UNARY_OP operation .)
    ENSURE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    THEN            reduce using rule 37 (function -> primary UNARY_OP operation .)
    DO              reduce using rule 37 (function -> primary UNARY_OP operation .)
    NOT_SYMBOL      reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMPLEMENT_OP   reduce using rule 37 (function -> primary UNARY_OP operation .)
    DEFINED_OP      reduce using rule 37 (function -> primary UNARY_OP operation .)
    NUMBER          reduce using rule 37 (function -> primary UNARY_OP operation .)
    RETURN          reduce using rule 37 (function -> primary UNARY_OP operation .)
    YIELD           reduce using rule 37 (function -> primary UNARY_OP operation .)
    CASE            reduce using rule 37 (function -> primary UNARY_OP operation .)
    FOR             reduce using rule 37 (function -> primary UNARY_OP operation .)
    BEGIN           reduce using rule 37 (function -> primary UNARY_OP operation .)
    CLASS           reduce using rule 37 (function -> primary UNARY_OP operation .)
    MODULE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    DEF             reduce using rule 37 (function -> primary UNARY_OP operation .)
    VAR_GLOBAL      reduce using rule 37 (function -> primary UNARY_OP operation .)
    VAR_LOCAL       reduce using rule 37 (function -> primary UNARY_OP operation .)
    VAR_INSTANCE    reduce using rule 37 (function -> primary UNARY_OP operation .)
    VAR_CLASS       reduce using rule 37 (function -> primary UNARY_OP operation .)
    SYMBOL          reduce using rule 37 (function -> primary UNARY_OP operation .)
    STRING          reduce using rule 37 (function -> primary UNARY_OP operation .)
    IDENTIFIER      reduce using rule 37 (function -> primary UNARY_OP operation .)
    SUPER           reduce using rule 37 (function -> primary UNARY_OP operation .)

  ! LPAREN          [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]


state 361

    (33) function -> operation LBRACKET LPAREN . LBRACKET call_args RBRACKET RPAREN RBRACKET

    LBRACKET        shift and go to state 439


state 362

    (15) stmt -> END LKEY compstmt RKEY .

    IF              reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    WHILE           reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    UNLESS          reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    UNTIL           reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    TERM            reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    $end            reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    RESCUE          reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    RPAREN          reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    WHEN            reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    RKEY            reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    LKEY            reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    END             reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    ELSIF           reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    ELSE            reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)
    ENSURE          reduce using rule 15 (stmt -> END LKEY compstmt RKEY .)


state 363

    (212) fname -> LBRACKET RBRACKET EQUAL_SYMBOL .

    IF              reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    WHILE           reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    UNLESS          reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    UNTIL           reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    TERM            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    $end            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    RESCUE          reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    RPAREN          reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    WHEN            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    RKEY            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    LKEY            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    END             reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    ELSIF           reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    ELSE            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    ENSURE          reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    IDENTIFIER      reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    RANGE_INCLUSIVE reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    OR_SYMBOL       reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    BINARY_AND_OP   reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    BINARY_XOR_OP   reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    COMBINED_COMPARISON_OP reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    EQUAL           reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    CASE_EQUALITY   reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    MATCHED_STRINGS_OP reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    GREATERTHAN     reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    GREATERTHANEQUAL reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    LESSERTHAN      reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    LESSERTHANEQUAL reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    PLUS            reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    MINUS           reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    TIMES           reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    DIVIDE          reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    MOD             reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    POW             reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    BINARY_LEFT_SHIFT_OP reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    COMPLEMENT_OP   reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    OVERLOAD_PLUS   reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    OVERLOAD_MINUS  reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    LBRACKET        reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)
    LPAREN          reduce using rule 212 (fname -> LBRACKET RBRACKET EQUAL_SYMBOL .)


state 364

    (98) primary -> IF expr then compstmt . END
    (99) primary -> IF expr then compstmt . elsif END
    (100) primary -> IF expr then compstmt . elsif ELSE compstmt END
    (118) elsif -> . ELSIF expr then compstmt
    (119) elsif -> . ELSIF expr then compstmt elsif

    END             shift and go to state 440
    ELSIF           shift and go to state 442

    elsif                          shift and go to state 441

state 365

    (131) then -> TERM THEN .

    LBRACKET        reduce using rule 131 (then -> TERM THEN .)
    UNDEF           reduce using rule 131 (then -> TERM THEN .)
    ALIAS           reduce using rule 131 (then -> TERM THEN .)
    BEGIN           reduce using rule 131 (then -> TERM THEN .)
    END             reduce using rule 131 (then -> TERM THEN .)
    RETURN          reduce using rule 131 (then -> TERM THEN .)
    YIELD           reduce using rule 131 (then -> TERM THEN .)
    NOT             reduce using rule 131 (then -> TERM THEN .)
    NOT_SYMBOL      reduce using rule 131 (then -> TERM THEN .)
    SUPER           reduce using rule 131 (then -> TERM THEN .)
    VAR_GLOBAL      reduce using rule 131 (then -> TERM THEN .)
    VAR_LOCAL       reduce using rule 131 (then -> TERM THEN .)
    VAR_INSTANCE    reduce using rule 131 (then -> TERM THEN .)
    VAR_CLASS       reduce using rule 131 (then -> TERM THEN .)
    LPAREN          reduce using rule 131 (then -> TERM THEN .)
    UNARY_OP        reduce using rule 131 (then -> TERM THEN .)
    LKEY            reduce using rule 131 (then -> TERM THEN .)
    DEFINED_OP      reduce using rule 131 (then -> TERM THEN .)
    IF              reduce using rule 131 (then -> TERM THEN .)
    UNLESS          reduce using rule 131 (then -> TERM THEN .)
    WHILE           reduce using rule 131 (then -> TERM THEN .)
    UNTIL           reduce using rule 131 (then -> TERM THEN .)
    CASE            reduce using rule 131 (then -> TERM THEN .)
    FOR             reduce using rule 131 (then -> TERM THEN .)
    CLASS           reduce using rule 131 (then -> TERM THEN .)
    MODULE          reduce using rule 131 (then -> TERM THEN .)
    DEF             reduce using rule 131 (then -> TERM THEN .)
    TIMES           reduce using rule 131 (then -> TERM THEN .)
    PLUS            reduce using rule 131 (then -> TERM THEN .)
    MINUS           reduce using rule 131 (then -> TERM THEN .)
    COMPLEMENT_OP   reduce using rule 131 (then -> TERM THEN .)
    IDENTIFIER      reduce using rule 131 (then -> TERM THEN .)
    NUMBER          reduce using rule 131 (then -> TERM THEN .)
    SYMBOL          reduce using rule 131 (then -> TERM THEN .)
    STRING          reduce using rule 131 (then -> TERM THEN .)


state 366

    (30) command -> primary DOT operation . call_args
    (34) function -> primary DOT operation . LPAREN call_args RPAREN
    (36) function -> primary DOT operation .
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    LPAREN          shift and go to state 392
    DOT             reduce using rule 36 (function -> primary DOT operation .)
    RANGE_INCLUSIVE reduce using rule 36 (function -> primary DOT operation .)
    RANGE_EXCLUSIVE reduce using rule 36 (function -> primary DOT operation .)
    OR_SYMBOL       reduce using rule 36 (function -> primary DOT operation .)
    BINARY_XOR_OP   reduce using rule 36 (function -> primary DOT operation .)
    COMBINED_COMPARISON_OP reduce using rule 36 (function -> primary DOT operation .)
    GREATERTHAN     reduce using rule 36 (function -> primary DOT operation .)
    GREATERTHANEQUAL reduce using rule 36 (function -> primary DOT operation .)
    LESSERTHAN      reduce using rule 36 (function -> primary DOT operation .)
    LESSERTHANEQUAL reduce using rule 36 (function -> primary DOT operation .)
    EQUAL           reduce using rule 36 (function -> primary DOT operation .)
    CASE_EQUALITY   reduce using rule 36 (function -> primary DOT operation .)
    NOTEQUAL        reduce using rule 36 (function -> primary DOT operation .)
    MATCHED_STRINGS_OP reduce using rule 36 (function -> primary DOT operation .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 36 (function -> primary DOT operation .)
    BINARY_LEFT_SHIFT_OP reduce using rule 36 (function -> primary DOT operation .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 36 (function -> primary DOT operation .)
    AND             reduce using rule 36 (function -> primary DOT operation .)
    OR              reduce using rule 36 (function -> primary DOT operation .)
    DIVIDE          reduce using rule 36 (function -> primary DOT operation .)
    MOD             reduce using rule 36 (function -> primary DOT operation .)
    POW             reduce using rule 36 (function -> primary DOT operation .)
    TERM            reduce using rule 36 (function -> primary DOT operation .)
    THEN            reduce using rule 36 (function -> primary DOT operation .)
    DO              reduce using rule 36 (function -> primary DOT operation .)
    COMMA           reduce using rule 36 (function -> primary DOT operation .)
    HASH_ROCKET     reduce using rule 36 (function -> primary DOT operation .)
    $end            reduce using rule 36 (function -> primary DOT operation .)
    RESCUE          reduce using rule 36 (function -> primary DOT operation .)
    RPAREN          reduce using rule 36 (function -> primary DOT operation .)
    WHEN            reduce using rule 36 (function -> primary DOT operation .)
    RKEY            reduce using rule 36 (function -> primary DOT operation .)
    END             reduce using rule 36 (function -> primary DOT operation .)
    ELSIF           reduce using rule 36 (function -> primary DOT operation .)
    ELSE            reduce using rule 36 (function -> primary DOT operation .)
    ENSURE          reduce using rule 36 (function -> primary DOT operation .)
    RBRACKET        reduce using rule 36 (function -> primary DOT operation .)
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! UNARY_OP        [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! LBRACKET        [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! BINARY_AND_OP   [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! PLUS            [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! MINUS           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! TIMES           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! IF              [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! WHILE           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! UNLESS          [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! UNTIL           [ reduce using rule 36 (function -> primary DOT operation .) ]
  ! LPAREN          [ reduce using rule 36 (function -> primary DOT operation .) ]

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 393
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 367

    (31) command -> primary UNARY_OP operation . call_args
    (35) function -> primary UNARY_OP operation . LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP operation .
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for BINARY_AND_OP resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for UNARY_OP resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for LKEY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for UNLESS resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for UNTIL resolved as shift
    LPAREN          shift and go to state 394
    DOT             reduce using rule 37 (function -> primary UNARY_OP operation .)
    RANGE_INCLUSIVE reduce using rule 37 (function -> primary UNARY_OP operation .)
    RANGE_EXCLUSIVE reduce using rule 37 (function -> primary UNARY_OP operation .)
    OR_SYMBOL       reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_XOR_OP   reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMBINED_COMPARISON_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    GREATERTHAN     reduce using rule 37 (function -> primary UNARY_OP operation .)
    GREATERTHANEQUAL reduce using rule 37 (function -> primary UNARY_OP operation .)
    LESSERTHAN      reduce using rule 37 (function -> primary UNARY_OP operation .)
    LESSERTHANEQUAL reduce using rule 37 (function -> primary UNARY_OP operation .)
    EQUAL           reduce using rule 37 (function -> primary UNARY_OP operation .)
    CASE_EQUALITY   reduce using rule 37 (function -> primary UNARY_OP operation .)
    NOTEQUAL        reduce using rule 37 (function -> primary UNARY_OP operation .)
    MATCHED_STRINGS_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_LEFT_SHIFT_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 37 (function -> primary UNARY_OP operation .)
    AND             reduce using rule 37 (function -> primary UNARY_OP operation .)
    OR              reduce using rule 37 (function -> primary UNARY_OP operation .)
    DIVIDE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    MOD             reduce using rule 37 (function -> primary UNARY_OP operation .)
    POW             reduce using rule 37 (function -> primary UNARY_OP operation .)
    TERM            reduce using rule 37 (function -> primary UNARY_OP operation .)
    THEN            reduce using rule 37 (function -> primary UNARY_OP operation .)
    DO              reduce using rule 37 (function -> primary UNARY_OP operation .)
    COMMA           reduce using rule 37 (function -> primary UNARY_OP operation .)
    HASH_ROCKET     reduce using rule 37 (function -> primary UNARY_OP operation .)
    $end            reduce using rule 37 (function -> primary UNARY_OP operation .)
    RESCUE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    RPAREN          reduce using rule 37 (function -> primary UNARY_OP operation .)
    WHEN            reduce using rule 37 (function -> primary UNARY_OP operation .)
    RKEY            reduce using rule 37 (function -> primary UNARY_OP operation .)
    END             reduce using rule 37 (function -> primary UNARY_OP operation .)
    ELSIF           reduce using rule 37 (function -> primary UNARY_OP operation .)
    ELSE            reduce using rule 37 (function -> primary UNARY_OP operation .)
    ENSURE          reduce using rule 37 (function -> primary UNARY_OP operation .)
    RBRACKET        reduce using rule 37 (function -> primary UNARY_OP operation .)
    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

  ! LKEY            [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! UNARY_OP        [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! LBRACKET        [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! BINARY_AND_OP   [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! PLUS            [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! MINUS           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! TIMES           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! IF              [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! WHILE           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! UNLESS          [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! UNTIL           [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]
  ! LPAREN          [ reduce using rule 37 (function -> primary UNARY_OP operation .) ]

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 395
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 368

    (77) primary -> primary LBRACKET RBRACKET .
    (142) lhs -> primary LBRACKET RBRACKET .

  ! reduce/reduce conflict for COMMA resolved using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DOT             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    UNARY_OP        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LBRACKET        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    OR_SYMBOL       reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_XOR_OP   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_AND_OP   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    GREATERTHAN     reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    GREATERTHANEQUAL reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LESSERTHAN      reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LESSERTHANEQUAL reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    EQUAL           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    CASE_EQUALITY   reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    NOTEQUAL        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    AND             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    OR              reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    PLUS            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MINUS           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    TIMES           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DIVIDE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    MOD             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    POW             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    TERM            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    THEN            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    DO              reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    COMMA           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    HASH_ROCKET     reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    IF              reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    WHILE           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    UNLESS          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    UNTIL           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    $end            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RESCUE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RPAREN          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    WHEN            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RKEY            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    LKEY            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    END             reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    ELSIF           reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    ELSE            reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    ENSURE          reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    RBRACKET        reduce using rule 77 (primary -> primary LBRACKET RBRACKET .)
    =               reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    PLUS_EQUAL      reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    MINUS_EQUAL     reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    TIMES_EQUAL     reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    DIVIDE_EQUAL    reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    MOD_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    POW_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    SINGLE_AND_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    SINGLE_OR_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    XOR_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    BINARY_LEFT_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    BINARY_RIGHT_EQUAL reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    AND_EQUAL       reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)
    OR_EQUAL        reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .)

  ! COMMA           [ reduce using rule 142 (lhs -> primary LBRACKET RBRACKET .) ]


state 369

    (78) primary -> primary LBRACKET args . RBRACKET
    (143) lhs -> primary LBRACKET args . RBRACKET

    RBRACKET        shift and go to state 443


state 370

    (75) primary -> primary UNARY_OP . IDENTIFIER
    (35) function -> primary UNARY_OP . operation LPAREN call_args RPAREN
    (37) function -> primary UNARY_OP . operation
    (31) command -> primary UNARY_OP . operation call_args
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    IDENTIFIER      shift and go to state 280

    operation                      shift and go to state 279

state 371

    (103) primary -> WHILE expr do compstmt . END

    END             shift and go to state 444


state 372

    (101) primary -> UNLESS expr then compstmt . END
    (102) primary -> UNLESS expr then compstmt . ELSE compstmt END

    END             shift and go to state 445
    ELSE            shift and go to state 446


state 373

    (104) primary -> UNTIL expr do compstmt . END

    END             shift and go to state 447


state 374

    (14) stmt -> BEGIN LKEY compstmt RKEY .

    IF              reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    WHILE           reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    UNLESS          reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    UNTIL           reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    TERM            reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    $end            reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    RESCUE          reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    RPAREN          reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    WHEN            reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    RKEY            reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    LKEY            reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    END             reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    ELSIF           reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    ELSE            reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)
    ENSURE          reduce using rule 14 (stmt -> BEGIN LKEY compstmt RKEY .)


state 375

    (67) arg -> primary .
    (30) command -> primary . DOT operation call_args
    (31) command -> primary . UNARY_OP operation call_args
    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation

    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    COMMA           reduce using rule 67 (arg -> primary .)
    HASH_ROCKET     reduce using rule 67 (arg -> primary .)
    RKEY            reduce using rule 67 (arg -> primary .)
    IF              reduce using rule 67 (arg -> primary .)
    WHILE           reduce using rule 67 (arg -> primary .)
    UNLESS          reduce using rule 67 (arg -> primary .)
    UNTIL           reduce using rule 67 (arg -> primary .)
    TERM            reduce using rule 67 (arg -> primary .)
    RPAREN          reduce using rule 67 (arg -> primary .)
    LPAREN          reduce using rule 67 (arg -> primary .)
    DOT             shift and go to state 250
    UNARY_OP        shift and go to state 251
    LBRACKET        shift and go to state 147


state 376

    (108) primary -> BEGIN compstmt rescue END .

    LBRACKET        reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    DOT             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    UNARY_OP        reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RANGE_INCLUSIVE reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RANGE_EXCLUSIVE reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    OR_SYMBOL       reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    BINARY_XOR_OP   reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    BINARY_AND_OP   reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    COMBINED_COMPARISON_OP reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    GREATERTHAN     reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    GREATERTHANEQUAL reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    LESSERTHAN      reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    LESSERTHANEQUAL reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    EQUAL           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    CASE_EQUALITY   reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    NOTEQUAL        reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    MATCHED_STRINGS_OP reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    AND             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    OR              reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    PLUS            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    MINUS           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    TIMES           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    DIVIDE          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    MOD             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    POW             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    IF              reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    WHILE           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    UNLESS          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    UNTIL           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    TERM            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    $end            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    COMMA           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RBRACKET        reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    THEN            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    DO              reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RESCUE          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    HASH_ROCKET     reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RKEY            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RPAREN          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    WHEN            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    LKEY            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    END             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    ELSIF           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    ELSE            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    ENSURE          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    NOT_SYMBOL      reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    COMPLEMENT_OP   reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    DEFINED_OP      reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    NUMBER          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    LPAREN          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    RETURN          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    YIELD           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    CASE            reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    FOR             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    BEGIN           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    CLASS           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    MODULE          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    DEF             reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    VAR_GLOBAL      reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    VAR_LOCAL       reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    VAR_INSTANCE    reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    VAR_CLASS       reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    SYMBOL          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    STRING          reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    IDENTIFIER      reduce using rule 108 (primary -> BEGIN compstmt rescue END .)
    SUPER           reduce using rule 108 (primary -> BEGIN compstmt rescue END .)


state 377

    (109) primary -> BEGIN compstmt rescue ELSE . compstmt END
    (111) primary -> BEGIN compstmt rescue ELSE . compstmt ENSURE compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 448
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 378

    (110) primary -> BEGIN compstmt rescue ENSURE . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 449
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 379

    (124) rescue -> rescue RESCUE . args do compstmt
    (125) rescue -> rescue RESCUE . do compstmt
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (135) term -> . TERM
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    DO              shift and go to state 62
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    TERM            shift and go to state 57
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    args                           shift and go to state 450
    do                             shift and go to state 451
    arg                            shift and go to state 70
    term                           shift and go to state 61
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 380

    (122) rescue -> RESCUE args . do compstmt
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 452
    term                           shift and go to state 61

state 381

    (123) rescue -> RESCUE do . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 453
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 382

    (85) primary -> LKEY args COMMA RKEY .

    LBRACKET        reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    DOT             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    UNARY_OP        reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RANGE_INCLUSIVE reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RANGE_EXCLUSIVE reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    OR_SYMBOL       reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    BINARY_XOR_OP   reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    BINARY_AND_OP   reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    COMBINED_COMPARISON_OP reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    GREATERTHAN     reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    GREATERTHANEQUAL reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    LESSERTHAN      reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    LESSERTHANEQUAL reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    EQUAL           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    CASE_EQUALITY   reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    NOTEQUAL        reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    MATCHED_STRINGS_OP reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    AND             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    OR              reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    PLUS            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    MINUS           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    TIMES           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    DIVIDE          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    MOD             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    POW             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    IF              reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    WHILE           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    UNLESS          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    UNTIL           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    TERM            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    $end            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    COMMA           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RBRACKET        reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    THEN            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    DO              reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RESCUE          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    HASH_ROCKET     reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RKEY            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RPAREN          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    WHEN            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    LKEY            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    END             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    ELSIF           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    ELSE            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    ENSURE          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    NOT_SYMBOL      reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    COMPLEMENT_OP   reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    DEFINED_OP      reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    NUMBER          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    LPAREN          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    RETURN          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    YIELD           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    CASE            reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    FOR             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    BEGIN           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    CLASS           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    MODULE          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    DEF             reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    VAR_GLOBAL      reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    VAR_LOCAL       reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    VAR_INSTANCE    reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    VAR_CLASS       reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    SYMBOL          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    STRING          reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    IDENTIFIER      reduce using rule 85 (primary -> LKEY args COMMA RKEY .)
    SUPER           reduce using rule 85 (primary -> LKEY args COMMA RKEY .)


state 383

    (86) primary -> LKEY assocs COMMA RKEY .

    LBRACKET        reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    DOT             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    UNARY_OP        reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RANGE_INCLUSIVE reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RANGE_EXCLUSIVE reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    OR_SYMBOL       reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    BINARY_XOR_OP   reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    BINARY_AND_OP   reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    COMBINED_COMPARISON_OP reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    GREATERTHAN     reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    GREATERTHANEQUAL reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    LESSERTHAN      reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    LESSERTHANEQUAL reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    EQUAL           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    CASE_EQUALITY   reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    NOTEQUAL        reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    MATCHED_STRINGS_OP reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    AND             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    OR              reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    PLUS            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    MINUS           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    TIMES           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    DIVIDE          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    MOD             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    POW             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    IF              reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    WHILE           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    UNLESS          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    UNTIL           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    TERM            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    $end            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    COMMA           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RBRACKET        reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    THEN            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    DO              reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RESCUE          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    HASH_ROCKET     reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RKEY            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RPAREN          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    WHEN            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    LKEY            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    END             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    ELSIF           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    ELSE            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    ENSURE          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    NOT_SYMBOL      reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    COMPLEMENT_OP   reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    DEFINED_OP      reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    NUMBER          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    LPAREN          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    RETURN          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    YIELD           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    CASE            reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    FOR             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    BEGIN           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    CLASS           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    MODULE          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    DEF             reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    VAR_GLOBAL      reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    VAR_LOCAL       reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    VAR_INSTANCE    reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    VAR_CLASS       reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    SYMBOL          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    STRING          reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    IDENTIFIER      reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)
    SUPER           reduce using rule 86 (primary -> LKEY assocs COMMA RKEY .)


state 384

    (166) assoc -> arg HASH_ROCKET arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    COMMA           reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    RKEY            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    IF              reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    WHILE           reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    UNLESS          reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    UNTIL           reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    TERM            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    $end            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    THEN            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    DO              reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    RESCUE          reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    RPAREN          reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    WHEN            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    LKEY            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    END             reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    ELSIF           reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    ELSE            reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    ENSURE          reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    LBRACKET        reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    RBRACKET        reduce using rule 166 (assoc -> arg HASH_ROCKET arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 166 (assoc -> arg HASH_ROCKET arg .) ]
  ! OR              [ reduce using rule 166 (assoc -> arg HASH_ROCKET arg .) ]


state 385

    (165) assocs -> assoc COMMA assoc .

    RKEY            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    COMMA           reduce using rule 165 (assocs -> assoc COMMA assoc .)
    AND             reduce using rule 165 (assocs -> assoc COMMA assoc .)
    OR              reduce using rule 165 (assocs -> assoc COMMA assoc .)
    IF              reduce using rule 165 (assocs -> assoc COMMA assoc .)
    WHILE           reduce using rule 165 (assocs -> assoc COMMA assoc .)
    UNLESS          reduce using rule 165 (assocs -> assoc COMMA assoc .)
    UNTIL           reduce using rule 165 (assocs -> assoc COMMA assoc .)
    TERM            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    $end            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    THEN            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    DO              reduce using rule 165 (assocs -> assoc COMMA assoc .)
    RESCUE          reduce using rule 165 (assocs -> assoc COMMA assoc .)
    RPAREN          reduce using rule 165 (assocs -> assoc COMMA assoc .)
    WHEN            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    LKEY            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    END             reduce using rule 165 (assocs -> assoc COMMA assoc .)
    ELSIF           reduce using rule 165 (assocs -> assoc COMMA assoc .)
    ELSE            reduce using rule 165 (assocs -> assoc COMMA assoc .)
    ENSURE          reduce using rule 165 (assocs -> assoc COMMA assoc .)
    LBRACKET        reduce using rule 165 (assocs -> assoc COMMA assoc .)
    RBRACKET        reduce using rule 165 (assocs -> assoc COMMA assoc .)


state 386

    (166) assoc -> arg . HASH_ROCKET arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

    HASH_ROCKET     shift and go to state 268
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189


state 387

    (16) stmt -> lhs = command LBRACKET . do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 454
    term                           shift and go to state 61

state 388

    (95) primary -> function LKEY compstmt LKEY .

    LBRACKET        reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    DOT             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    UNARY_OP        reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RANGE_INCLUSIVE reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RANGE_EXCLUSIVE reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    OR_SYMBOL       reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    BINARY_XOR_OP   reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    BINARY_AND_OP   reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    COMBINED_COMPARISON_OP reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    GREATERTHAN     reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    GREATERTHANEQUAL reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    LESSERTHAN      reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    LESSERTHANEQUAL reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    EQUAL           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    CASE_EQUALITY   reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    NOTEQUAL        reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    MATCHED_STRINGS_OP reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    AND             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    OR              reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    PLUS            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    MINUS           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    TIMES           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    DIVIDE          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    MOD             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    POW             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    IF              reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    WHILE           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    UNLESS          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    UNTIL           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    TERM            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    $end            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    COMMA           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RBRACKET        reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    THEN            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    DO              reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RESCUE          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    HASH_ROCKET     reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RKEY            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RPAREN          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    WHEN            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    LKEY            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    END             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    ELSIF           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    ELSE            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    ENSURE          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    NOT_SYMBOL      reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    COMPLEMENT_OP   reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    DEFINED_OP      reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    NUMBER          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    LPAREN          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    RETURN          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    YIELD           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    CASE            reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    FOR             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    BEGIN           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    CLASS           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    MODULE          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    DEF             reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    VAR_GLOBAL      reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    VAR_LOCAL       reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    VAR_INSTANCE    reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    VAR_CLASS       reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    SYMBOL          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    STRING          reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    IDENTIFIER      reduce using rule 95 (primary -> function LKEY compstmt LKEY .)
    SUPER           reduce using rule 95 (primary -> function LKEY compstmt LKEY .)


state 389

    (96) primary -> function LKEY OR_SYMBOL OR_SYMBOL . compstmt LKEY
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    function                       shift and go to state 18
    compstmt                       shift and go to state 455
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 390

    (97) primary -> function LKEY OR_SYMBOL block_var . OR_SYMBOL compstmt LKEY

    OR_SYMBOL       shift and go to state 456


state 391

    (143) lhs -> primary LBRACKET args RBRACKET .
    (78) primary -> primary LBRACKET args RBRACKET .

  ! reduce/reduce conflict for LBRACKET resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for UNARY_OP resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for OR_SYMBOL resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for TIMES resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for IF resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for WHILE resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for UNLESS resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for UNTIL resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for COMMA resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for RPAREN resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for LKEY resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for DEFINED_OP resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for NUMBER resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for LPAREN resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for RETURN resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for YIELD resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for CASE resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for FOR resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for BEGIN resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for CLASS resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for MODULE resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for DEF resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for VAR_GLOBAL resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for VAR_LOCAL resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for VAR_INSTANCE resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for VAR_CLASS resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for SYMBOL resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for STRING resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
  ! reduce/reduce conflict for SUPER resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    =               reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    PLUS_EQUAL      reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    MINUS_EQUAL     reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    TIMES_EQUAL     reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    DIVIDE_EQUAL    reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    MOD_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    POW_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    SINGLE_AND_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    SINGLE_OR_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    XOR_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    BINARY_LEFT_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    BINARY_RIGHT_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    AND_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    OR_EQUAL        reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    IN              reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    LBRACKET        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DOT             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    UNARY_OP        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    OR_SYMBOL       reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_XOR_OP   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_AND_OP   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    GREATERTHAN     reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    GREATERTHANEQUAL reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LESSERTHAN      reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LESSERTHANEQUAL reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    EQUAL           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    CASE_EQUALITY   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    NOTEQUAL        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    AND             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    OR              reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    PLUS            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MINUS           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    TIMES           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DIVIDE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MOD             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    POW             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    IF              reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    WHILE           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    UNLESS          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    UNTIL           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    TERM            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    $end            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    COMMA           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RBRACKET        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RESCUE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    HASH_ROCKET     reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RKEY            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RPAREN          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    WHEN            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LKEY            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    END             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    ELSIF           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    ELSE            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    ENSURE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    THEN            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DO              reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    NOT_SYMBOL      reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    COMPLEMENT_OP   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DEFINED_OP      reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    NUMBER          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LPAREN          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RETURN          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    YIELD           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    CASE            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    FOR             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BEGIN           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    CLASS           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MODULE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DEF             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    VAR_GLOBAL      reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    VAR_LOCAL       reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    VAR_INSTANCE    reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    VAR_CLASS       reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    SYMBOL          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    STRING          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    IDENTIFIER      reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    SUPER           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)

  ! COMMA           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! RBRACKET        [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! RPAREN          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! OR_SYMBOL       [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! TIMES           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! VAR_GLOBAL      [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! VAR_LOCAL       [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! VAR_INSTANCE    [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! VAR_CLASS       [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! LPAREN          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! UNARY_OP        [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! LBRACKET        [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! LKEY            [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! RETURN          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! YIELD           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! DEFINED_OP      [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! IF              [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! UNLESS          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! WHILE           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! UNTIL           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! CASE            [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! FOR             [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! BEGIN           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! CLASS           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! MODULE          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! DEF             [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! NUMBER          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! SYMBOL          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! STRING          [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! IDENTIFIER      [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]
  ! SUPER           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]


state 392

    (34) function -> primary DOT operation LPAREN . call_args RPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    TIMES           shift and go to state 287
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 284
    YIELD           shift and go to state 289
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NOT             shift and go to state 25
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 457
    compstmt                       shift and go to state 192
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 259
    command                        shift and go to state 288
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    assoc                          shift and go to state 127
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 290
    mlhs                           shift and go to state 22
    mlhs_item                      shift and go to state 43

state 393

    (30) command -> primary DOT operation call_args .

    DO              reduce using rule 30 (command -> primary DOT operation call_args .)
    TERM            reduce using rule 30 (command -> primary DOT operation call_args .)
    AND             reduce using rule 30 (command -> primary DOT operation call_args .)
    OR              reduce using rule 30 (command -> primary DOT operation call_args .)
    IF              reduce using rule 30 (command -> primary DOT operation call_args .)
    WHILE           reduce using rule 30 (command -> primary DOT operation call_args .)
    UNLESS          reduce using rule 30 (command -> primary DOT operation call_args .)
    UNTIL           reduce using rule 30 (command -> primary DOT operation call_args .)
    $end            reduce using rule 30 (command -> primary DOT operation call_args .)
    THEN            reduce using rule 30 (command -> primary DOT operation call_args .)
    RESCUE          reduce using rule 30 (command -> primary DOT operation call_args .)
    RPAREN          reduce using rule 30 (command -> primary DOT operation call_args .)
    WHEN            reduce using rule 30 (command -> primary DOT operation call_args .)
    RKEY            reduce using rule 30 (command -> primary DOT operation call_args .)
    LKEY            reduce using rule 30 (command -> primary DOT operation call_args .)
    END             reduce using rule 30 (command -> primary DOT operation call_args .)
    ELSIF           reduce using rule 30 (command -> primary DOT operation call_args .)
    ELSE            reduce using rule 30 (command -> primary DOT operation call_args .)
    ENSURE          reduce using rule 30 (command -> primary DOT operation call_args .)
    LBRACKET        reduce using rule 30 (command -> primary DOT operation call_args .)
    RBRACKET        reduce using rule 30 (command -> primary DOT operation call_args .)


state 394

    (35) function -> primary UNARY_OP operation LPAREN . call_args RPAREN
    (72) primary -> LPAREN . compstmt RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN

    TIMES           shift and go to state 287
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 260
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    RETURN          shift and go to state 284
    YIELD           shift and go to state 289
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NOT             shift and go to state 25
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 458
    compstmt                       shift and go to state 192
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 259
    command                        shift and go to state 288
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    assoc                          shift and go to state 127
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 290
    mlhs                           shift and go to state 22
    mlhs_item                      shift and go to state 43

state 395

    (31) command -> primary UNARY_OP operation call_args .

    DO              reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    TERM            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    AND             reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    OR              reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    IF              reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    WHILE           reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    UNLESS          reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    UNTIL           reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    $end            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    THEN            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    RESCUE          reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    RPAREN          reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    WHEN            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    RKEY            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    LKEY            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    END             reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    ELSIF           reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    ELSE            reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    ENSURE          reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    LBRACKET        reduce using rule 31 (command -> primary UNARY_OP operation call_args .)
    RBRACKET        reduce using rule 31 (command -> primary UNARY_OP operation call_args .)


state 396

    (137) mrhs -> args COMMA .

    AND             reduce using rule 137 (mrhs -> args COMMA .)
    OR              reduce using rule 137 (mrhs -> args COMMA .)
    IF              reduce using rule 137 (mrhs -> args COMMA .)
    WHILE           reduce using rule 137 (mrhs -> args COMMA .)
    UNLESS          reduce using rule 137 (mrhs -> args COMMA .)
    UNTIL           reduce using rule 137 (mrhs -> args COMMA .)
    TERM            reduce using rule 137 (mrhs -> args COMMA .)
    $end            reduce using rule 137 (mrhs -> args COMMA .)
    THEN            reduce using rule 137 (mrhs -> args COMMA .)
    DO              reduce using rule 137 (mrhs -> args COMMA .)
    RESCUE          reduce using rule 137 (mrhs -> args COMMA .)
    RPAREN          reduce using rule 137 (mrhs -> args COMMA .)
    WHEN            reduce using rule 137 (mrhs -> args COMMA .)
    RKEY            reduce using rule 137 (mrhs -> args COMMA .)
    LKEY            reduce using rule 137 (mrhs -> args COMMA .)
    END             reduce using rule 137 (mrhs -> args COMMA .)
    ELSIF           reduce using rule 137 (mrhs -> args COMMA .)
    ELSE            reduce using rule 137 (mrhs -> args COMMA .)
    ENSURE          reduce using rule 137 (mrhs -> args COMMA .)


state 397

    (138) mrhs -> args TIMES .

    AND             reduce using rule 138 (mrhs -> args TIMES .)
    OR              reduce using rule 138 (mrhs -> args TIMES .)
    IF              reduce using rule 138 (mrhs -> args TIMES .)
    WHILE           reduce using rule 138 (mrhs -> args TIMES .)
    UNLESS          reduce using rule 138 (mrhs -> args TIMES .)
    UNTIL           reduce using rule 138 (mrhs -> args TIMES .)
    TERM            reduce using rule 138 (mrhs -> args TIMES .)
    $end            reduce using rule 138 (mrhs -> args TIMES .)
    THEN            reduce using rule 138 (mrhs -> args TIMES .)
    DO              reduce using rule 138 (mrhs -> args TIMES .)
    RESCUE          reduce using rule 138 (mrhs -> args TIMES .)
    RPAREN          reduce using rule 138 (mrhs -> args TIMES .)
    WHEN            reduce using rule 138 (mrhs -> args TIMES .)
    RKEY            reduce using rule 138 (mrhs -> args TIMES .)
    LKEY            reduce using rule 138 (mrhs -> args TIMES .)
    END             reduce using rule 138 (mrhs -> args TIMES .)
    ELSIF           reduce using rule 138 (mrhs -> args TIMES .)
    ELSE            reduce using rule 138 (mrhs -> args TIMES .)
    ENSURE          reduce using rule 138 (mrhs -> args TIMES .)


state 398

    (139) mrhs -> args arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 139 (mrhs -> args arg .)
    WHILE           reduce using rule 139 (mrhs -> args arg .)
    UNLESS          reduce using rule 139 (mrhs -> args arg .)
    UNTIL           reduce using rule 139 (mrhs -> args arg .)
    TERM            reduce using rule 139 (mrhs -> args arg .)
    $end            reduce using rule 139 (mrhs -> args arg .)
    THEN            reduce using rule 139 (mrhs -> args arg .)
    DO              reduce using rule 139 (mrhs -> args arg .)
    RESCUE          reduce using rule 139 (mrhs -> args arg .)
    RPAREN          reduce using rule 139 (mrhs -> args arg .)
    WHEN            reduce using rule 139 (mrhs -> args arg .)
    RKEY            reduce using rule 139 (mrhs -> args arg .)
    LKEY            reduce using rule 139 (mrhs -> args arg .)
    END             reduce using rule 139 (mrhs -> args arg .)
    ELSIF           reduce using rule 139 (mrhs -> args arg .)
    ELSE            reduce using rule 139 (mrhs -> args arg .)
    ENSURE          reduce using rule 139 (mrhs -> args arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 139 (mrhs -> args arg .) ]
  ! OR              [ reduce using rule 139 (mrhs -> args arg .) ]


state 399

    (140) mrhs -> TIMES arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 140 (mrhs -> TIMES arg .)
    WHILE           reduce using rule 140 (mrhs -> TIMES arg .)
    UNLESS          reduce using rule 140 (mrhs -> TIMES arg .)
    UNTIL           reduce using rule 140 (mrhs -> TIMES arg .)
    TERM            reduce using rule 140 (mrhs -> TIMES arg .)
    $end            reduce using rule 140 (mrhs -> TIMES arg .)
    THEN            reduce using rule 140 (mrhs -> TIMES arg .)
    DO              reduce using rule 140 (mrhs -> TIMES arg .)
    RESCUE          reduce using rule 140 (mrhs -> TIMES arg .)
    RPAREN          reduce using rule 140 (mrhs -> TIMES arg .)
    WHEN            reduce using rule 140 (mrhs -> TIMES arg .)
    RKEY            reduce using rule 140 (mrhs -> TIMES arg .)
    LKEY            reduce using rule 140 (mrhs -> TIMES arg .)
    END             reduce using rule 140 (mrhs -> TIMES arg .)
    ELSIF           reduce using rule 140 (mrhs -> TIMES arg .)
    ELSE            reduce using rule 140 (mrhs -> TIMES arg .)
    ENSURE          reduce using rule 140 (mrhs -> TIMES arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 140 (mrhs -> TIMES arg .) ]
  ! OR              [ reduce using rule 140 (mrhs -> TIMES arg .) ]


state 400

    (89) primary -> RETURN LPAREN call_args RPAREN .

    LBRACKET        reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    DOT             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    UNARY_OP        reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RANGE_INCLUSIVE reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    OR_SYMBOL       reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    BINARY_XOR_OP   reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    BINARY_AND_OP   reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    GREATERTHAN     reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    GREATERTHANEQUAL reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    LESSERTHAN      reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    LESSERTHANEQUAL reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    EQUAL           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    CASE_EQUALITY   reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    NOTEQUAL        reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    AND             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    OR              reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    PLUS            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    MINUS           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    TIMES           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    DIVIDE          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    MOD             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    POW             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    IF              reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    WHILE           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    UNLESS          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    UNTIL           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    TERM            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    $end            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    COMMA           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RBRACKET        reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    THEN            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    DO              reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RESCUE          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    HASH_ROCKET     reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RKEY            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    WHEN            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    LKEY            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    END             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    ELSIF           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    ELSE            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    ENSURE          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    NOT_SYMBOL      reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    COMPLEMENT_OP   reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    DEFINED_OP      reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    NUMBER          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    LPAREN          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    RETURN          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    YIELD           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    CASE            reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    FOR             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    BEGIN           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    CLASS           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    MODULE          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    DEF             reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    VAR_GLOBAL      reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    VAR_LOCAL       reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    VAR_INSTANCE    reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    VAR_CLASS       reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    SYMBOL          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    STRING          reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    IDENTIFIER      reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)
    SUPER           reduce using rule 89 (primary -> RETURN LPAREN call_args RPAREN .)


state 401

    (151) mlhs -> TIMES lhs .
    (40) arg -> lhs . = arg
    (41) arg -> lhs . op_asgn arg
    (216) op_asgn -> . PLUS_EQUAL
    (217) op_asgn -> . MINUS_EQUAL
    (218) op_asgn -> . TIMES_EQUAL
    (219) op_asgn -> . DIVIDE_EQUAL
    (220) op_asgn -> . MOD_EQUAL
    (221) op_asgn -> . POW_EQUAL
    (222) op_asgn -> . SINGLE_AND_EQUAL
    (223) op_asgn -> . SINGLE_OR_EQUAL
    (224) op_asgn -> . XOR_EQUAL
    (225) op_asgn -> . BINARY_LEFT_EQUAL
    (226) op_asgn -> . BINARY_RIGHT_EQUAL
    (227) op_asgn -> . AND_EQUAL
    (228) op_asgn -> . OR_EQUAL

  ! shift/reduce conflict for = resolved as shift
    RBRACKET        reduce using rule 151 (mlhs -> TIMES lhs .)
    =               shift and go to state 236
    PLUS_EQUAL      shift and go to state 133
    MINUS_EQUAL     shift and go to state 134
    TIMES_EQUAL     shift and go to state 135
    DIVIDE_EQUAL    shift and go to state 136
    MOD_EQUAL       shift and go to state 137
    POW_EQUAL       shift and go to state 138
    SINGLE_AND_EQUAL shift and go to state 139
    SINGLE_OR_EQUAL shift and go to state 140
    XOR_EQUAL       shift and go to state 141
    BINARY_LEFT_EQUAL shift and go to state 142
    BINARY_RIGHT_EQUAL shift and go to state 143
    AND_EQUAL       shift and go to state 144
    OR_EQUAL        shift and go to state 145

  ! =               [ reduce using rule 151 (mlhs -> TIMES lhs .) ]

    op_asgn                        shift and go to state 132

state 402

    (168) call_args -> args COMMA assocs .
    (171) call_args -> args COMMA assocs . COMMA TIMES arg
    (172) call_args -> args COMMA assocs . COMMA BINARY_AND_OP arg
    (174) call_args -> args COMMA assocs . COMMA TIMES arg COMMA BINARY_AND_OP arg

    AND             reduce using rule 168 (call_args -> args COMMA assocs .)
    OR              reduce using rule 168 (call_args -> args COMMA assocs .)
    IF              reduce using rule 168 (call_args -> args COMMA assocs .)
    WHILE           reduce using rule 168 (call_args -> args COMMA assocs .)
    UNLESS          reduce using rule 168 (call_args -> args COMMA assocs .)
    UNTIL           reduce using rule 168 (call_args -> args COMMA assocs .)
    TERM            reduce using rule 168 (call_args -> args COMMA assocs .)
    $end            reduce using rule 168 (call_args -> args COMMA assocs .)
    THEN            reduce using rule 168 (call_args -> args COMMA assocs .)
    DO              reduce using rule 168 (call_args -> args COMMA assocs .)
    RESCUE          reduce using rule 168 (call_args -> args COMMA assocs .)
    RPAREN          reduce using rule 168 (call_args -> args COMMA assocs .)
    WHEN            reduce using rule 168 (call_args -> args COMMA assocs .)
    RKEY            reduce using rule 168 (call_args -> args COMMA assocs .)
    LKEY            reduce using rule 168 (call_args -> args COMMA assocs .)
    END             reduce using rule 168 (call_args -> args COMMA assocs .)
    ELSIF           reduce using rule 168 (call_args -> args COMMA assocs .)
    ELSE            reduce using rule 168 (call_args -> args COMMA assocs .)
    ENSURE          reduce using rule 168 (call_args -> args COMMA assocs .)
    LBRACKET        reduce using rule 168 (call_args -> args COMMA assocs .)
    RBRACKET        reduce using rule 168 (call_args -> args COMMA assocs .)
    COMMA           shift and go to state 459


state 403

    (169) call_args -> args COMMA TIMES . arg
    (173) call_args -> args COMMA TIMES . arg COMMA BINARY_AND_OP arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 460
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 404

    (170) call_args -> args COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 461
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 405

    (176) call_args -> assocs COMMA TIMES . arg
    (178) call_args -> assocs COMMA TIMES . arg COMMA BINARY_AND_OP arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 462
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 406

    (177) call_args -> assocs COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 463
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 407

    (180) call_args -> TIMES arg COMMA . BINARY_AND_OP arg

    BINARY_AND_OP   shift and go to state 464


state 408

    (92) primary -> YIELD LPAREN call_args RPAREN .

    LBRACKET        reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    DOT             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    UNARY_OP        reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RANGE_INCLUSIVE reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    OR_SYMBOL       reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    BINARY_XOR_OP   reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    BINARY_AND_OP   reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    GREATERTHAN     reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    GREATERTHANEQUAL reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    LESSERTHAN      reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    LESSERTHANEQUAL reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    EQUAL           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    CASE_EQUALITY   reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    NOTEQUAL        reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    AND             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    OR              reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    PLUS            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    MINUS           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    TIMES           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    DIVIDE          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    MOD             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    POW             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    IF              reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    WHILE           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    UNLESS          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    UNTIL           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    TERM            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    $end            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    COMMA           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RBRACKET        reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    THEN            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    DO              reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RESCUE          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    HASH_ROCKET     reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RKEY            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    WHEN            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    LKEY            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    END             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    ELSIF           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    ELSE            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    ENSURE          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    NOT_SYMBOL      reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    COMPLEMENT_OP   reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    DEFINED_OP      reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    NUMBER          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    LPAREN          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    RETURN          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    YIELD           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    CASE            reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    FOR             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    BEGIN           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    CLASS           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    MODULE          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    DEF             reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    VAR_GLOBAL      reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    VAR_LOCAL       reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    VAR_INSTANCE    reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    VAR_CLASS       reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    SYMBOL          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    STRING          reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    IDENTIFIER      reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)
    SUPER           reduce using rule 92 (primary -> YIELD LPAREN call_args RPAREN .)


state 409

    (33) function -> operation LBRACKET LPAREN LBRACKET . call_args RBRACKET RPAREN RBRACKET
    (6) stmt -> LBRACKET . block_var RBRACKET
    (7) stmt -> LBRACKET . OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (79) primary -> LBRACKET . RBRACKET
    (80) primary -> LBRACKET . args RBRACKET
    (81) primary -> LBRACKET . args COMMA RBRACKET
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    OR_SYMBOL       shift and go to state 66
    RBRACKET        shift and go to state 65
    TIMES           shift and go to state 287
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    operation                      shift and go to state 113
    call_args                      shift and go to state 465
    block_var                      shift and go to state 64
    args                           shift and go to state 466
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    lhs                            shift and go to state 68
    mlhs                           shift and go to state 69
    assoc                          shift and go to state 127
    primary                        shift and go to state 467
    variable                       shift and go to state 19
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    function                       shift and go to state 77

state 410

    (38) function -> SUPER LPAREN call_args RPAREN .

    LKEY            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    DO              reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    TERM            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    LBRACKET        reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    DOT             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    UNARY_OP        reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RANGE_INCLUSIVE reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    OR_SYMBOL       reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    BINARY_XOR_OP   reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    BINARY_AND_OP   reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    GREATERTHAN     reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    GREATERTHANEQUAL reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    LESSERTHAN      reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    LESSERTHANEQUAL reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    EQUAL           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    CASE_EQUALITY   reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    NOTEQUAL        reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    AND             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    OR              reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    PLUS            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    MINUS           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    TIMES           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    DIVIDE          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    MOD             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    POW             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    IF              reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    WHILE           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    UNLESS          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    UNTIL           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    $end            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    COMMA           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RBRACKET        reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    THEN            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RESCUE          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    HASH_ROCKET     reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RKEY            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    WHEN            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    END             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    ELSIF           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    ELSE            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    ENSURE          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    NOT_SYMBOL      reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    COMPLEMENT_OP   reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    DEFINED_OP      reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    NUMBER          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    LPAREN          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    RETURN          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    YIELD           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    CASE            reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    FOR             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    BEGIN           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    CLASS           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    MODULE          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    DEF             reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    VAR_GLOBAL      reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    VAR_LOCAL       reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    VAR_INSTANCE    reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    VAR_CLASS       reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    SYMBOL          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    STRING          reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    IDENTIFIER      reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)
    SUPER           reduce using rule 38 (function -> SUPER LPAREN call_args RPAREN .)


state 411

    (93) primary -> DEFINED_OP LPAREN arg LPAREN .

    LBRACKET        reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    DOT             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    UNARY_OP        reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RANGE_INCLUSIVE reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RANGE_EXCLUSIVE reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    OR_SYMBOL       reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    BINARY_XOR_OP   reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    BINARY_AND_OP   reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    GREATERTHAN     reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    GREATERTHANEQUAL reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    LESSERTHAN      reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    LESSERTHANEQUAL reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    EQUAL           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    CASE_EQUALITY   reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    NOTEQUAL        reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    MATCHED_STRINGS_OP reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    AND             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    OR              reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    PLUS            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    MINUS           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    TIMES           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    DIVIDE          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    MOD             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    POW             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    IF              reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    WHILE           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    UNLESS          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    UNTIL           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    TERM            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    $end            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    COMMA           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RBRACKET        reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    THEN            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    DO              reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RESCUE          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    HASH_ROCKET     reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RKEY            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RPAREN          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    WHEN            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    LKEY            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    END             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    ELSIF           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    ELSE            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    ENSURE          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    NOT_SYMBOL      reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    COMPLEMENT_OP   reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    DEFINED_OP      reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    NUMBER          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    LPAREN          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    RETURN          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    YIELD           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    CASE            reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    FOR             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    BEGIN           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    CLASS           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    MODULE          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    DEF             reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    VAR_GLOBAL      reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    VAR_LOCAL       reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    VAR_INSTANCE    reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    VAR_CLASS       reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    SYMBOL          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    STRING          reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    IDENTIFIER      reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)
    SUPER           reduce using rule 93 (primary -> DEFINED_OP LPAREN arg LPAREN .)


state 412

    (40) arg -> lhs = . arg
    (16) stmt -> lhs = . command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    SUPER           shift and go to state 115
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    IDENTIFIER      shift and go to state 21
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    lhs                            shift and go to state 128
    arg                            shift and go to state 271
    command                        shift and go to state 270
    math_operations                shift and go to state 45
    primary                        shift and go to state 375
    operation                      shift and go to state 113
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77

state 413

    (105) primary -> CASE compstmt when END .

    LBRACKET        reduce using rule 105 (primary -> CASE compstmt when END .)
    DOT             reduce using rule 105 (primary -> CASE compstmt when END .)
    UNARY_OP        reduce using rule 105 (primary -> CASE compstmt when END .)
    RANGE_INCLUSIVE reduce using rule 105 (primary -> CASE compstmt when END .)
    RANGE_EXCLUSIVE reduce using rule 105 (primary -> CASE compstmt when END .)
    OR_SYMBOL       reduce using rule 105 (primary -> CASE compstmt when END .)
    BINARY_XOR_OP   reduce using rule 105 (primary -> CASE compstmt when END .)
    BINARY_AND_OP   reduce using rule 105 (primary -> CASE compstmt when END .)
    COMBINED_COMPARISON_OP reduce using rule 105 (primary -> CASE compstmt when END .)
    GREATERTHAN     reduce using rule 105 (primary -> CASE compstmt when END .)
    GREATERTHANEQUAL reduce using rule 105 (primary -> CASE compstmt when END .)
    LESSERTHAN      reduce using rule 105 (primary -> CASE compstmt when END .)
    LESSERTHANEQUAL reduce using rule 105 (primary -> CASE compstmt when END .)
    EQUAL           reduce using rule 105 (primary -> CASE compstmt when END .)
    CASE_EQUALITY   reduce using rule 105 (primary -> CASE compstmt when END .)
    NOTEQUAL        reduce using rule 105 (primary -> CASE compstmt when END .)
    MATCHED_STRINGS_OP reduce using rule 105 (primary -> CASE compstmt when END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 105 (primary -> CASE compstmt when END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 105 (primary -> CASE compstmt when END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 105 (primary -> CASE compstmt when END .)
    AND             reduce using rule 105 (primary -> CASE compstmt when END .)
    OR              reduce using rule 105 (primary -> CASE compstmt when END .)
    PLUS            reduce using rule 105 (primary -> CASE compstmt when END .)
    MINUS           reduce using rule 105 (primary -> CASE compstmt when END .)
    TIMES           reduce using rule 105 (primary -> CASE compstmt when END .)
    DIVIDE          reduce using rule 105 (primary -> CASE compstmt when END .)
    MOD             reduce using rule 105 (primary -> CASE compstmt when END .)
    POW             reduce using rule 105 (primary -> CASE compstmt when END .)
    IF              reduce using rule 105 (primary -> CASE compstmt when END .)
    WHILE           reduce using rule 105 (primary -> CASE compstmt when END .)
    UNLESS          reduce using rule 105 (primary -> CASE compstmt when END .)
    UNTIL           reduce using rule 105 (primary -> CASE compstmt when END .)
    TERM            reduce using rule 105 (primary -> CASE compstmt when END .)
    $end            reduce using rule 105 (primary -> CASE compstmt when END .)
    COMMA           reduce using rule 105 (primary -> CASE compstmt when END .)
    RBRACKET        reduce using rule 105 (primary -> CASE compstmt when END .)
    THEN            reduce using rule 105 (primary -> CASE compstmt when END .)
    DO              reduce using rule 105 (primary -> CASE compstmt when END .)
    RESCUE          reduce using rule 105 (primary -> CASE compstmt when END .)
    HASH_ROCKET     reduce using rule 105 (primary -> CASE compstmt when END .)
    RKEY            reduce using rule 105 (primary -> CASE compstmt when END .)
    RPAREN          reduce using rule 105 (primary -> CASE compstmt when END .)
    WHEN            reduce using rule 105 (primary -> CASE compstmt when END .)
    LKEY            reduce using rule 105 (primary -> CASE compstmt when END .)
    END             reduce using rule 105 (primary -> CASE compstmt when END .)
    ELSIF           reduce using rule 105 (primary -> CASE compstmt when END .)
    ELSE            reduce using rule 105 (primary -> CASE compstmt when END .)
    ENSURE          reduce using rule 105 (primary -> CASE compstmt when END .)
    NOT_SYMBOL      reduce using rule 105 (primary -> CASE compstmt when END .)
    COMPLEMENT_OP   reduce using rule 105 (primary -> CASE compstmt when END .)
    DEFINED_OP      reduce using rule 105 (primary -> CASE compstmt when END .)
    NUMBER          reduce using rule 105 (primary -> CASE compstmt when END .)
    LPAREN          reduce using rule 105 (primary -> CASE compstmt when END .)
    RETURN          reduce using rule 105 (primary -> CASE compstmt when END .)
    YIELD           reduce using rule 105 (primary -> CASE compstmt when END .)
    CASE            reduce using rule 105 (primary -> CASE compstmt when END .)
    FOR             reduce using rule 105 (primary -> CASE compstmt when END .)
    BEGIN           reduce using rule 105 (primary -> CASE compstmt when END .)
    CLASS           reduce using rule 105 (primary -> CASE compstmt when END .)
    MODULE          reduce using rule 105 (primary -> CASE compstmt when END .)
    DEF             reduce using rule 105 (primary -> CASE compstmt when END .)
    VAR_GLOBAL      reduce using rule 105 (primary -> CASE compstmt when END .)
    VAR_LOCAL       reduce using rule 105 (primary -> CASE compstmt when END .)
    VAR_INSTANCE    reduce using rule 105 (primary -> CASE compstmt when END .)
    VAR_CLASS       reduce using rule 105 (primary -> CASE compstmt when END .)
    SYMBOL          reduce using rule 105 (primary -> CASE compstmt when END .)
    STRING          reduce using rule 105 (primary -> CASE compstmt when END .)
    IDENTIFIER      reduce using rule 105 (primary -> CASE compstmt when END .)
    SUPER           reduce using rule 105 (primary -> CASE compstmt when END .)


state 414

    (106) primary -> CASE compstmt when ELSE . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 468
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 415

    (121) when -> when WHEN . when_args then compstmt
    (126) when_args -> . args
    (127) when_args -> . args COMMA TIMES arg
    (128) when_args -> . TIMES arg
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 418
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    when_args                      shift and go to state 469
    args                           shift and go to state 417
    arg                            shift and go to state 70
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 416

    (120) when -> WHEN when_args . then compstmt
    (129) then -> . TERM
    (130) then -> . THEN
    (131) then -> . TERM THEN

    TERM            shift and go to state 248
    THEN            shift and go to state 249

    then                           shift and go to state 470

state 417

    (126) when_args -> args .
    (127) when_args -> args . COMMA TIMES arg

    TERM            reduce using rule 126 (when_args -> args .)
    THEN            reduce using rule 126 (when_args -> args .)
    COMMA           shift and go to state 471


state 418

    (128) when_args -> TIMES . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 472
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 419

    (107) primary -> FOR block_var IN expr . do compstmt END
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    AND             shift and go to state 58
    OR              shift and go to state 59
    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 473
    term                           shift and go to state 61

state 420

    (93) primary -> DEFINED_OP LPAREN arg . LPAREN
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

    LPAREN          shift and go to state 411
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189


state 421

    (112) primary -> CLASS IDENTIFIER compstmt END .

    LBRACKET        reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    DOT             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    UNARY_OP        reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RANGE_INCLUSIVE reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    OR_SYMBOL       reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    BINARY_XOR_OP   reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    BINARY_AND_OP   reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    GREATERTHAN     reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    GREATERTHANEQUAL reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    LESSERTHAN      reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    LESSERTHANEQUAL reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    EQUAL           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    CASE_EQUALITY   reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    NOTEQUAL        reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    AND             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    OR              reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    PLUS            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    MINUS           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    TIMES           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    DIVIDE          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    MOD             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    POW             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    IF              reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    WHILE           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    UNLESS          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    UNTIL           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    TERM            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    $end            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    COMMA           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RBRACKET        reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    THEN            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    DO              reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RESCUE          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    HASH_ROCKET     reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RKEY            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RPAREN          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    WHEN            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    LKEY            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    END             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    ELSIF           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    ELSE            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    ENSURE          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    NOT_SYMBOL      reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    COMPLEMENT_OP   reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    DEFINED_OP      reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    NUMBER          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    LPAREN          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    RETURN          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    YIELD           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    CASE            reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    FOR             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    BEGIN           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    CLASS           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    MODULE          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    DEF             reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    VAR_GLOBAL      reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    VAR_LOCAL       reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    VAR_INSTANCE    reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    VAR_CLASS       reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    SYMBOL          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    STRING          reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    IDENTIFIER      reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)
    SUPER           reduce using rule 112 (primary -> CLASS IDENTIFIER compstmt END .)


state 422

    (113) primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 474
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 423

    (114) primary -> MODULE IDENTIFIER compstmt END .

    LBRACKET        reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    DOT             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    UNARY_OP        reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RANGE_INCLUSIVE reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    OR_SYMBOL       reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    BINARY_XOR_OP   reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    BINARY_AND_OP   reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    GREATERTHAN     reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    GREATERTHANEQUAL reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    LESSERTHAN      reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    LESSERTHANEQUAL reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    EQUAL           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    CASE_EQUALITY   reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    NOTEQUAL        reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    AND             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    OR              reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    PLUS            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    MINUS           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    TIMES           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    DIVIDE          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    MOD             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    POW             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    IF              reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    WHILE           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    UNLESS          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    UNTIL           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    TERM            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    $end            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    COMMA           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RBRACKET        reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    THEN            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    DO              reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RESCUE          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    HASH_ROCKET     reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RKEY            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RPAREN          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    WHEN            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    LKEY            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    END             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    ELSIF           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    ELSE            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    ENSURE          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    NOT_SYMBOL      reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    COMPLEMENT_OP   reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    DEFINED_OP      reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    NUMBER          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    LPAREN          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    RETURN          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    YIELD           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    CASE            reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    FOR             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    BEGIN           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    CLASS           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    MODULE          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    DEF             reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    VAR_GLOBAL      reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    VAR_LOCAL       reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    VAR_INSTANCE    reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    VAR_CLASS       reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    SYMBOL          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    STRING          reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    IDENTIFIER      reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)
    SUPER           reduce using rule 114 (primary -> MODULE IDENTIFIER compstmt END .)


state 424

    (115) primary -> DEF fname argdecl compstmt . END

    END             shift and go to state 475


state 425

    (157) argdecl -> LPAREN arglist . RPAREN

    RPAREN          shift and go to state 476


state 426

    (158) argdecl -> arglist term .

    LBRACKET        reduce using rule 158 (argdecl -> arglist term .)
    UNDEF           reduce using rule 158 (argdecl -> arglist term .)
    ALIAS           reduce using rule 158 (argdecl -> arglist term .)
    BEGIN           reduce using rule 158 (argdecl -> arglist term .)
    END             reduce using rule 158 (argdecl -> arglist term .)
    RETURN          reduce using rule 158 (argdecl -> arglist term .)
    YIELD           reduce using rule 158 (argdecl -> arglist term .)
    NOT             reduce using rule 158 (argdecl -> arglist term .)
    NOT_SYMBOL      reduce using rule 158 (argdecl -> arglist term .)
    SUPER           reduce using rule 158 (argdecl -> arglist term .)
    VAR_GLOBAL      reduce using rule 158 (argdecl -> arglist term .)
    VAR_LOCAL       reduce using rule 158 (argdecl -> arglist term .)
    VAR_INSTANCE    reduce using rule 158 (argdecl -> arglist term .)
    VAR_CLASS       reduce using rule 158 (argdecl -> arglist term .)
    LPAREN          reduce using rule 158 (argdecl -> arglist term .)
    UNARY_OP        reduce using rule 158 (argdecl -> arglist term .)
    LKEY            reduce using rule 158 (argdecl -> arglist term .)
    DEFINED_OP      reduce using rule 158 (argdecl -> arglist term .)
    IF              reduce using rule 158 (argdecl -> arglist term .)
    UNLESS          reduce using rule 158 (argdecl -> arglist term .)
    WHILE           reduce using rule 158 (argdecl -> arglist term .)
    UNTIL           reduce using rule 158 (argdecl -> arglist term .)
    CASE            reduce using rule 158 (argdecl -> arglist term .)
    FOR             reduce using rule 158 (argdecl -> arglist term .)
    CLASS           reduce using rule 158 (argdecl -> arglist term .)
    MODULE          reduce using rule 158 (argdecl -> arglist term .)
    DEF             reduce using rule 158 (argdecl -> arglist term .)
    TIMES           reduce using rule 158 (argdecl -> arglist term .)
    PLUS            reduce using rule 158 (argdecl -> arglist term .)
    MINUS           reduce using rule 158 (argdecl -> arglist term .)
    COMPLEMENT_OP   reduce using rule 158 (argdecl -> arglist term .)
    IDENTIFIER      reduce using rule 158 (argdecl -> arglist term .)
    NUMBER          reduce using rule 158 (argdecl -> arglist term .)
    SYMBOL          reduce using rule 158 (argdecl -> arglist term .)
    STRING          reduce using rule 158 (argdecl -> arglist term .)


state 427

    (160) arglist -> IDENTIFIER COMMA . IDENTIFIER
    (161) arglist -> IDENTIFIER COMMA . & IDENTIFIER

    IDENTIFIER      shift and go to state 477
    &               shift and go to state 478


state 428

    (116) primary -> DEF singleton DOT fname . argdecl compstmt END
    (157) argdecl -> . LPAREN arglist RPAREN
    (158) argdecl -> . arglist term
    (159) arglist -> . IDENTIFIER
    (160) arglist -> . IDENTIFIER COMMA IDENTIFIER
    (161) arglist -> . IDENTIFIER COMMA & IDENTIFIER

    LPAREN          shift and go to state 338
    IDENTIFIER      shift and go to state 340

    argdecl                        shift and go to state 479
    arglist                        shift and go to state 339

state 429

    (117) primary -> DEF singleton UNARY_OP fname . argdecl compstmt END
    (157) argdecl -> . LPAREN arglist RPAREN
    (158) argdecl -> . arglist term
    (159) arglist -> . IDENTIFIER
    (160) arglist -> . IDENTIFIER COMMA IDENTIFIER
    (161) arglist -> . IDENTIFIER COMMA & IDENTIFIER

    LPAREN          shift and go to state 338
    IDENTIFIER      shift and go to state 340

    argdecl                        shift and go to state 480
    arglist                        shift and go to state 339

state 430

    (163) singleton -> LPAREN expr RPAREN .

    DOT             reduce using rule 163 (singleton -> LPAREN expr RPAREN .)
    UNARY_OP        reduce using rule 163 (singleton -> LPAREN expr RPAREN .)


state 431

    (147) mlhs -> mlhs_item COMMA mlhs_item TIMES .

    =               reduce using rule 147 (mlhs -> mlhs_item COMMA mlhs_item TIMES .)
    RBRACKET        reduce using rule 147 (mlhs -> mlhs_item COMMA mlhs_item TIMES .)
    RPAREN          reduce using rule 147 (mlhs -> mlhs_item COMMA mlhs_item TIMES .)
    IN              reduce using rule 147 (mlhs -> mlhs_item COMMA mlhs_item TIMES .)
    OR_SYMBOL       reduce using rule 147 (mlhs -> mlhs_item COMMA mlhs_item TIMES .)


state 432

    (148) mlhs -> mlhs_item COMMA mlhs_item lhs .

    =               reduce using rule 148 (mlhs -> mlhs_item COMMA mlhs_item lhs .)
    RBRACKET        reduce using rule 148 (mlhs -> mlhs_item COMMA mlhs_item lhs .)
    RPAREN          reduce using rule 148 (mlhs -> mlhs_item COMMA mlhs_item lhs .)
    IN              reduce using rule 148 (mlhs -> mlhs_item COMMA mlhs_item lhs .)
    OR_SYMBOL       reduce using rule 148 (mlhs -> mlhs_item COMMA mlhs_item lhs .)


state 433

    (152) mult_mlhs_item -> COMMA mlhs_item .

    TIMES           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    VAR_GLOBAL      reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    VAR_LOCAL       reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    VAR_INSTANCE    reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    VAR_CLASS       reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    LPAREN          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    UNARY_OP        reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    LBRACKET        reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    LKEY            reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    RETURN          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    YIELD           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    DEFINED_OP      reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    IF              reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    UNLESS          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    WHILE           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    UNTIL           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    CASE            reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    FOR             reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    BEGIN           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    CLASS           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    MODULE          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    DEF             reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    NUMBER          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    SYMBOL          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    STRING          reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    IDENTIFIER      reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)
    SUPER           reduce using rule 152 (mult_mlhs_item -> COMMA mlhs_item .)


state 434

    (149) mlhs -> mlhs_item COMMA mult_mlhs_item TIMES .

    =               reduce using rule 149 (mlhs -> mlhs_item COMMA mult_mlhs_item TIMES .)
    RBRACKET        reduce using rule 149 (mlhs -> mlhs_item COMMA mult_mlhs_item TIMES .)
    RPAREN          reduce using rule 149 (mlhs -> mlhs_item COMMA mult_mlhs_item TIMES .)
    IN              reduce using rule 149 (mlhs -> mlhs_item COMMA mult_mlhs_item TIMES .)
    OR_SYMBOL       reduce using rule 149 (mlhs -> mlhs_item COMMA mult_mlhs_item TIMES .)


state 435

    (150) mlhs -> mlhs_item COMMA mult_mlhs_item lhs .

    =               reduce using rule 150 (mlhs -> mlhs_item COMMA mult_mlhs_item lhs .)
    RBRACKET        reduce using rule 150 (mlhs -> mlhs_item COMMA mult_mlhs_item lhs .)
    RPAREN          reduce using rule 150 (mlhs -> mlhs_item COMMA mult_mlhs_item lhs .)
    IN              reduce using rule 150 (mlhs -> mlhs_item COMMA mult_mlhs_item lhs .)
    OR_SYMBOL       reduce using rule 150 (mlhs -> mlhs_item COMMA mult_mlhs_item lhs .)


state 436

    (7) stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 481
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 437

    (34) function -> primary DOT operation LPAREN . call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 457
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 438

    (35) function -> primary UNARY_OP operation LPAREN . call_args RPAREN
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    primary                        shift and go to state 114
    operation                      shift and go to state 113
    call_args                      shift and go to state 458
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 439

    (33) function -> operation LBRACKET LPAREN LBRACKET . call_args RBRACKET RPAREN RBRACKET
    (167) call_args -> . args
    (168) call_args -> . args COMMA assocs
    (169) call_args -> . args COMMA TIMES arg
    (170) call_args -> . args COMMA BINARY_AND_OP arg
    (171) call_args -> . args COMMA assocs COMMA TIMES arg
    (172) call_args -> . args COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> . args COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> . args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (175) call_args -> . assocs
    (176) call_args -> . assocs COMMA TIMES arg
    (177) call_args -> . assocs COMMA BINARY_AND_OP arg
    (178) call_args -> . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (179) call_args -> . TIMES arg
    (180) call_args -> . TIMES arg COMMA BINARY_AND_OP arg
    (181) call_args -> . BINARY_AND_OP arg
    (182) call_args -> . command
    (155) args -> . arg
    (156) args -> . arg COMMA arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (166) assoc -> . arg HASH_ROCKET arg
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    TIMES           shift and go to state 157
    BINARY_AND_OP   shift and go to state 158
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    IDENTIFIER      shift and go to state 21
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    operation                      shift and go to state 113
    call_args                      shift and go to state 465
    args                           shift and go to state 155
    assocs                         shift and go to state 156
    arg                            shift and go to state 126
    command                        shift and go to state 159
    assoc                          shift and go to state 127
    primary                        shift and go to state 114
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 440

    (98) primary -> IF expr then compstmt END .

    LBRACKET        reduce using rule 98 (primary -> IF expr then compstmt END .)
    DOT             reduce using rule 98 (primary -> IF expr then compstmt END .)
    UNARY_OP        reduce using rule 98 (primary -> IF expr then compstmt END .)
    RANGE_INCLUSIVE reduce using rule 98 (primary -> IF expr then compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 98 (primary -> IF expr then compstmt END .)
    OR_SYMBOL       reduce using rule 98 (primary -> IF expr then compstmt END .)
    BINARY_XOR_OP   reduce using rule 98 (primary -> IF expr then compstmt END .)
    BINARY_AND_OP   reduce using rule 98 (primary -> IF expr then compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 98 (primary -> IF expr then compstmt END .)
    GREATERTHAN     reduce using rule 98 (primary -> IF expr then compstmt END .)
    GREATERTHANEQUAL reduce using rule 98 (primary -> IF expr then compstmt END .)
    LESSERTHAN      reduce using rule 98 (primary -> IF expr then compstmt END .)
    LESSERTHANEQUAL reduce using rule 98 (primary -> IF expr then compstmt END .)
    EQUAL           reduce using rule 98 (primary -> IF expr then compstmt END .)
    CASE_EQUALITY   reduce using rule 98 (primary -> IF expr then compstmt END .)
    NOTEQUAL        reduce using rule 98 (primary -> IF expr then compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 98 (primary -> IF expr then compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 98 (primary -> IF expr then compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 98 (primary -> IF expr then compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 98 (primary -> IF expr then compstmt END .)
    AND             reduce using rule 98 (primary -> IF expr then compstmt END .)
    OR              reduce using rule 98 (primary -> IF expr then compstmt END .)
    PLUS            reduce using rule 98 (primary -> IF expr then compstmt END .)
    MINUS           reduce using rule 98 (primary -> IF expr then compstmt END .)
    TIMES           reduce using rule 98 (primary -> IF expr then compstmt END .)
    DIVIDE          reduce using rule 98 (primary -> IF expr then compstmt END .)
    MOD             reduce using rule 98 (primary -> IF expr then compstmt END .)
    POW             reduce using rule 98 (primary -> IF expr then compstmt END .)
    IF              reduce using rule 98 (primary -> IF expr then compstmt END .)
    WHILE           reduce using rule 98 (primary -> IF expr then compstmt END .)
    UNLESS          reduce using rule 98 (primary -> IF expr then compstmt END .)
    UNTIL           reduce using rule 98 (primary -> IF expr then compstmt END .)
    TERM            reduce using rule 98 (primary -> IF expr then compstmt END .)
    $end            reduce using rule 98 (primary -> IF expr then compstmt END .)
    COMMA           reduce using rule 98 (primary -> IF expr then compstmt END .)
    RBRACKET        reduce using rule 98 (primary -> IF expr then compstmt END .)
    THEN            reduce using rule 98 (primary -> IF expr then compstmt END .)
    DO              reduce using rule 98 (primary -> IF expr then compstmt END .)
    RESCUE          reduce using rule 98 (primary -> IF expr then compstmt END .)
    HASH_ROCKET     reduce using rule 98 (primary -> IF expr then compstmt END .)
    RKEY            reduce using rule 98 (primary -> IF expr then compstmt END .)
    RPAREN          reduce using rule 98 (primary -> IF expr then compstmt END .)
    WHEN            reduce using rule 98 (primary -> IF expr then compstmt END .)
    LKEY            reduce using rule 98 (primary -> IF expr then compstmt END .)
    END             reduce using rule 98 (primary -> IF expr then compstmt END .)
    ELSIF           reduce using rule 98 (primary -> IF expr then compstmt END .)
    ELSE            reduce using rule 98 (primary -> IF expr then compstmt END .)
    ENSURE          reduce using rule 98 (primary -> IF expr then compstmt END .)
    NOT_SYMBOL      reduce using rule 98 (primary -> IF expr then compstmt END .)
    COMPLEMENT_OP   reduce using rule 98 (primary -> IF expr then compstmt END .)
    DEFINED_OP      reduce using rule 98 (primary -> IF expr then compstmt END .)
    NUMBER          reduce using rule 98 (primary -> IF expr then compstmt END .)
    LPAREN          reduce using rule 98 (primary -> IF expr then compstmt END .)
    RETURN          reduce using rule 98 (primary -> IF expr then compstmt END .)
    YIELD           reduce using rule 98 (primary -> IF expr then compstmt END .)
    CASE            reduce using rule 98 (primary -> IF expr then compstmt END .)
    FOR             reduce using rule 98 (primary -> IF expr then compstmt END .)
    BEGIN           reduce using rule 98 (primary -> IF expr then compstmt END .)
    CLASS           reduce using rule 98 (primary -> IF expr then compstmt END .)
    MODULE          reduce using rule 98 (primary -> IF expr then compstmt END .)
    DEF             reduce using rule 98 (primary -> IF expr then compstmt END .)
    VAR_GLOBAL      reduce using rule 98 (primary -> IF expr then compstmt END .)
    VAR_LOCAL       reduce using rule 98 (primary -> IF expr then compstmt END .)
    VAR_INSTANCE    reduce using rule 98 (primary -> IF expr then compstmt END .)
    VAR_CLASS       reduce using rule 98 (primary -> IF expr then compstmt END .)
    SYMBOL          reduce using rule 98 (primary -> IF expr then compstmt END .)
    STRING          reduce using rule 98 (primary -> IF expr then compstmt END .)
    IDENTIFIER      reduce using rule 98 (primary -> IF expr then compstmt END .)
    SUPER           reduce using rule 98 (primary -> IF expr then compstmt END .)


state 441

    (99) primary -> IF expr then compstmt elsif . END
    (100) primary -> IF expr then compstmt elsif . ELSE compstmt END

    END             shift and go to state 482
    ELSE            shift and go to state 483


state 442

    (118) elsif -> ELSIF . expr then compstmt
    (119) elsif -> ELSIF . expr then compstmt elsif
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER

    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    TIMES           shift and go to state 44
    SUPER           shift and go to state 115
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    LPAREN          shift and go to state 116
    IDENTIFIER      shift and go to state 21
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 79
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35

    expr                           shift and go to state 484
    mlhs                           shift and go to state 22
    command                        shift and go to state 111
    arg                            shift and go to state 27
    mlhs_item                      shift and go to state 43
    lhs                            shift and go to state 112
    operation                      shift and go to state 113
    primary                        shift and go to state 114
    math_operations                shift and go to state 45
    literal                        shift and go to state 36
    variable                       shift and go to state 117
    function                       shift and go to state 77

state 443

    (78) primary -> primary LBRACKET args RBRACKET .
    (143) lhs -> primary LBRACKET args RBRACKET .

  ! reduce/reduce conflict for COMMA resolved using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DOT             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    UNARY_OP        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LBRACKET        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    OR_SYMBOL       reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_XOR_OP   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_AND_OP   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    GREATERTHAN     reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    GREATERTHANEQUAL reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LESSERTHAN      reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LESSERTHANEQUAL reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    EQUAL           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    CASE_EQUALITY   reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    NOTEQUAL        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    AND             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    OR              reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    PLUS            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MINUS           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    TIMES           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DIVIDE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    MOD             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    POW             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    TERM            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    THEN            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    DO              reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    COMMA           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    HASH_ROCKET     reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    IF              reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    WHILE           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    UNLESS          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    UNTIL           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    $end            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RESCUE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RPAREN          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    WHEN            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RKEY            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    LKEY            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    END             reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    ELSIF           reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    ELSE            reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    ENSURE          reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    RBRACKET        reduce using rule 78 (primary -> primary LBRACKET args RBRACKET .)
    =               reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    PLUS_EQUAL      reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    MINUS_EQUAL     reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    TIMES_EQUAL     reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    DIVIDE_EQUAL    reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    MOD_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    POW_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    SINGLE_AND_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    SINGLE_OR_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    XOR_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    BINARY_LEFT_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    BINARY_RIGHT_EQUAL reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    AND_EQUAL       reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)
    OR_EQUAL        reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .)

  ! COMMA           [ reduce using rule 143 (lhs -> primary LBRACKET args RBRACKET .) ]


state 444

    (103) primary -> WHILE expr do compstmt END .

    LBRACKET        reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    DOT             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    UNARY_OP        reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RANGE_INCLUSIVE reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    OR_SYMBOL       reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    BINARY_XOR_OP   reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    BINARY_AND_OP   reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    GREATERTHAN     reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    GREATERTHANEQUAL reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    LESSERTHAN      reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    LESSERTHANEQUAL reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    EQUAL           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    CASE_EQUALITY   reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    NOTEQUAL        reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    AND             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    OR              reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    PLUS            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    MINUS           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    TIMES           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    DIVIDE          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    MOD             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    POW             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    IF              reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    WHILE           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    UNLESS          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    UNTIL           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    TERM            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    $end            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    COMMA           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RBRACKET        reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    THEN            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    DO              reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RESCUE          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    HASH_ROCKET     reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RKEY            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RPAREN          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    WHEN            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    LKEY            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    END             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    ELSIF           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    ELSE            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    ENSURE          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    NOT_SYMBOL      reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    COMPLEMENT_OP   reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    DEFINED_OP      reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    NUMBER          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    LPAREN          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    RETURN          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    YIELD           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    CASE            reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    FOR             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    BEGIN           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    CLASS           reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    MODULE          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    DEF             reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    VAR_GLOBAL      reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    VAR_LOCAL       reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    VAR_INSTANCE    reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    VAR_CLASS       reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    SYMBOL          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    STRING          reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    IDENTIFIER      reduce using rule 103 (primary -> WHILE expr do compstmt END .)
    SUPER           reduce using rule 103 (primary -> WHILE expr do compstmt END .)


state 445

    (101) primary -> UNLESS expr then compstmt END .

    LBRACKET        reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    DOT             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    UNARY_OP        reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RANGE_INCLUSIVE reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    OR_SYMBOL       reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    BINARY_XOR_OP   reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    BINARY_AND_OP   reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    GREATERTHAN     reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    GREATERTHANEQUAL reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    LESSERTHAN      reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    LESSERTHANEQUAL reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    EQUAL           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    CASE_EQUALITY   reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    NOTEQUAL        reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    AND             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    OR              reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    PLUS            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    MINUS           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    TIMES           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    DIVIDE          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    MOD             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    POW             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    IF              reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    WHILE           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    UNLESS          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    UNTIL           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    TERM            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    $end            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    COMMA           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RBRACKET        reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    THEN            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    DO              reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RESCUE          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    HASH_ROCKET     reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RKEY            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RPAREN          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    WHEN            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    LKEY            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    END             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    ELSIF           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    ELSE            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    ENSURE          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    NOT_SYMBOL      reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    COMPLEMENT_OP   reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    DEFINED_OP      reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    NUMBER          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    LPAREN          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    RETURN          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    YIELD           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    CASE            reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    FOR             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    BEGIN           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    CLASS           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    MODULE          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    DEF             reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    VAR_GLOBAL      reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    VAR_LOCAL       reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    VAR_INSTANCE    reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    VAR_CLASS       reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    SYMBOL          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    STRING          reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    IDENTIFIER      reduce using rule 101 (primary -> UNLESS expr then compstmt END .)
    SUPER           reduce using rule 101 (primary -> UNLESS expr then compstmt END .)


state 446

    (102) primary -> UNLESS expr then compstmt ELSE . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 485
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 447

    (104) primary -> UNTIL expr do compstmt END .

    LBRACKET        reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    DOT             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    UNARY_OP        reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RANGE_INCLUSIVE reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    OR_SYMBOL       reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    BINARY_XOR_OP   reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    BINARY_AND_OP   reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    GREATERTHAN     reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    GREATERTHANEQUAL reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    LESSERTHAN      reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    LESSERTHANEQUAL reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    EQUAL           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    CASE_EQUALITY   reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    NOTEQUAL        reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    AND             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    OR              reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    PLUS            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    MINUS           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    TIMES           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    DIVIDE          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    MOD             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    POW             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    IF              reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    WHILE           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    UNLESS          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    UNTIL           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    TERM            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    $end            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    COMMA           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RBRACKET        reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    THEN            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    DO              reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RESCUE          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    HASH_ROCKET     reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RKEY            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RPAREN          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    WHEN            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    LKEY            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    END             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    ELSIF           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    ELSE            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    ENSURE          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    NOT_SYMBOL      reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    COMPLEMENT_OP   reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    DEFINED_OP      reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    NUMBER          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    LPAREN          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    RETURN          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    YIELD           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    CASE            reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    FOR             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    BEGIN           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    CLASS           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    MODULE          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    DEF             reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    VAR_GLOBAL      reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    VAR_LOCAL       reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    VAR_INSTANCE    reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    VAR_CLASS       reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    SYMBOL          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    STRING          reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    IDENTIFIER      reduce using rule 104 (primary -> UNTIL expr do compstmt END .)
    SUPER           reduce using rule 104 (primary -> UNTIL expr do compstmt END .)


state 448

    (109) primary -> BEGIN compstmt rescue ELSE compstmt . END
    (111) primary -> BEGIN compstmt rescue ELSE compstmt . ENSURE compstmt END

    END             shift and go to state 486
    ENSURE          shift and go to state 487


state 449

    (110) primary -> BEGIN compstmt rescue ENSURE compstmt . END

    END             shift and go to state 488


state 450

    (124) rescue -> rescue RESCUE args . do compstmt
    (132) do -> . term
    (133) do -> . DO
    (134) do -> . term DO
    (135) term -> . TERM

    DO              shift and go to state 62
    TERM            shift and go to state 57

    do                             shift and go to state 489
    term                           shift and go to state 61

state 451

    (125) rescue -> rescue RESCUE do . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 490
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 452

    (122) rescue -> RESCUE args do . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 491
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 453

    (123) rescue -> RESCUE do compstmt .

    END             reduce using rule 123 (rescue -> RESCUE do compstmt .)
    ELSE            reduce using rule 123 (rescue -> RESCUE do compstmt .)
    ENSURE          reduce using rule 123 (rescue -> RESCUE do compstmt .)
    RESCUE          reduce using rule 123 (rescue -> RESCUE do compstmt .)


state 454

    (16) stmt -> lhs = command LBRACKET do . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET

    LBRACKET        shift and go to state 492


state 455

    (96) primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt . LKEY

    LKEY            shift and go to state 493


state 456

    (97) primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL . compstmt LKEY
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    function                       shift and go to state 18
    compstmt                       shift and go to state 494
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 457

    (34) function -> primary DOT operation LPAREN call_args . RPAREN

    RPAREN          shift and go to state 495


state 458

    (35) function -> primary UNARY_OP operation LPAREN call_args . RPAREN

    RPAREN          shift and go to state 496


state 459

    (171) call_args -> args COMMA assocs COMMA . TIMES arg
    (172) call_args -> args COMMA assocs COMMA . BINARY_AND_OP arg
    (174) call_args -> args COMMA assocs COMMA . TIMES arg COMMA BINARY_AND_OP arg

    TIMES           shift and go to state 497
    BINARY_AND_OP   shift and go to state 498


state 460

    (169) call_args -> args COMMA TIMES arg .
    (173) call_args -> args COMMA TIMES arg . COMMA BINARY_AND_OP arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    WHILE           reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    UNLESS          reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    UNTIL           reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    TERM            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    $end            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    THEN            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    DO              reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    RESCUE          reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    RPAREN          reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    WHEN            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    RKEY            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    LKEY            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    END             reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    ELSIF           reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    ELSE            reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    ENSURE          reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    LBRACKET        reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    RBRACKET        reduce using rule 169 (call_args -> args COMMA TIMES arg .)
    COMMA           shift and go to state 499
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 169 (call_args -> args COMMA TIMES arg .) ]
  ! OR              [ reduce using rule 169 (call_args -> args COMMA TIMES arg .) ]


state 461

    (170) call_args -> args COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    END             reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 170 (call_args -> args COMMA BINARY_AND_OP arg .) ]


state 462

    (176) call_args -> assocs COMMA TIMES arg .
    (178) call_args -> assocs COMMA TIMES arg . COMMA BINARY_AND_OP arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    WHILE           reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    UNLESS          reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    UNTIL           reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    TERM            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    $end            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    THEN            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    DO              reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    RESCUE          reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    RPAREN          reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    WHEN            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    RKEY            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    LKEY            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    END             reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    ELSIF           reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    ELSE            reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    ENSURE          reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    LBRACKET        reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    RBRACKET        reduce using rule 176 (call_args -> assocs COMMA TIMES arg .)
    COMMA           shift and go to state 500
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 176 (call_args -> assocs COMMA TIMES arg .) ]
  ! OR              [ reduce using rule 176 (call_args -> assocs COMMA TIMES arg .) ]


state 463

    (177) call_args -> assocs COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    END             reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 177 (call_args -> assocs COMMA BINARY_AND_OP arg .) ]


state 464

    (180) call_args -> TIMES arg COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 501
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 465

    (33) function -> operation LBRACKET LPAREN LBRACKET call_args . RBRACKET RPAREN RBRACKET

    RBRACKET        shift and go to state 502


state 466

    (80) primary -> LBRACKET args . RBRACKET
    (81) primary -> LBRACKET args . COMMA RBRACKET
    (167) call_args -> args .
    (168) call_args -> args . COMMA assocs
    (169) call_args -> args . COMMA TIMES arg
    (170) call_args -> args . COMMA BINARY_AND_OP arg
    (171) call_args -> args . COMMA assocs COMMA TIMES arg
    (172) call_args -> args . COMMA assocs COMMA BINARY_AND_OP arg
    (173) call_args -> args . COMMA TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> args . COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg

  ! shift/reduce conflict for RBRACKET resolved as shift
    RBRACKET        shift and go to state 234
    COMMA           shift and go to state 503

  ! RBRACKET        [ reduce using rule 167 (call_args -> args .) ]


state 467

    (30) command -> primary . DOT operation call_args
    (31) command -> primary . UNARY_OP operation call_args
    (142) lhs -> primary . LBRACKET RBRACKET
    (143) lhs -> primary . LBRACKET args RBRACKET
    (144) lhs -> primary . DOT IDENTIFIER
    (67) arg -> primary .
    (75) primary -> primary . UNARY_OP IDENTIFIER
    (77) primary -> primary . LBRACKET RBRACKET
    (78) primary -> primary . LBRACKET args RBRACKET
    (34) function -> primary . DOT operation LPAREN call_args RPAREN
    (35) function -> primary . UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> primary . DOT operation
    (37) function -> primary . UNARY_OP operation

    DOT             shift and go to state 250
    UNARY_OP        shift and go to state 251
    LBRACKET        shift and go to state 147
    COMMA           reduce using rule 67 (arg -> primary .)
    RANGE_INCLUSIVE reduce using rule 67 (arg -> primary .)
    RANGE_EXCLUSIVE reduce using rule 67 (arg -> primary .)
    OR_SYMBOL       reduce using rule 67 (arg -> primary .)
    BINARY_XOR_OP   reduce using rule 67 (arg -> primary .)
    BINARY_AND_OP   reduce using rule 67 (arg -> primary .)
    COMBINED_COMPARISON_OP reduce using rule 67 (arg -> primary .)
    GREATERTHAN     reduce using rule 67 (arg -> primary .)
    GREATERTHANEQUAL reduce using rule 67 (arg -> primary .)
    LESSERTHAN      reduce using rule 67 (arg -> primary .)
    LESSERTHANEQUAL reduce using rule 67 (arg -> primary .)
    EQUAL           reduce using rule 67 (arg -> primary .)
    CASE_EQUALITY   reduce using rule 67 (arg -> primary .)
    NOTEQUAL        reduce using rule 67 (arg -> primary .)
    MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 67 (arg -> primary .)
    BINARY_LEFT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 67 (arg -> primary .)
    AND             reduce using rule 67 (arg -> primary .)
    OR              reduce using rule 67 (arg -> primary .)
    HASH_ROCKET     reduce using rule 67 (arg -> primary .)
    PLUS            reduce using rule 67 (arg -> primary .)
    MINUS           reduce using rule 67 (arg -> primary .)
    TIMES           reduce using rule 67 (arg -> primary .)
    DIVIDE          reduce using rule 67 (arg -> primary .)
    MOD             reduce using rule 67 (arg -> primary .)
    POW             reduce using rule 67 (arg -> primary .)
    RBRACKET        reduce using rule 67 (arg -> primary .)


state 468

    (106) primary -> CASE compstmt when ELSE compstmt . END

    END             shift and go to state 504


state 469

    (121) when -> when WHEN when_args . then compstmt
    (129) then -> . TERM
    (130) then -> . THEN
    (131) then -> . TERM THEN

    TERM            shift and go to state 248
    THEN            shift and go to state 249

    then                           shift and go to state 505

state 470

    (120) when -> WHEN when_args then . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 506
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 471

    (127) when_args -> args COMMA . TIMES arg

    TIMES           shift and go to state 507


state 472

    (128) when_args -> TIMES arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

    TERM            reduce using rule 128 (when_args -> TIMES arg .)
    THEN            reduce using rule 128 (when_args -> TIMES arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189


state 473

    (107) primary -> FOR block_var IN expr do . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 508
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 474

    (113) primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt . END

    END             shift and go to state 509


state 475

    (115) primary -> DEF fname argdecl compstmt END .

    LBRACKET        reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    DOT             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    UNARY_OP        reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RANGE_INCLUSIVE reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    OR_SYMBOL       reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    BINARY_XOR_OP   reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    BINARY_AND_OP   reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    GREATERTHAN     reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    GREATERTHANEQUAL reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    LESSERTHAN      reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    LESSERTHANEQUAL reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    EQUAL           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    CASE_EQUALITY   reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    NOTEQUAL        reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    AND             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    OR              reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    PLUS            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    MINUS           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    TIMES           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    DIVIDE          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    MOD             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    POW             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    IF              reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    WHILE           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    UNLESS          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    UNTIL           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    TERM            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    $end            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    COMMA           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RBRACKET        reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    THEN            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    DO              reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RESCUE          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    HASH_ROCKET     reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RKEY            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RPAREN          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    WHEN            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    LKEY            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    END             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    ELSIF           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    ELSE            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    ENSURE          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    NOT_SYMBOL      reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    COMPLEMENT_OP   reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    DEFINED_OP      reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    NUMBER          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    LPAREN          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    RETURN          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    YIELD           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    CASE            reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    FOR             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    BEGIN           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    CLASS           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    MODULE          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    DEF             reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    VAR_GLOBAL      reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    VAR_LOCAL       reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    VAR_INSTANCE    reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    VAR_CLASS       reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    SYMBOL          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    STRING          reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    IDENTIFIER      reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)
    SUPER           reduce using rule 115 (primary -> DEF fname argdecl compstmt END .)


state 476

    (157) argdecl -> LPAREN arglist RPAREN .

    LBRACKET        reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    UNDEF           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    ALIAS           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    BEGIN           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    END             reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    RETURN          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    YIELD           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    NOT             reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    NOT_SYMBOL      reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    SUPER           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    VAR_GLOBAL      reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    VAR_LOCAL       reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    VAR_INSTANCE    reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    VAR_CLASS       reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    LPAREN          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    UNARY_OP        reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    LKEY            reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    DEFINED_OP      reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    IF              reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    UNLESS          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    WHILE           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    UNTIL           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    CASE            reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    FOR             reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    CLASS           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    MODULE          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    DEF             reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    TIMES           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    PLUS            reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    MINUS           reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    COMPLEMENT_OP   reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    IDENTIFIER      reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    NUMBER          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    SYMBOL          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)
    STRING          reduce using rule 157 (argdecl -> LPAREN arglist RPAREN .)


state 477

    (160) arglist -> IDENTIFIER COMMA IDENTIFIER .

    TERM            reduce using rule 160 (arglist -> IDENTIFIER COMMA IDENTIFIER .)
    RPAREN          reduce using rule 160 (arglist -> IDENTIFIER COMMA IDENTIFIER .)


state 478

    (161) arglist -> IDENTIFIER COMMA & . IDENTIFIER

    IDENTIFIER      shift and go to state 510


state 479

    (116) primary -> DEF singleton DOT fname argdecl . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 511
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 480

    (117) primary -> DEF singleton UNARY_OP fname argdecl . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 512
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 481

    (7) stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt . END

    END             shift and go to state 513


state 482

    (99) primary -> IF expr then compstmt elsif END .

    LBRACKET        reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    DOT             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    UNARY_OP        reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RANGE_INCLUSIVE reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RANGE_EXCLUSIVE reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    OR_SYMBOL       reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    BINARY_XOR_OP   reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    BINARY_AND_OP   reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    COMBINED_COMPARISON_OP reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    GREATERTHAN     reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    GREATERTHANEQUAL reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    LESSERTHAN      reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    LESSERTHANEQUAL reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    EQUAL           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    CASE_EQUALITY   reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    NOTEQUAL        reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    MATCHED_STRINGS_OP reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    AND             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    OR              reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    PLUS            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    MINUS           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    TIMES           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    DIVIDE          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    MOD             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    POW             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    IF              reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    WHILE           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    UNLESS          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    UNTIL           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    TERM            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    $end            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    COMMA           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RBRACKET        reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    THEN            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    DO              reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RESCUE          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    HASH_ROCKET     reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RKEY            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RPAREN          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    WHEN            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    LKEY            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    END             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    ELSIF           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    ELSE            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    ENSURE          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    NOT_SYMBOL      reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    COMPLEMENT_OP   reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    DEFINED_OP      reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    NUMBER          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    LPAREN          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    RETURN          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    YIELD           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    CASE            reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    FOR             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    BEGIN           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    CLASS           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    MODULE          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    DEF             reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    VAR_GLOBAL      reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    VAR_LOCAL       reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    VAR_INSTANCE    reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    VAR_CLASS       reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    SYMBOL          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    STRING          reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    IDENTIFIER      reduce using rule 99 (primary -> IF expr then compstmt elsif END .)
    SUPER           reduce using rule 99 (primary -> IF expr then compstmt elsif END .)


state 483

    (100) primary -> IF expr then compstmt elsif ELSE . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 514
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 484

    (118) elsif -> ELSIF expr . then compstmt
    (119) elsif -> ELSIF expr . then compstmt elsif
    (21) expr -> expr . AND expr
    (22) expr -> expr . OR expr
    (129) then -> . TERM
    (130) then -> . THEN
    (131) then -> . TERM THEN

    AND             shift and go to state 58
    OR              shift and go to state 59
    TERM            shift and go to state 248
    THEN            shift and go to state 249

    then                           shift and go to state 515

state 485

    (102) primary -> UNLESS expr then compstmt ELSE compstmt . END

    END             shift and go to state 516


state 486

    (109) primary -> BEGIN compstmt rescue ELSE compstmt END .

    LBRACKET        reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    DOT             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    UNARY_OP        reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RANGE_INCLUSIVE reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    OR_SYMBOL       reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    BINARY_XOR_OP   reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    BINARY_AND_OP   reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    GREATERTHAN     reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    GREATERTHANEQUAL reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    LESSERTHAN      reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    LESSERTHANEQUAL reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    EQUAL           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    CASE_EQUALITY   reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    NOTEQUAL        reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    AND             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    OR              reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    PLUS            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    MINUS           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    TIMES           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    DIVIDE          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    MOD             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    POW             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    IF              reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    WHILE           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    UNLESS          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    UNTIL           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    TERM            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    $end            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    COMMA           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RBRACKET        reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    THEN            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    DO              reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RESCUE          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    HASH_ROCKET     reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RKEY            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RPAREN          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    WHEN            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    LKEY            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    END             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    ELSIF           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    ELSE            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    ENSURE          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    NOT_SYMBOL      reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    COMPLEMENT_OP   reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    DEFINED_OP      reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    NUMBER          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    LPAREN          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    RETURN          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    YIELD           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    CASE            reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    FOR             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    BEGIN           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    CLASS           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    MODULE          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    DEF             reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    VAR_GLOBAL      reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    VAR_LOCAL       reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    VAR_INSTANCE    reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    VAR_CLASS       reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    SYMBOL          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    STRING          reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    IDENTIFIER      reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)
    SUPER           reduce using rule 109 (primary -> BEGIN compstmt rescue ELSE compstmt END .)


state 487

    (111) primary -> BEGIN compstmt rescue ELSE compstmt ENSURE . compstmt END
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 517
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 488

    (110) primary -> BEGIN compstmt rescue ENSURE compstmt END .

    LBRACKET        reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    DOT             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    UNARY_OP        reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RANGE_INCLUSIVE reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    OR_SYMBOL       reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    BINARY_XOR_OP   reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    BINARY_AND_OP   reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    GREATERTHAN     reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    GREATERTHANEQUAL reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    LESSERTHAN      reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    LESSERTHANEQUAL reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    EQUAL           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    CASE_EQUALITY   reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    NOTEQUAL        reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    AND             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    OR              reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    PLUS            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    MINUS           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    TIMES           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    DIVIDE          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    MOD             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    POW             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    IF              reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    WHILE           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    UNLESS          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    UNTIL           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    TERM            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    $end            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    COMMA           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RBRACKET        reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    THEN            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    DO              reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RESCUE          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    HASH_ROCKET     reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RKEY            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RPAREN          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    WHEN            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    LKEY            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    END             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    ELSIF           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    ELSE            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    ENSURE          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    NOT_SYMBOL      reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    COMPLEMENT_OP   reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    DEFINED_OP      reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    NUMBER          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    LPAREN          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    RETURN          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    YIELD           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    CASE            reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    FOR             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    BEGIN           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    CLASS           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    MODULE          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    DEF             reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    VAR_GLOBAL      reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    VAR_LOCAL       reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    VAR_INSTANCE    reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    VAR_CLASS       reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    SYMBOL          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    STRING          reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    IDENTIFIER      reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)
    SUPER           reduce using rule 110 (primary -> BEGIN compstmt rescue ENSURE compstmt END .)


state 489

    (124) rescue -> rescue RESCUE args do . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 518
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 490

    (125) rescue -> rescue RESCUE do compstmt .

    END             reduce using rule 125 (rescue -> rescue RESCUE do compstmt .)
    ELSE            reduce using rule 125 (rescue -> rescue RESCUE do compstmt .)
    ENSURE          reduce using rule 125 (rescue -> rescue RESCUE do compstmt .)
    RESCUE          reduce using rule 125 (rescue -> rescue RESCUE do compstmt .)


state 491

    (122) rescue -> RESCUE args do compstmt .

    END             reduce using rule 122 (rescue -> RESCUE args do compstmt .)
    ELSE            reduce using rule 122 (rescue -> RESCUE args do compstmt .)
    ENSURE          reduce using rule 122 (rescue -> RESCUE args do compstmt .)
    RESCUE          reduce using rule 122 (rescue -> RESCUE args do compstmt .)


state 492

    (16) stmt -> lhs = command LBRACKET do LBRACKET . OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET

    OR_SYMBOL       shift and go to state 519


state 493

    (96) primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .

    LBRACKET        reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    DOT             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    UNARY_OP        reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RANGE_INCLUSIVE reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RANGE_EXCLUSIVE reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    OR_SYMBOL       reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    BINARY_XOR_OP   reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    BINARY_AND_OP   reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    COMBINED_COMPARISON_OP reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    GREATERTHAN     reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    GREATERTHANEQUAL reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    LESSERTHAN      reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    LESSERTHANEQUAL reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    EQUAL           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    CASE_EQUALITY   reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    NOTEQUAL        reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    MATCHED_STRINGS_OP reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    AND             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    OR              reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    PLUS            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    MINUS           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    TIMES           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    DIVIDE          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    MOD             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    POW             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    IF              reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    WHILE           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    UNLESS          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    UNTIL           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    TERM            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    $end            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    COMMA           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RBRACKET        reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    THEN            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    DO              reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RESCUE          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    HASH_ROCKET     reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RKEY            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RPAREN          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    WHEN            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    LKEY            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    END             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    ELSIF           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    ELSE            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    ENSURE          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    NOT_SYMBOL      reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    COMPLEMENT_OP   reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    DEFINED_OP      reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    NUMBER          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    LPAREN          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    RETURN          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    YIELD           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    CASE            reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    FOR             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    BEGIN           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    CLASS           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    MODULE          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    DEF             reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    VAR_GLOBAL      reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    VAR_LOCAL       reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    VAR_INSTANCE    reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    VAR_CLASS       reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    SYMBOL          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    STRING          reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    IDENTIFIER      reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)
    SUPER           reduce using rule 96 (primary -> function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY .)


state 494

    (97) primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt . LKEY

    LKEY            shift and go to state 520


state 495

    (34) function -> primary DOT operation LPAREN call_args RPAREN .

    LKEY            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    DO              reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    TERM            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    LBRACKET        reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    DOT             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    UNARY_OP        reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RANGE_INCLUSIVE reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    OR_SYMBOL       reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    BINARY_XOR_OP   reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    BINARY_AND_OP   reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    GREATERTHAN     reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    GREATERTHANEQUAL reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    LESSERTHAN      reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    LESSERTHANEQUAL reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    EQUAL           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    CASE_EQUALITY   reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    NOTEQUAL        reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    AND             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    OR              reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    PLUS            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    MINUS           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    TIMES           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    DIVIDE          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    MOD             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    POW             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    IF              reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    WHILE           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    UNLESS          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    UNTIL           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    $end            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    COMMA           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RBRACKET        reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    THEN            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RESCUE          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    HASH_ROCKET     reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RKEY            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    WHEN            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    END             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    ELSIF           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    ELSE            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    ENSURE          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    NOT_SYMBOL      reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    COMPLEMENT_OP   reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    DEFINED_OP      reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    NUMBER          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    LPAREN          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    RETURN          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    YIELD           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    CASE            reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    FOR             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    BEGIN           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    CLASS           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    MODULE          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    DEF             reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    VAR_GLOBAL      reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    VAR_LOCAL       reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    VAR_INSTANCE    reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    VAR_CLASS       reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    SYMBOL          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    STRING          reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    IDENTIFIER      reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)
    SUPER           reduce using rule 34 (function -> primary DOT operation LPAREN call_args RPAREN .)


state 496

    (35) function -> primary UNARY_OP operation LPAREN call_args RPAREN .

    LKEY            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    DO              reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    TERM            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    LBRACKET        reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    DOT             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    UNARY_OP        reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RANGE_INCLUSIVE reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RANGE_EXCLUSIVE reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    OR_SYMBOL       reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    BINARY_XOR_OP   reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    BINARY_AND_OP   reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    COMBINED_COMPARISON_OP reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    GREATERTHAN     reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    GREATERTHANEQUAL reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    LESSERTHAN      reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    LESSERTHANEQUAL reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    EQUAL           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    CASE_EQUALITY   reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    NOTEQUAL        reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    MATCHED_STRINGS_OP reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    BINARY_LEFT_SHIFT_OP reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    AND             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    OR              reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    PLUS            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    MINUS           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    TIMES           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    DIVIDE          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    MOD             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    POW             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    IF              reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    WHILE           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    UNLESS          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    UNTIL           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    $end            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    COMMA           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RBRACKET        reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    THEN            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RESCUE          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    HASH_ROCKET     reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RKEY            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RPAREN          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    WHEN            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    END             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    ELSIF           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    ELSE            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    ENSURE          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    NOT_SYMBOL      reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    COMPLEMENT_OP   reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    DEFINED_OP      reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    NUMBER          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    LPAREN          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    RETURN          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    YIELD           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    CASE            reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    FOR             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    BEGIN           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    CLASS           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    MODULE          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    DEF             reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    VAR_GLOBAL      reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    VAR_LOCAL       reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    VAR_INSTANCE    reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    VAR_CLASS       reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    SYMBOL          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    STRING          reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    IDENTIFIER      reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)
    SUPER           reduce using rule 35 (function -> primary UNARY_OP operation LPAREN call_args RPAREN .)


state 497

    (171) call_args -> args COMMA assocs COMMA TIMES . arg
    (174) call_args -> args COMMA assocs COMMA TIMES . arg COMMA BINARY_AND_OP arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 521
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 498

    (172) call_args -> args COMMA assocs COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 522
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 499

    (173) call_args -> args COMMA TIMES arg COMMA . BINARY_AND_OP arg

    BINARY_AND_OP   shift and go to state 523


state 500

    (178) call_args -> assocs COMMA TIMES arg COMMA . BINARY_AND_OP arg

    BINARY_AND_OP   shift and go to state 524


state 501

    (180) call_args -> TIMES arg COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    END             reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 180 (call_args -> TIMES arg COMMA BINARY_AND_OP arg .) ]


state 502

    (33) function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET . RPAREN RBRACKET

    RPAREN          shift and go to state 525


state 503

    (81) primary -> LBRACKET args COMMA . RBRACKET
    (168) call_args -> args COMMA . assocs
    (169) call_args -> args COMMA . TIMES arg
    (170) call_args -> args COMMA . BINARY_AND_OP arg
    (171) call_args -> args COMMA . assocs COMMA TIMES arg
    (172) call_args -> args COMMA . assocs COMMA BINARY_AND_OP arg
    (173) call_args -> args COMMA . TIMES arg COMMA BINARY_AND_OP arg
    (174) call_args -> args COMMA . assocs COMMA TIMES arg COMMA BINARY_AND_OP arg
    (164) assocs -> . assoc
    (165) assocs -> . assoc COMMA assoc
    (166) assoc -> . arg HASH_ROCKET arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    RBRACKET        shift and go to state 357
    TIMES           shift and go to state 403
    BINARY_AND_OP   shift and go to state 404
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    assocs                         shift and go to state 402
    arg                            shift and go to state 386
    assoc                          shift and go to state 127
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 504

    (106) primary -> CASE compstmt when ELSE compstmt END .

    LBRACKET        reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    DOT             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    UNARY_OP        reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RANGE_INCLUSIVE reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    OR_SYMBOL       reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    BINARY_XOR_OP   reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    BINARY_AND_OP   reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    GREATERTHAN     reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    GREATERTHANEQUAL reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    LESSERTHAN      reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    LESSERTHANEQUAL reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    EQUAL           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    CASE_EQUALITY   reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    NOTEQUAL        reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    AND             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    OR              reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    PLUS            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    MINUS           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    TIMES           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    DIVIDE          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    MOD             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    POW             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    IF              reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    WHILE           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    UNLESS          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    UNTIL           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    TERM            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    $end            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    COMMA           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RBRACKET        reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    THEN            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    DO              reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RESCUE          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    HASH_ROCKET     reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RKEY            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RPAREN          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    WHEN            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    LKEY            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    END             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    ELSIF           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    ELSE            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    ENSURE          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    NOT_SYMBOL      reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    COMPLEMENT_OP   reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    DEFINED_OP      reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    NUMBER          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    LPAREN          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    RETURN          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    YIELD           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    CASE            reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    FOR             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    BEGIN           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    CLASS           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    MODULE          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    DEF             reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    VAR_GLOBAL      reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    VAR_LOCAL       reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    VAR_INSTANCE    reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    VAR_CLASS       reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    SYMBOL          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    STRING          reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    IDENTIFIER      reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)
    SUPER           reduce using rule 106 (primary -> CASE compstmt when ELSE compstmt END .)


state 505

    (121) when -> when WHEN when_args then . compstmt
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    compstmt                       shift and go to state 526
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 506

    (120) when -> WHEN when_args then compstmt .

    END             reduce using rule 120 (when -> WHEN when_args then compstmt .)
    ELSE            reduce using rule 120 (when -> WHEN when_args then compstmt .)
    WHEN            reduce using rule 120 (when -> WHEN when_args then compstmt .)


state 507

    (127) when_args -> args COMMA TIMES . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 527
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 508

    (107) primary -> FOR block_var IN expr do compstmt . END

    END             shift and go to state 528


state 509

    (113) primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .

    LBRACKET        reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    DOT             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    UNARY_OP        reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RANGE_INCLUSIVE reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    OR_SYMBOL       reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    BINARY_XOR_OP   reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    BINARY_AND_OP   reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    GREATERTHAN     reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    GREATERTHANEQUAL reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    LESSERTHAN      reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    LESSERTHANEQUAL reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    EQUAL           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    CASE_EQUALITY   reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    NOTEQUAL        reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    AND             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    OR              reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    PLUS            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    MINUS           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    TIMES           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    DIVIDE          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    MOD             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    POW             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    IF              reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    WHILE           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    UNLESS          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    UNTIL           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    TERM            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    $end            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    COMMA           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RBRACKET        reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    THEN            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    DO              reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RESCUE          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    HASH_ROCKET     reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RKEY            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RPAREN          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    WHEN            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    LKEY            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    END             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    ELSIF           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    ELSE            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    ENSURE          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    NOT_SYMBOL      reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    COMPLEMENT_OP   reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    DEFINED_OP      reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    NUMBER          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    LPAREN          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    RETURN          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    YIELD           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    CASE            reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    FOR             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    BEGIN           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    CLASS           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    MODULE          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    DEF             reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    VAR_GLOBAL      reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    VAR_LOCAL       reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    VAR_INSTANCE    reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    VAR_CLASS       reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    SYMBOL          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    STRING          reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    IDENTIFIER      reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)
    SUPER           reduce using rule 113 (primary -> CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END .)


state 510

    (161) arglist -> IDENTIFIER COMMA & IDENTIFIER .

    TERM            reduce using rule 161 (arglist -> IDENTIFIER COMMA & IDENTIFIER .)
    RPAREN          reduce using rule 161 (arglist -> IDENTIFIER COMMA & IDENTIFIER .)


state 511

    (116) primary -> DEF singleton DOT fname argdecl compstmt . END

    END             shift and go to state 529


state 512

    (117) primary -> DEF singleton UNARY_OP fname argdecl compstmt . END

    END             shift and go to state 530


state 513

    (7) stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .

    IF              reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    WHILE           reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    UNLESS          reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    UNTIL           reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    TERM            reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    $end            reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    RESCUE          reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    RPAREN          reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    WHEN            reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    RKEY            reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    LKEY            reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    END             reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    ELSIF           reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    ELSE            reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)
    ENSURE          reduce using rule 7 (stmt -> LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END .)


state 514

    (100) primary -> IF expr then compstmt elsif ELSE compstmt . END

    END             shift and go to state 531


state 515

    (118) elsif -> ELSIF expr then . compstmt
    (119) elsif -> ELSIF expr then . compstmt elsif
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    expr                           shift and go to state 4
    compstmt                       shift and go to state 532
    stmt                           shift and go to state 3
    call                           shift and go to state 5
    lhs                            shift and go to state 16
    command                        shift and go to state 17
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 516

    (102) primary -> UNLESS expr then compstmt ELSE compstmt END .

    LBRACKET        reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    DOT             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    UNARY_OP        reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RANGE_INCLUSIVE reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    OR_SYMBOL       reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    BINARY_XOR_OP   reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    BINARY_AND_OP   reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    GREATERTHAN     reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    GREATERTHANEQUAL reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    LESSERTHAN      reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    LESSERTHANEQUAL reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    EQUAL           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    CASE_EQUALITY   reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    NOTEQUAL        reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    AND             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    OR              reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    PLUS            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    MINUS           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    TIMES           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    DIVIDE          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    MOD             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    POW             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    IF              reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    WHILE           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    UNLESS          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    UNTIL           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    TERM            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    $end            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    COMMA           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RBRACKET        reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    THEN            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    DO              reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RESCUE          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    HASH_ROCKET     reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RKEY            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RPAREN          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    WHEN            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    LKEY            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    END             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    ELSIF           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    ELSE            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    ENSURE          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    NOT_SYMBOL      reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    COMPLEMENT_OP   reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    DEFINED_OP      reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    NUMBER          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    LPAREN          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    RETURN          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    YIELD           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    CASE            reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    FOR             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    BEGIN           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    CLASS           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    MODULE          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    DEF             reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    VAR_GLOBAL      reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    VAR_LOCAL       reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    VAR_INSTANCE    reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    VAR_CLASS       reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    SYMBOL          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    STRING          reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    IDENTIFIER      reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)
    SUPER           reduce using rule 102 (primary -> UNLESS expr then compstmt ELSE compstmt END .)


state 517

    (111) primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt . END

    END             shift and go to state 533


state 518

    (124) rescue -> rescue RESCUE args do compstmt .

    END             reduce using rule 124 (rescue -> rescue RESCUE args do compstmt .)
    ELSE            reduce using rule 124 (rescue -> rescue RESCUE args do compstmt .)
    ENSURE          reduce using rule 124 (rescue -> rescue RESCUE args do compstmt .)
    RESCUE          reduce using rule 124 (rescue -> rescue RESCUE args do compstmt .)


state 519

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL . block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (145) block_var -> . lhs
    (146) block_var -> . mlhs
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    TIMES           shift and go to state 44
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    DEFINED_OP      shift and go to state 204
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    NUMBER          shift and go to state 205
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    lhs                            shift and go to state 202
    block_var                      shift and go to state 534
    mlhs                           shift and go to state 69
    variable                       shift and go to state 19
    primary                        shift and go to state 203
    mlhs_item                      shift and go to state 43
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 520

    (97) primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .

    LBRACKET        reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    DOT             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    UNARY_OP        reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RANGE_INCLUSIVE reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RANGE_EXCLUSIVE reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    OR_SYMBOL       reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    BINARY_XOR_OP   reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    BINARY_AND_OP   reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    COMBINED_COMPARISON_OP reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    GREATERTHAN     reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    GREATERTHANEQUAL reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    LESSERTHAN      reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    LESSERTHANEQUAL reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    EQUAL           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    CASE_EQUALITY   reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    NOTEQUAL        reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    MATCHED_STRINGS_OP reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    BINARY_LEFT_SHIFT_OP reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    AND             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    OR              reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    PLUS            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    MINUS           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    TIMES           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    DIVIDE          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    MOD             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    POW             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    IF              reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    WHILE           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    UNLESS          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    UNTIL           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    TERM            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    $end            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    COMMA           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RBRACKET        reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    THEN            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    DO              reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RESCUE          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    HASH_ROCKET     reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RKEY            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RPAREN          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    WHEN            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    LKEY            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    END             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    ELSIF           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    ELSE            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    ENSURE          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    NOT_SYMBOL      reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    COMPLEMENT_OP   reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    DEFINED_OP      reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    NUMBER          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    LPAREN          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    RETURN          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    YIELD           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    CASE            reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    FOR             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    BEGIN           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    CLASS           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    MODULE          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    DEF             reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    VAR_GLOBAL      reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    VAR_LOCAL       reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    VAR_INSTANCE    reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    VAR_CLASS       reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    SYMBOL          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    STRING          reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    IDENTIFIER      reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)
    SUPER           reduce using rule 97 (primary -> function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY .)


state 521

    (171) call_args -> args COMMA assocs COMMA TIMES arg .
    (174) call_args -> args COMMA assocs COMMA TIMES arg . COMMA BINARY_AND_OP arg
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    WHILE           reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    UNLESS          reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    UNTIL           reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    TERM            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    $end            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    THEN            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    DO              reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    RESCUE          reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    RPAREN          reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    WHEN            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    RKEY            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    LKEY            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    END             reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    ELSIF           reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    ELSE            reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    ENSURE          reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    LBRACKET        reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    RBRACKET        reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .)
    COMMA           shift and go to state 535
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .) ]
  ! OR              [ reduce using rule 171 (call_args -> args COMMA assocs COMMA TIMES arg .) ]


state 522

    (172) call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    END             reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 172 (call_args -> args COMMA assocs COMMA BINARY_AND_OP arg .) ]


state 523

    (173) call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 536
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 524

    (178) call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 537
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 525

    (33) function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN . RBRACKET

    RBRACKET        shift and go to state 538


state 526

    (121) when -> when WHEN when_args then compstmt .

    END             reduce using rule 121 (when -> when WHEN when_args then compstmt .)
    ELSE            reduce using rule 121 (when -> when WHEN when_args then compstmt .)
    WHEN            reduce using rule 121 (when -> when WHEN when_args then compstmt .)


state 527

    (127) when_args -> args COMMA TIMES arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

    TERM            reduce using rule 127 (when_args -> args COMMA TIMES arg .)
    THEN            reduce using rule 127 (when_args -> args COMMA TIMES arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189


state 528

    (107) primary -> FOR block_var IN expr do compstmt END .

    LBRACKET        reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    DOT             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    UNARY_OP        reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RANGE_INCLUSIVE reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    OR_SYMBOL       reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    BINARY_XOR_OP   reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    BINARY_AND_OP   reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    GREATERTHAN     reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    GREATERTHANEQUAL reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    LESSERTHAN      reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    LESSERTHANEQUAL reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    EQUAL           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    CASE_EQUALITY   reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    NOTEQUAL        reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    AND             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    OR              reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    PLUS            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    MINUS           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    TIMES           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    DIVIDE          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    MOD             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    POW             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    IF              reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    WHILE           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    UNLESS          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    UNTIL           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    TERM            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    $end            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    COMMA           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RBRACKET        reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    THEN            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    DO              reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RESCUE          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    HASH_ROCKET     reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RKEY            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RPAREN          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    WHEN            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    LKEY            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    END             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    ELSIF           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    ELSE            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    ENSURE          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    NOT_SYMBOL      reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    COMPLEMENT_OP   reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    DEFINED_OP      reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    NUMBER          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    LPAREN          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    RETURN          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    YIELD           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    CASE            reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    FOR             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    BEGIN           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    CLASS           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    MODULE          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    DEF             reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    VAR_GLOBAL      reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    VAR_LOCAL       reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    VAR_INSTANCE    reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    VAR_CLASS       reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    SYMBOL          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    STRING          reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    IDENTIFIER      reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)
    SUPER           reduce using rule 107 (primary -> FOR block_var IN expr do compstmt END .)


state 529

    (116) primary -> DEF singleton DOT fname argdecl compstmt END .

    LBRACKET        reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    DOT             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    UNARY_OP        reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RANGE_INCLUSIVE reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    OR_SYMBOL       reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    BINARY_XOR_OP   reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    BINARY_AND_OP   reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    GREATERTHAN     reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    GREATERTHANEQUAL reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    LESSERTHAN      reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    LESSERTHANEQUAL reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    EQUAL           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    CASE_EQUALITY   reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    NOTEQUAL        reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    AND             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    OR              reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    PLUS            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    MINUS           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    TIMES           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    DIVIDE          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    MOD             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    POW             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    IF              reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    WHILE           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    UNLESS          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    UNTIL           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    TERM            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    $end            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    COMMA           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RBRACKET        reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    THEN            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    DO              reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RESCUE          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    HASH_ROCKET     reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RKEY            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RPAREN          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    WHEN            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    LKEY            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    END             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    ELSIF           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    ELSE            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    ENSURE          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    NOT_SYMBOL      reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    COMPLEMENT_OP   reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    DEFINED_OP      reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    NUMBER          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    LPAREN          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    RETURN          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    YIELD           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    CASE            reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    FOR             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    BEGIN           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    CLASS           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    MODULE          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    DEF             reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    VAR_GLOBAL      reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    VAR_LOCAL       reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    VAR_INSTANCE    reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    VAR_CLASS       reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    SYMBOL          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    STRING          reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    IDENTIFIER      reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)
    SUPER           reduce using rule 116 (primary -> DEF singleton DOT fname argdecl compstmt END .)


state 530

    (117) primary -> DEF singleton UNARY_OP fname argdecl compstmt END .

    LBRACKET        reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    DOT             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    UNARY_OP        reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RANGE_INCLUSIVE reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    OR_SYMBOL       reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    BINARY_XOR_OP   reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    BINARY_AND_OP   reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    GREATERTHAN     reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    GREATERTHANEQUAL reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    LESSERTHAN      reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    LESSERTHANEQUAL reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    EQUAL           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    CASE_EQUALITY   reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    NOTEQUAL        reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    AND             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    OR              reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    PLUS            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    MINUS           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    TIMES           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    DIVIDE          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    MOD             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    POW             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    IF              reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    WHILE           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    UNLESS          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    UNTIL           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    TERM            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    $end            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    COMMA           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RBRACKET        reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    THEN            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    DO              reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RESCUE          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    HASH_ROCKET     reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RKEY            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RPAREN          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    WHEN            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    LKEY            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    END             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    ELSIF           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    ELSE            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    ENSURE          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    NOT_SYMBOL      reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    COMPLEMENT_OP   reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    DEFINED_OP      reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    NUMBER          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    LPAREN          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    RETURN          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    YIELD           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    CASE            reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    FOR             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    BEGIN           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    CLASS           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    MODULE          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    DEF             reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    VAR_GLOBAL      reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    VAR_LOCAL       reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    VAR_INSTANCE    reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    VAR_CLASS       reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    SYMBOL          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    STRING          reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    IDENTIFIER      reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)
    SUPER           reduce using rule 117 (primary -> DEF singleton UNARY_OP fname argdecl compstmt END .)


state 531

    (100) primary -> IF expr then compstmt elsif ELSE compstmt END .

    LBRACKET        reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    DOT             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    UNARY_OP        reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RANGE_INCLUSIVE reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    OR_SYMBOL       reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    BINARY_XOR_OP   reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    BINARY_AND_OP   reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    GREATERTHAN     reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    GREATERTHANEQUAL reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    LESSERTHAN      reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    LESSERTHANEQUAL reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    EQUAL           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    CASE_EQUALITY   reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    NOTEQUAL        reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    AND             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    OR              reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    PLUS            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    MINUS           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    TIMES           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    DIVIDE          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    MOD             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    POW             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    IF              reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    WHILE           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    UNLESS          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    UNTIL           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    TERM            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    $end            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    COMMA           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RBRACKET        reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    THEN            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    DO              reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RESCUE          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    HASH_ROCKET     reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RKEY            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RPAREN          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    WHEN            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    LKEY            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    END             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    ELSIF           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    ELSE            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    ENSURE          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    NOT_SYMBOL      reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    COMPLEMENT_OP   reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    DEFINED_OP      reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    NUMBER          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    LPAREN          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    RETURN          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    YIELD           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    CASE            reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    FOR             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    BEGIN           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    CLASS           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    MODULE          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    DEF             reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    VAR_GLOBAL      reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    VAR_LOCAL       reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    VAR_INSTANCE    reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    VAR_CLASS       reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    SYMBOL          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    STRING          reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    IDENTIFIER      reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)
    SUPER           reduce using rule 100 (primary -> IF expr then compstmt elsif ELSE compstmt END .)


state 532

    (118) elsif -> ELSIF expr then compstmt .
    (119) elsif -> ELSIF expr then compstmt . elsif
    (118) elsif -> . ELSIF expr then compstmt
    (119) elsif -> . ELSIF expr then compstmt elsif

    END             reduce using rule 118 (elsif -> ELSIF expr then compstmt .)
    ELSE            reduce using rule 118 (elsif -> ELSIF expr then compstmt .)
    ELSIF           shift and go to state 442

    elsif                          shift and go to state 539

state 533

    (111) primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .

    LBRACKET        reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    DOT             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    UNARY_OP        reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RANGE_INCLUSIVE reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RANGE_EXCLUSIVE reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    OR_SYMBOL       reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    BINARY_XOR_OP   reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    BINARY_AND_OP   reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    COMBINED_COMPARISON_OP reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    GREATERTHAN     reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    GREATERTHANEQUAL reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    LESSERTHAN      reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    LESSERTHANEQUAL reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    EQUAL           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    CASE_EQUALITY   reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    NOTEQUAL        reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    MATCHED_STRINGS_OP reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    BINARY_LEFT_SHIFT_OP reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    AND             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    OR              reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    PLUS            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    MINUS           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    TIMES           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    DIVIDE          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    MOD             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    POW             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    IF              reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    WHILE           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    UNLESS          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    UNTIL           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    TERM            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    $end            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    COMMA           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RBRACKET        reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    THEN            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    DO              reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RESCUE          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    HASH_ROCKET     reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RKEY            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RPAREN          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    WHEN            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    LKEY            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    END             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    ELSIF           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    ELSE            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    ENSURE          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    NOT_SYMBOL      reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    COMPLEMENT_OP   reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    DEFINED_OP      reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    NUMBER          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    LPAREN          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    RETURN          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    YIELD           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    CASE            reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    FOR             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    BEGIN           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    CLASS           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    MODULE          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    DEF             reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    VAR_GLOBAL      reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    VAR_LOCAL       reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    VAR_INSTANCE    reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    VAR_CLASS       reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    SYMBOL          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    STRING          reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    IDENTIFIER      reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)
    SUPER           reduce using rule 111 (primary -> BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END .)


state 534

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var . OR_SYMBOL RBRACKET compstmt END RBRACKET

    OR_SYMBOL       shift and go to state 540


state 535

    (174) call_args -> args COMMA assocs COMMA TIMES arg COMMA . BINARY_AND_OP arg

    BINARY_AND_OP   shift and go to state 541


state 536

    (173) call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    END             reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 173 (call_args -> args COMMA TIMES arg COMMA BINARY_AND_OP arg .) ]


state 537

    (178) call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    END             reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 178 (call_args -> assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .) ]


state 538

    (33) function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .

    LKEY            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    DO              reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    TERM            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    LBRACKET        reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    DOT             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    UNARY_OP        reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RANGE_INCLUSIVE reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RANGE_EXCLUSIVE reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    OR_SYMBOL       reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    BINARY_XOR_OP   reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    BINARY_AND_OP   reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    COMBINED_COMPARISON_OP reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    GREATERTHAN     reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    GREATERTHANEQUAL reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    LESSERTHAN      reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    LESSERTHANEQUAL reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    EQUAL           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    CASE_EQUALITY   reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    NOTEQUAL        reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    MATCHED_STRINGS_OP reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    OPPOSITE_MATCHED_STRINGS_OP reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    BINARY_LEFT_SHIFT_OP reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    BINARY_RIGHT_SHIFT_OP reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    AND             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    OR              reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    PLUS            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    MINUS           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    TIMES           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    DIVIDE          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    MOD             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    POW             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    IF              reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    WHILE           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    UNLESS          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    UNTIL           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    $end            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    COMMA           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RBRACKET        reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    THEN            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RESCUE          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    HASH_ROCKET     reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RKEY            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RPAREN          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    WHEN            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    END             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    ELSIF           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    ELSE            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    ENSURE          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    NOT_SYMBOL      reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    COMPLEMENT_OP   reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    DEFINED_OP      reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    NUMBER          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    LPAREN          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    RETURN          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    YIELD           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    CASE            reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    FOR             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    BEGIN           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    CLASS           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    MODULE          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    DEF             reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    VAR_GLOBAL      reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    VAR_LOCAL       reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    VAR_INSTANCE    reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    VAR_CLASS       reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    SYMBOL          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    STRING          reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    IDENTIFIER      reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)
    SUPER           reduce using rule 33 (function -> operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET .)


state 539

    (119) elsif -> ELSIF expr then compstmt elsif .

    END             reduce using rule 119 (elsif -> ELSIF expr then compstmt elsif .)
    ELSE            reduce using rule 119 (elsif -> ELSIF expr then compstmt elsif .)


state 540

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL . RBRACKET compstmt END RBRACKET

    RBRACKET        shift and go to state 542


state 541

    (174) call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP . arg
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL

    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    NOT_SYMBOL      shift and go to state 73
    COMPLEMENT_OP   shift and go to state 48
    DEFINED_OP      shift and go to state 74
    NUMBER          shift and go to state 79
    LPAREN          shift and go to state 130
    UNARY_OP        shift and go to state 30
    LBRACKET        shift and go to state 63
    LKEY            shift and go to state 15
    RETURN          shift and go to state 75
    YIELD           shift and go to state 76
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    BEGIN           shift and go to state 78
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51
    IDENTIFIER      shift and go to state 72
    SUPER           shift and go to state 81

    arg                            shift and go to state 543
    lhs                            shift and go to state 128
    math_operations                shift and go to state 45
    primary                        shift and go to state 129
    variable                       shift and go to state 19
    literal                        shift and go to state 36
    function                       shift and go to state 77
    operation                      shift and go to state 80

state 542

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET . compstmt END RBRACKET
    (2) compstmt -> . stmt
    (3) compstmt -> . stmt term
    (4) compstmt -> . stmt term expr term
    (5) stmt -> . call do LBRACKET RBRACKET
    (6) stmt -> . LBRACKET block_var RBRACKET
    (7) stmt -> . LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END
    (8) stmt -> . UNDEF fname
    (9) stmt -> . ALIAS fname fname
    (10) stmt -> . stmt IF expr
    (11) stmt -> . stmt WHILE expr
    (12) stmt -> . stmt UNLESS expr
    (13) stmt -> . stmt UNTIL expr
    (14) stmt -> . BEGIN LKEY compstmt RKEY
    (15) stmt -> . END LKEY compstmt RKEY
    (16) stmt -> . lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET
    (17) stmt -> . expr
    (27) call -> . function
    (28) call -> . command
    (141) lhs -> . variable
    (142) lhs -> . primary LBRACKET RBRACKET
    (143) lhs -> . primary LBRACKET args RBRACKET
    (144) lhs -> . primary DOT IDENTIFIER
    (18) expr -> . mlhs = mrhs
    (19) expr -> . RETURN call_args
    (20) expr -> . YIELD call_args
    (21) expr -> . expr AND expr
    (22) expr -> . expr OR expr
    (23) expr -> . NOT expr
    (24) expr -> . command
    (25) expr -> . NOT_SYMBOL command
    (26) expr -> . arg
    (33) function -> . operation LBRACKET LPAREN LBRACKET call_args RBRACKET RPAREN RBRACKET
    (34) function -> . primary DOT operation LPAREN call_args RPAREN
    (35) function -> . primary UNARY_OP operation LPAREN call_args RPAREN
    (36) function -> . primary DOT operation
    (37) function -> . primary UNARY_OP operation
    (38) function -> . SUPER LPAREN call_args RPAREN
    (39) function -> . SUPER
    (29) command -> . operation call_args
    (30) command -> . primary DOT operation call_args
    (31) command -> . primary UNARY_OP operation call_args
    (32) command -> . SUPER call_args
    (68) variable -> . VAR_GLOBAL
    (69) variable -> . VAR_LOCAL
    (70) variable -> . VAR_INSTANCE
    (71) variable -> . VAR_CLASS
    (72) primary -> . LPAREN compstmt RPAREN
    (73) primary -> . literal
    (74) primary -> . variable
    (75) primary -> . primary UNARY_OP IDENTIFIER
    (76) primary -> . UNARY_OP IDENTIFIER
    (77) primary -> . primary LBRACKET RBRACKET
    (78) primary -> . primary LBRACKET args RBRACKET
    (79) primary -> . LBRACKET RBRACKET
    (80) primary -> . LBRACKET args RBRACKET
    (81) primary -> . LBRACKET args COMMA RBRACKET
    (82) primary -> . LKEY RKEY
    (83) primary -> . LKEY args RKEY
    (84) primary -> . LKEY assocs RKEY
    (85) primary -> . LKEY args COMMA RKEY
    (86) primary -> . LKEY assocs COMMA RKEY
    (87) primary -> . RETURN
    (88) primary -> . RETURN LPAREN RPAREN
    (89) primary -> . RETURN LPAREN call_args RPAREN
    (90) primary -> . YIELD
    (91) primary -> . YIELD LPAREN RPAREN
    (92) primary -> . YIELD LPAREN call_args RPAREN
    (93) primary -> . DEFINED_OP LPAREN arg LPAREN
    (94) primary -> . function
    (95) primary -> . function LKEY compstmt LKEY
    (96) primary -> . function LKEY OR_SYMBOL OR_SYMBOL compstmt LKEY
    (97) primary -> . function LKEY OR_SYMBOL block_var OR_SYMBOL compstmt LKEY
    (98) primary -> . IF expr then compstmt END
    (99) primary -> . IF expr then compstmt elsif END
    (100) primary -> . IF expr then compstmt elsif ELSE compstmt END
    (101) primary -> . UNLESS expr then compstmt END
    (102) primary -> . UNLESS expr then compstmt ELSE compstmt END
    (103) primary -> . WHILE expr do compstmt END
    (104) primary -> . UNTIL expr do compstmt END
    (105) primary -> . CASE compstmt when END
    (106) primary -> . CASE compstmt when ELSE compstmt END
    (107) primary -> . FOR block_var IN expr do compstmt END
    (108) primary -> . BEGIN compstmt rescue END
    (109) primary -> . BEGIN compstmt rescue ELSE compstmt END
    (110) primary -> . BEGIN compstmt rescue ENSURE compstmt END
    (111) primary -> . BEGIN compstmt rescue ELSE compstmt ENSURE compstmt END
    (112) primary -> . CLASS IDENTIFIER compstmt END
    (113) primary -> . CLASS IDENTIFIER LESSERTHAN IDENTIFIER compstmt END
    (114) primary -> . MODULE IDENTIFIER compstmt END
    (115) primary -> . DEF fname argdecl compstmt END
    (116) primary -> . DEF singleton DOT fname argdecl compstmt END
    (117) primary -> . DEF singleton UNARY_OP fname argdecl compstmt END
    (147) mlhs -> . mlhs_item COMMA mlhs_item TIMES
    (148) mlhs -> . mlhs_item COMMA mlhs_item lhs
    (149) mlhs -> . mlhs_item COMMA mult_mlhs_item TIMES
    (150) mlhs -> . mlhs_item COMMA mult_mlhs_item lhs
    (151) mlhs -> . TIMES lhs
    (40) arg -> . lhs = arg
    (41) arg -> . lhs op_asgn arg
    (42) arg -> . arg RANGE_INCLUSIVE arg
    (43) arg -> . arg RANGE_EXCLUSIVE arg
    (44) arg -> . math_operations
    (45) arg -> . PLUS arg
    (46) arg -> . MINUS arg
    (47) arg -> . arg OR_SYMBOL arg
    (48) arg -> . arg BINARY_XOR_OP arg
    (49) arg -> . arg BINARY_AND_OP arg
    (50) arg -> . arg COMBINED_COMPARISON_OP arg
    (51) arg -> . arg GREATERTHAN arg
    (52) arg -> . arg GREATERTHANEQUAL arg
    (53) arg -> . arg LESSERTHAN arg
    (54) arg -> . arg LESSERTHANEQUAL arg
    (55) arg -> . arg EQUAL arg
    (56) arg -> . arg CASE_EQUALITY arg
    (57) arg -> . arg NOTEQUAL arg
    (58) arg -> . arg MATCHED_STRINGS_OP arg
    (59) arg -> . arg OPPOSITE_MATCHED_STRINGS_OP arg
    (60) arg -> . NOT_SYMBOL arg
    (61) arg -> . COMPLEMENT_OP arg
    (62) arg -> . arg BINARY_LEFT_SHIFT_OP arg
    (63) arg -> . arg BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> . arg AND arg
    (65) arg -> . arg OR arg
    (66) arg -> . DEFINED_OP arg
    (67) arg -> . primary
    (213) operation -> . IDENTIFIER
    (214) operation -> . IDENTIFIER NOT_SYMBOL
    (215) operation -> . IDENTIFIER OPTIONAL_SYMBOL
    (183) literal -> . NUMBER
    (184) literal -> . SYMBOL
    (185) literal -> . STRING
    (186) literal -> . IDENTIFIER
    (153) mlhs_item -> . lhs
    (154) mlhs_item -> . LPAREN mlhs RPAREN
    (229) math_operations -> . arg PLUS arg
    (230) math_operations -> . arg MINUS arg
    (231) math_operations -> . arg TIMES arg
    (232) math_operations -> . arg DIVIDE arg
    (233) math_operations -> . arg MOD arg
    (234) math_operations -> . arg POW arg
    (235) math_operations -> . NUMBER PLUS NUMBER
    (236) math_operations -> . NUMBER MINUS NUMBER
    (237) math_operations -> . NUMBER TIMES NUMBER
    (238) math_operations -> . NUMBER DIVIDE NUMBER
    (239) math_operations -> . NUMBER MOD NUMBER
    (240) math_operations -> . NUMBER POW NUMBER

    LBRACKET        shift and go to state 6
    UNDEF           shift and go to state 8
    ALIAS           shift and go to state 9
    BEGIN           shift and go to state 14
    END             shift and go to state 7
    RETURN          shift and go to state 23
    YIELD           shift and go to state 24
    NOT             shift and go to state 25
    NOT_SYMBOL      shift and go to state 26
    SUPER           shift and go to state 31
    VAR_GLOBAL      shift and go to state 32
    VAR_LOCAL       shift and go to state 33
    VAR_INSTANCE    shift and go to state 34
    VAR_CLASS       shift and go to state 35
    LPAREN          shift and go to state 29
    UNARY_OP        shift and go to state 30
    LKEY            shift and go to state 15
    DEFINED_OP      shift and go to state 37
    IF              shift and go to state 10
    UNLESS          shift and go to state 12
    WHILE           shift and go to state 11
    UNTIL           shift and go to state 13
    CASE            shift and go to state 38
    FOR             shift and go to state 39
    CLASS           shift and go to state 40
    MODULE          shift and go to state 41
    DEF             shift and go to state 42
    TIMES           shift and go to state 44
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47
    COMPLEMENT_OP   shift and go to state 48
    IDENTIFIER      shift and go to state 21
    NUMBER          shift and go to state 49
    SYMBOL          shift and go to state 50
    STRING          shift and go to state 51

    lhs                            shift and go to state 16
    command                        shift and go to state 17
    compstmt                       shift and go to state 544
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    call                           shift and go to state 5
    function                       shift and go to state 18
    variable                       shift and go to state 19
    primary                        shift and go to state 20
    mlhs                           shift and go to state 22
    arg                            shift and go to state 27
    operation                      shift and go to state 28
    literal                        shift and go to state 36
    mlhs_item                      shift and go to state 43
    math_operations                shift and go to state 45

state 543

    (174) call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .
    (42) arg -> arg . RANGE_INCLUSIVE arg
    (43) arg -> arg . RANGE_EXCLUSIVE arg
    (47) arg -> arg . OR_SYMBOL arg
    (48) arg -> arg . BINARY_XOR_OP arg
    (49) arg -> arg . BINARY_AND_OP arg
    (50) arg -> arg . COMBINED_COMPARISON_OP arg
    (51) arg -> arg . GREATERTHAN arg
    (52) arg -> arg . GREATERTHANEQUAL arg
    (53) arg -> arg . LESSERTHAN arg
    (54) arg -> arg . LESSERTHANEQUAL arg
    (55) arg -> arg . EQUAL arg
    (56) arg -> arg . CASE_EQUALITY arg
    (57) arg -> arg . NOTEQUAL arg
    (58) arg -> arg . MATCHED_STRINGS_OP arg
    (59) arg -> arg . OPPOSITE_MATCHED_STRINGS_OP arg
    (62) arg -> arg . BINARY_LEFT_SHIFT_OP arg
    (63) arg -> arg . BINARY_RIGHT_SHIFT_OP arg
    (64) arg -> arg . AND arg
    (65) arg -> arg . OR arg
    (229) math_operations -> arg . PLUS arg
    (230) math_operations -> arg . MINUS arg
    (231) math_operations -> arg . TIMES arg
    (232) math_operations -> arg . DIVIDE arg
    (233) math_operations -> arg . MOD arg
    (234) math_operations -> arg . POW arg

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    IF              reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    WHILE           reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    UNLESS          reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    UNTIL           reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    TERM            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    $end            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    THEN            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    DO              reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RESCUE          reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RPAREN          reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    WHEN            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RKEY            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    LKEY            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    END             reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ELSIF           reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ELSE            reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    ENSURE          reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    LBRACKET        reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RBRACKET        reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .)
    RANGE_INCLUSIVE shift and go to state 165
    RANGE_EXCLUSIVE shift and go to state 166
    OR_SYMBOL       shift and go to state 167
    BINARY_XOR_OP   shift and go to state 168
    BINARY_AND_OP   shift and go to state 169
    COMBINED_COMPARISON_OP shift and go to state 170
    GREATERTHAN     shift and go to state 171
    GREATERTHANEQUAL shift and go to state 172
    LESSERTHAN      shift and go to state 173
    LESSERTHANEQUAL shift and go to state 174
    EQUAL           shift and go to state 175
    CASE_EQUALITY   shift and go to state 176
    NOTEQUAL        shift and go to state 177
    MATCHED_STRINGS_OP shift and go to state 178
    OPPOSITE_MATCHED_STRINGS_OP shift and go to state 179
    BINARY_LEFT_SHIFT_OP shift and go to state 180
    BINARY_RIGHT_SHIFT_OP shift and go to state 181
    AND             shift and go to state 182
    OR              shift and go to state 183
    PLUS            shift and go to state 184
    MINUS           shift and go to state 185
    TIMES           shift and go to state 186
    DIVIDE          shift and go to state 187
    MOD             shift and go to state 188
    POW             shift and go to state 189

  ! AND             [ reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .) ]
  ! OR              [ reduce using rule 174 (call_args -> args COMMA assocs COMMA TIMES arg COMMA BINARY_AND_OP arg .) ]


state 544

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt . END RBRACKET

    END             shift and go to state 545


state 545

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END . RBRACKET

    RBRACKET        shift and go to state 546


state 546

    (16) stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .

    IF              reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    WHILE           reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    UNLESS          reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    UNTIL           reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    TERM            reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    $end            reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    RESCUE          reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    RPAREN          reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    WHEN            reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    RKEY            reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    LKEY            reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    END             reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    ELSIF           reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    ELSE            reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)
    ENSURE          reduce using rule 16 (stmt -> lhs = command LBRACKET do LBRACKET OR_SYMBOL block_var OR_SYMBOL RBRACKET compstmt END RBRACKET .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LKEY in state 18 resolved as shift
WARNING: shift/reduce conflict for NOT_SYMBOL in state 21 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 23 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 23 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 23 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 23 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 23 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 23 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 23 resolved as shift
WARNING: shift/reduce conflict for IF in state 23 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 23 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 23 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 23 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 24 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 24 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 24 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 24 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 24 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 24 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 24 resolved as shift
WARNING: shift/reduce conflict for IF in state 24 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 24 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 24 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 24 resolved as shift
WARNING: shift/reduce conflict for AND in state 27 resolved as shift
WARNING: shift/reduce conflict for OR in state 27 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 31 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 31 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 31 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 31 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 31 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 31 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 31 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 31 resolved as shift
WARNING: shift/reduce conflict for IF in state 31 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 31 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 31 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 31 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 49 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 49 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 49 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 49 resolved as shift
WARNING: shift/reduce conflict for MOD in state 49 resolved as shift
WARNING: shift/reduce conflict for POW in state 49 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 52 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 70 resolved as shift
WARNING: shift/reduce conflict for AND in state 70 resolved as shift
WARNING: shift/reduce conflict for OR in state 70 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 70 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 70 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 70 resolved as shift
WARNING: shift/reduce conflict for NOT_SYMBOL in state 72 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 75 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 76 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 77 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 79 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 79 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 79 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 79 resolved as shift
WARNING: shift/reduce conflict for MOD in state 79 resolved as shift
WARNING: shift/reduce conflict for POW in state 79 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 81 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 114 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 115 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 115 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 115 resolved as shift
WARNING: shift/reduce conflict for IF in state 115 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 115 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 115 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 115 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 126 resolved as shift
WARNING: shift/reduce conflict for AND in state 126 resolved as shift
WARNING: shift/reduce conflict for OR in state 126 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 127 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 129 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 129 resolved as shift
WARNING: shift/reduce conflict for AND in state 162 resolved as shift
WARNING: shift/reduce conflict for OR in state 162 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 164 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 164 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 164 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 164 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 164 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 164 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 164 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 164 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 164 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 164 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 164 resolved as shift
WARNING: shift/reduce conflict for AND in state 164 resolved as shift
WARNING: shift/reduce conflict for OR in state 164 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 164 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 164 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 164 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 164 resolved as shift
WARNING: shift/reduce conflict for MOD in state 164 resolved as shift
WARNING: shift/reduce conflict for POW in state 164 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 199 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 199 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 199 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 199 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 199 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 199 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 199 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 199 resolved as shift
WARNING: shift/reduce conflict for AND in state 199 resolved as shift
WARNING: shift/reduce conflict for OR in state 199 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 199 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 199 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 199 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 199 resolved as shift
WARNING: shift/reduce conflict for MOD in state 199 resolved as shift
WARNING: shift/reduce conflict for POW in state 199 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 214 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 214 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 214 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 214 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 214 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 214 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 214 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 214 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 214 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 214 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 214 resolved as shift
WARNING: shift/reduce conflict for AND in state 214 resolved as shift
WARNING: shift/reduce conflict for OR in state 214 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 214 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 214 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 214 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 214 resolved as shift
WARNING: shift/reduce conflict for MOD in state 214 resolved as shift
WARNING: shift/reduce conflict for POW in state 214 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 215 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 215 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 215 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 215 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 215 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 215 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 215 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 215 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 215 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 215 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 215 resolved as shift
WARNING: shift/reduce conflict for AND in state 215 resolved as shift
WARNING: shift/reduce conflict for OR in state 215 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 215 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 215 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 215 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 215 resolved as shift
WARNING: shift/reduce conflict for MOD in state 215 resolved as shift
WARNING: shift/reduce conflict for POW in state 215 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 216 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 216 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 216 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 216 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 216 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 216 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 216 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 216 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 216 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 216 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 216 resolved as shift
WARNING: shift/reduce conflict for AND in state 216 resolved as shift
WARNING: shift/reduce conflict for OR in state 216 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 216 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 216 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 216 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 216 resolved as shift
WARNING: shift/reduce conflict for MOD in state 216 resolved as shift
WARNING: shift/reduce conflict for POW in state 216 resolved as shift
WARNING: shift/reduce conflict for AND in state 228 resolved as shift
WARNING: shift/reduce conflict for OR in state 228 resolved as shift
WARNING: shift/reduce conflict for AND in state 229 resolved as shift
WARNING: shift/reduce conflict for OR in state 229 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 259 resolved as shift
WARNING: shift/reduce conflict for AND in state 259 resolved as shift
WARNING: shift/reduce conflict for OR in state 259 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 271 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 271 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 271 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 271 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 271 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 271 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 271 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 271 resolved as shift
WARNING: shift/reduce conflict for AND in state 271 resolved as shift
WARNING: shift/reduce conflict for OR in state 271 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 271 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 271 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 271 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 271 resolved as shift
WARNING: shift/reduce conflict for MOD in state 271 resolved as shift
WARNING: shift/reduce conflict for POW in state 271 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 272 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 272 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 272 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 272 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 272 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 272 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 272 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 272 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 272 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 272 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 272 resolved as shift
WARNING: shift/reduce conflict for AND in state 272 resolved as shift
WARNING: shift/reduce conflict for OR in state 272 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 272 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 272 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 272 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 272 resolved as shift
WARNING: shift/reduce conflict for MOD in state 272 resolved as shift
WARNING: shift/reduce conflict for POW in state 272 resolved as shift
WARNING: shift/reduce conflict for NOT_SYMBOL in state 277 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 278 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 278 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 278 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 278 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 278 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 278 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 278 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 278 resolved as shift
WARNING: shift/reduce conflict for IF in state 278 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 278 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 278 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 278 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 279 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 279 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 279 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 279 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 279 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 279 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 279 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 279 resolved as shift
WARNING: shift/reduce conflict for IF in state 279 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 279 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 279 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 279 resolved as shift
WARNING: shift/reduce conflict for NOT_SYMBOL in state 280 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 282 resolved as shift
WARNING: shift/reduce conflict for IF in state 282 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 282 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 282 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 282 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 284 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 284 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 284 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 284 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 284 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 284 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 284 resolved as shift
WARNING: shift/reduce conflict for IF in state 284 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 284 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 284 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 284 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 289 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 289 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 289 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 289 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 289 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 289 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 289 resolved as shift
WARNING: shift/reduce conflict for IF in state 289 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 289 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 289 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 289 resolved as shift
WARNING: shift/reduce conflict for AND in state 293 resolved as shift
WARNING: shift/reduce conflict for OR in state 293 resolved as shift
WARNING: shift/reduce conflict for AND in state 294 resolved as shift
WARNING: shift/reduce conflict for OR in state 294 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 297 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 297 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 297 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 297 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 297 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 297 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 297 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 297 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 297 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 297 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 297 resolved as shift
WARNING: shift/reduce conflict for AND in state 297 resolved as shift
WARNING: shift/reduce conflict for OR in state 297 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 297 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 297 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 297 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 297 resolved as shift
WARNING: shift/reduce conflict for MOD in state 297 resolved as shift
WARNING: shift/reduce conflict for POW in state 297 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 298 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 298 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 298 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 298 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 298 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 298 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 298 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 298 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 298 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 298 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 298 resolved as shift
WARNING: shift/reduce conflict for AND in state 298 resolved as shift
WARNING: shift/reduce conflict for OR in state 298 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 298 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 298 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 298 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 298 resolved as shift
WARNING: shift/reduce conflict for MOD in state 298 resolved as shift
WARNING: shift/reduce conflict for POW in state 298 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 299 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 299 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 299 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 299 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 299 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 299 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 299 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 299 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 299 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 299 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 299 resolved as shift
WARNING: shift/reduce conflict for AND in state 299 resolved as shift
WARNING: shift/reduce conflict for OR in state 299 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 299 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 299 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 299 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 299 resolved as shift
WARNING: shift/reduce conflict for MOD in state 299 resolved as shift
WARNING: shift/reduce conflict for POW in state 299 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 300 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 300 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 300 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 300 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 300 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 300 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 300 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 300 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 300 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 300 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 300 resolved as shift
WARNING: shift/reduce conflict for AND in state 300 resolved as shift
WARNING: shift/reduce conflict for OR in state 300 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 300 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 300 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 300 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 300 resolved as shift
WARNING: shift/reduce conflict for MOD in state 300 resolved as shift
WARNING: shift/reduce conflict for POW in state 300 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 301 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 301 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 301 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 301 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 301 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 301 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 301 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 301 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 301 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 301 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 301 resolved as shift
WARNING: shift/reduce conflict for AND in state 301 resolved as shift
WARNING: shift/reduce conflict for OR in state 301 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 301 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 301 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 301 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 301 resolved as shift
WARNING: shift/reduce conflict for MOD in state 301 resolved as shift
WARNING: shift/reduce conflict for POW in state 301 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 302 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 302 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 302 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 302 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 302 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 302 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 302 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 302 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 302 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 302 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 302 resolved as shift
WARNING: shift/reduce conflict for AND in state 302 resolved as shift
WARNING: shift/reduce conflict for OR in state 302 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 302 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 302 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 302 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 302 resolved as shift
WARNING: shift/reduce conflict for MOD in state 302 resolved as shift
WARNING: shift/reduce conflict for POW in state 302 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 303 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 303 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 303 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 303 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 303 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 303 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 303 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 303 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 303 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 303 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 303 resolved as shift
WARNING: shift/reduce conflict for AND in state 303 resolved as shift
WARNING: shift/reduce conflict for OR in state 303 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 303 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 303 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 303 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 303 resolved as shift
WARNING: shift/reduce conflict for MOD in state 303 resolved as shift
WARNING: shift/reduce conflict for POW in state 303 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 304 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 304 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 304 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 304 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 304 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 304 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 304 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 304 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 304 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 304 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 304 resolved as shift
WARNING: shift/reduce conflict for AND in state 304 resolved as shift
WARNING: shift/reduce conflict for OR in state 304 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 304 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 304 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 304 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 304 resolved as shift
WARNING: shift/reduce conflict for MOD in state 304 resolved as shift
WARNING: shift/reduce conflict for POW in state 304 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 305 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 305 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 305 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 305 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 305 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 305 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 305 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 305 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 305 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 305 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 305 resolved as shift
WARNING: shift/reduce conflict for AND in state 305 resolved as shift
WARNING: shift/reduce conflict for OR in state 305 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 305 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 305 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 305 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 305 resolved as shift
WARNING: shift/reduce conflict for MOD in state 305 resolved as shift
WARNING: shift/reduce conflict for POW in state 305 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 306 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 306 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 306 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 306 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 306 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 306 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 306 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 306 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 306 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 306 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 306 resolved as shift
WARNING: shift/reduce conflict for AND in state 306 resolved as shift
WARNING: shift/reduce conflict for OR in state 306 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 306 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 306 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 306 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 306 resolved as shift
WARNING: shift/reduce conflict for MOD in state 306 resolved as shift
WARNING: shift/reduce conflict for POW in state 306 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 307 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 307 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 307 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 307 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 307 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 307 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 307 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 307 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 307 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 307 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 307 resolved as shift
WARNING: shift/reduce conflict for AND in state 307 resolved as shift
WARNING: shift/reduce conflict for OR in state 307 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 307 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 307 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 307 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 307 resolved as shift
WARNING: shift/reduce conflict for MOD in state 307 resolved as shift
WARNING: shift/reduce conflict for POW in state 307 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 308 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 308 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 308 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 308 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 308 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 308 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 308 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 308 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 308 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 308 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 308 resolved as shift
WARNING: shift/reduce conflict for AND in state 308 resolved as shift
WARNING: shift/reduce conflict for OR in state 308 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 308 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 308 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 308 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 308 resolved as shift
WARNING: shift/reduce conflict for MOD in state 308 resolved as shift
WARNING: shift/reduce conflict for POW in state 308 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 309 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 309 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 309 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 309 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 309 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 309 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 309 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 309 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 309 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 309 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 309 resolved as shift
WARNING: shift/reduce conflict for AND in state 309 resolved as shift
WARNING: shift/reduce conflict for OR in state 309 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 309 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 309 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 309 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 309 resolved as shift
WARNING: shift/reduce conflict for MOD in state 309 resolved as shift
WARNING: shift/reduce conflict for POW in state 309 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 310 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 310 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 310 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 310 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 310 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 310 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 310 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 310 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 310 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 310 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 310 resolved as shift
WARNING: shift/reduce conflict for AND in state 310 resolved as shift
WARNING: shift/reduce conflict for OR in state 310 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 310 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 310 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 310 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 310 resolved as shift
WARNING: shift/reduce conflict for MOD in state 310 resolved as shift
WARNING: shift/reduce conflict for POW in state 310 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 311 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 311 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 311 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 311 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 311 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 311 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 311 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 311 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 311 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 311 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 311 resolved as shift
WARNING: shift/reduce conflict for AND in state 311 resolved as shift
WARNING: shift/reduce conflict for OR in state 311 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 311 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 311 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 311 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 311 resolved as shift
WARNING: shift/reduce conflict for MOD in state 311 resolved as shift
WARNING: shift/reduce conflict for POW in state 311 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 312 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 312 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 312 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 312 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 312 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 312 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 312 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 312 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 312 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 312 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 312 resolved as shift
WARNING: shift/reduce conflict for AND in state 312 resolved as shift
WARNING: shift/reduce conflict for OR in state 312 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 312 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 312 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 312 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 312 resolved as shift
WARNING: shift/reduce conflict for MOD in state 312 resolved as shift
WARNING: shift/reduce conflict for POW in state 312 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 313 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 313 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 313 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 313 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 313 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 313 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 313 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 313 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 313 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 313 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 313 resolved as shift
WARNING: shift/reduce conflict for AND in state 313 resolved as shift
WARNING: shift/reduce conflict for OR in state 313 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 313 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 313 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 313 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 313 resolved as shift
WARNING: shift/reduce conflict for MOD in state 313 resolved as shift
WARNING: shift/reduce conflict for POW in state 313 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 314 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 314 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 314 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 314 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 314 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 314 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 314 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 314 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 314 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 314 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 314 resolved as shift
WARNING: shift/reduce conflict for AND in state 314 resolved as shift
WARNING: shift/reduce conflict for OR in state 314 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 314 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 314 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 314 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 314 resolved as shift
WARNING: shift/reduce conflict for MOD in state 314 resolved as shift
WARNING: shift/reduce conflict for POW in state 314 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 315 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 315 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 315 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 315 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 315 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 315 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 315 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 315 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 315 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 315 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 315 resolved as shift
WARNING: shift/reduce conflict for AND in state 315 resolved as shift
WARNING: shift/reduce conflict for OR in state 315 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 315 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 315 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 315 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 315 resolved as shift
WARNING: shift/reduce conflict for MOD in state 315 resolved as shift
WARNING: shift/reduce conflict for POW in state 315 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 316 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 316 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 316 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 316 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 316 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 316 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 316 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 316 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 316 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 316 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 316 resolved as shift
WARNING: shift/reduce conflict for AND in state 316 resolved as shift
WARNING: shift/reduce conflict for OR in state 316 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 316 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 316 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 316 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 316 resolved as shift
WARNING: shift/reduce conflict for MOD in state 316 resolved as shift
WARNING: shift/reduce conflict for POW in state 316 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 317 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 317 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 317 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 317 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 317 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 317 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 317 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 317 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 317 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 317 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 317 resolved as shift
WARNING: shift/reduce conflict for AND in state 317 resolved as shift
WARNING: shift/reduce conflict for OR in state 317 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 317 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 317 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 317 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 317 resolved as shift
WARNING: shift/reduce conflict for MOD in state 317 resolved as shift
WARNING: shift/reduce conflict for POW in state 317 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 318 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 318 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 318 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 318 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 318 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 318 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 318 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 318 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 318 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 318 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 318 resolved as shift
WARNING: shift/reduce conflict for AND in state 318 resolved as shift
WARNING: shift/reduce conflict for OR in state 318 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 318 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 318 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 318 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 318 resolved as shift
WARNING: shift/reduce conflict for MOD in state 318 resolved as shift
WARNING: shift/reduce conflict for POW in state 318 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 319 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 319 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 319 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 319 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 319 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 319 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 319 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 319 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 319 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 319 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 319 resolved as shift
WARNING: shift/reduce conflict for AND in state 319 resolved as shift
WARNING: shift/reduce conflict for OR in state 319 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 319 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 319 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 319 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 319 resolved as shift
WARNING: shift/reduce conflict for MOD in state 319 resolved as shift
WARNING: shift/reduce conflict for POW in state 319 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 320 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 320 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 320 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 320 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 320 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 320 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 320 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 320 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 320 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 320 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 320 resolved as shift
WARNING: shift/reduce conflict for AND in state 320 resolved as shift
WARNING: shift/reduce conflict for OR in state 320 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 320 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 320 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 320 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 320 resolved as shift
WARNING: shift/reduce conflict for MOD in state 320 resolved as shift
WARNING: shift/reduce conflict for POW in state 320 resolved as shift
WARNING: shift/reduce conflict for RANGE_INCLUSIVE in state 321 resolved as shift
WARNING: shift/reduce conflict for RANGE_EXCLUSIVE in state 321 resolved as shift
WARNING: shift/reduce conflict for OR_SYMBOL in state 321 resolved as shift
WARNING: shift/reduce conflict for BINARY_XOR_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for COMBINED_COMPARISON_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for GREATERTHAN in state 321 resolved as shift
WARNING: shift/reduce conflict for GREATERTHANEQUAL in state 321 resolved as shift
WARNING: shift/reduce conflict for LESSERTHAN in state 321 resolved as shift
WARNING: shift/reduce conflict for LESSERTHANEQUAL in state 321 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 321 resolved as shift
WARNING: shift/reduce conflict for CASE_EQUALITY in state 321 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 321 resolved as shift
WARNING: shift/reduce conflict for MATCHED_STRINGS_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for OPPOSITE_MATCHED_STRINGS_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for BINARY_LEFT_SHIFT_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for BINARY_RIGHT_SHIFT_OP in state 321 resolved as shift
WARNING: shift/reduce conflict for AND in state 321 resolved as shift
WARNING: shift/reduce conflict for OR in state 321 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 321 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 321 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 321 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 321 resolved as shift
WARNING: shift/reduce conflict for MOD in state 321 resolved as shift
WARNING: shift/reduce conflict for POW in state 321 resolved as shift
WARNING: shift/reduce conflict for AND in state 326 resolved as shift
WARNING: shift/reduce conflict for OR in state 326 resolved as shift
WARNING: shift/reduce conflict for AND in state 358 resolved as shift
WARNING: shift/reduce conflict for OR in state 358 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 358 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 358 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 358 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 359 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 360 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 366 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 366 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 366 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 366 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 366 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 366 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 366 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 366 resolved as shift
WARNING: shift/reduce conflict for IF in state 366 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 366 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 366 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 366 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 367 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 367 resolved as shift
WARNING: shift/reduce conflict for BINARY_AND_OP in state 367 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 367 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 367 resolved as shift
WARNING: shift/reduce conflict for UNARY_OP in state 367 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 367 resolved as shift
WARNING: shift/reduce conflict for LKEY in state 367 resolved as shift
WARNING: shift/reduce conflict for IF in state 367 resolved as shift
WARNING: shift/reduce conflict for UNLESS in state 367 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 367 resolved as shift
WARNING: shift/reduce conflict for UNTIL in state 367 resolved as shift
WARNING: shift/reduce conflict for AND in state 384 resolved as shift
WARNING: shift/reduce conflict for OR in state 384 resolved as shift
WARNING: shift/reduce conflict for AND in state 398 resolved as shift
WARNING: shift/reduce conflict for OR in state 398 resolved as shift
WARNING: shift/reduce conflict for AND in state 399 resolved as shift
WARNING: shift/reduce conflict for OR in state 399 resolved as shift
WARNING: shift/reduce conflict for = in state 401 resolved as shift
WARNING: shift/reduce conflict for AND in state 460 resolved as shift
WARNING: shift/reduce conflict for OR in state 460 resolved as shift
WARNING: shift/reduce conflict for AND in state 461 resolved as shift
WARNING: shift/reduce conflict for OR in state 461 resolved as shift
WARNING: shift/reduce conflict for AND in state 462 resolved as shift
WARNING: shift/reduce conflict for OR in state 462 resolved as shift
WARNING: shift/reduce conflict for AND in state 463 resolved as shift
WARNING: shift/reduce conflict for OR in state 463 resolved as shift
WARNING: shift/reduce conflict for RBRACKET in state 466 resolved as shift
WARNING: shift/reduce conflict for AND in state 501 resolved as shift
WARNING: shift/reduce conflict for OR in state 501 resolved as shift
WARNING: shift/reduce conflict for AND in state 521 resolved as shift
WARNING: shift/reduce conflict for OR in state 521 resolved as shift
WARNING: shift/reduce conflict for AND in state 522 resolved as shift
WARNING: shift/reduce conflict for OR in state 522 resolved as shift
WARNING: shift/reduce conflict for AND in state 536 resolved as shift
WARNING: shift/reduce conflict for OR in state 536 resolved as shift
WARNING: shift/reduce conflict for AND in state 537 resolved as shift
WARNING: shift/reduce conflict for OR in state 537 resolved as shift
WARNING: shift/reduce conflict for AND in state 543 resolved as shift
WARNING: shift/reduce conflict for OR in state 543 resolved as shift
WARNING: reduce/reduce conflict in state 17 resolved using rule (expr -> command)
WARNING: rejected rule (call -> command) in state 17
WARNING: reduce/reduce conflict in state 18 resolved using rule (call -> function)
WARNING: rejected rule (primary -> function) in state 18
WARNING: reduce/reduce conflict in state 19 resolved using rule (primary -> variable)
WARNING: rejected rule (lhs -> variable) in state 19
WARNING: reduce/reduce conflict in state 21 resolved using rule (literal -> IDENTIFIER)
WARNING: rejected rule (operation -> IDENTIFIER) in state 21
WARNING: reduce/reduce conflict in state 72 resolved using rule (literal -> IDENTIFIER)
WARNING: rejected rule (operation -> IDENTIFIER) in state 72
WARNING: reduce/reduce conflict in state 117 resolved using rule (primary -> variable)
WARNING: rejected rule (lhs -> variable) in state 117
WARNING: reduce/reduce conflict in state 259 resolved using rule (expr -> arg)
WARNING: rejected rule (args -> arg) in state 259
WARNING: reduce/reduce conflict in state 275 resolved using rule (primary -> primary LBRACKET RBRACKET)
WARNING: rejected rule (lhs -> primary LBRACKET RBRACKET) in state 275
WARNING: reduce/reduce conflict in state 277 resolved using rule (lhs -> primary DOT IDENTIFIER)
WARNING: rejected rule (operation -> IDENTIFIER) in state 277
WARNING: reduce/reduce conflict in state 280 resolved using rule (primary -> primary UNARY_OP IDENTIFIER)
WARNING: rejected rule (operation -> IDENTIFIER) in state 280
WARNING: reduce/reduce conflict in state 288 resolved using rule (expr -> command)
WARNING: rejected rule (call -> command) in state 288
WARNING: reduce/reduce conflict in state 288 resolved using rule (expr -> command)
WARNING: rejected rule (call_args -> command) in state 288
WARNING: reduce/reduce conflict in state 290 resolved using rule (call -> function)
WARNING: rejected rule (primary -> function) in state 290
WARNING: reduce/reduce conflict in state 368 resolved using rule (primary -> primary LBRACKET RBRACKET)
WARNING: rejected rule (lhs -> primary LBRACKET RBRACKET) in state 368
WARNING: reduce/reduce conflict in state 391 resolved using rule (primary -> primary LBRACKET args RBRACKET)
WARNING: rejected rule (lhs -> primary LBRACKET args RBRACKET) in state 391
WARNING: reduce/reduce conflict in state 443 resolved using rule (primary -> primary LBRACKET args RBRACKET)
WARNING: rejected rule (lhs -> primary LBRACKET args RBRACKET) in state 443
