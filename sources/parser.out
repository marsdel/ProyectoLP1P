Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ALIAS
    AND
    AND_EQUAL
    BEGIN
    BINARY_AND_OP
    BINARY_LEFT_EQUAL
    BINARY_LEFT_SHIFT_OP
    BINARY_RIGHT_EQUAL
    BINARY_RIGHT_SHIFT_OP
    BINARY_XOR_OP
    BREAK
    CASE
    CASE_EQUALITY
    CLASS
    COMBINED_COMPARISON_OP
    COMPLEMENT_OP
    DEF
    DEFINED
    DEFINED_OP
    DO
    ELSE
    ELSIF
    ENSURE
    EXPONENT_AND
    FALSE
    FOR
    IN
    MATCHED_STRINGS_OP
    MODULE
    NEXT
    NIL
    NOT
    NOT_SYMBOL
    OPPOSITE_MATCHED_STRINGS_OP
    OPTIONAL_SYMBOL
    OR
    OR_EQUAL
    OR_SYMBOL
    OVERLOAD_MINUS
    OVERLOAD_PLUS
    POW
    PUTS
    RANGE_EXCLUSIVE
    RANGE_INCLUSIVE
    REDO
    RESCUE
    RETRY
    RETURN
    SELF
    SINGLE_AND_EQUAL
    SINGLE_OR_EQUAL
    SYMBOL
    TERM
    TRUE
    UNARY_OP
    UNDEF
    UNLESS
    UNTIL
    WHEN
    WHILE
    XOR_EQUAL
    YIELD
    _FILE_
    _LINE_

Grammar

Rule 0     S' -> program
Rule 1     program -> expression
Rule 2     expression -> string_literals
Rule 3     expression -> variables
Rule 4     expression -> array
Rule 5     expression -> hash
Rule 6     expression -> method_invocation
Rule 7     expression -> super
Rule 8     expression -> assignment
Rule 9     expression -> expression_operations
Rule 10    expression -> control_structure
Rule 11    expression -> Class definitions
Rule 12    expression -> Singleton-class definitions
Rule 13    expression -> Module definitions
Rule 14    expression -> Method definitions
Rule 15    expression -> Singleton-method definitions
Rule 16    expression -> alias
Rule 17    expression -> undef
Rule 18    variables -> VAR_GLOBAL
Rule 19    variables -> VAR_INSTANCE
Rule 20    variables -> VAR_CLASS
Rule 21    variables -> VAR_LOCAL
Rule 22    variables -> VAR_SYSTEM
Rule 23    variables -> VAR_CONSTANT
Rule 24    string_literals -> STRING
Rule 25    string_literals -> string_concat
Rule 26    string_concat -> DOUBLE_QUOTED IDENTIFIER concat DOUBLE_QUOTED
Rule 27    string_concat -> DOUBLE_QUOTED IDENTIFIER concat IDENTIFIER DOUBLE_QUOTED
Rule 28    concat -> NUMBER_SIGN LKEY IDENTIFIER RKEY
Rule 29    array -> LBRACKET args_array RBRACKET
Rule 30    array_data -> IDENTIFIER LBRACKET NUMBER RBRACKET
Rule 31    args_array -> data
Rule 32    args_array -> data COMMA args_array
Rule 33    hash -> LKEY args_hash RKEY
Rule 34    args_hash -> data HASH_ROCKET data
Rule 35    args_hash -> data HASH_ROCKET data COMMA args_hash
Rule 36    function -> IDENTIFIER LPAREN RPAREN
Rule 37    super -> SUPER LPAREN RPAREN
Rule 38    super -> SUPER LPAREN args_method RPAREN
Rule 39    method_invocation -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
Rule 40    method_invocation -> IDENTIFIER DOT IDENTIFIER LPAREN args_method RPAREN
Rule 41    method_invocation -> IDENTIFIER DOT IDENTIFIER
Rule 42    args_method -> data
Rule 43    args_method -> data COMMA args_method
Rule 44    assignment -> variable EQUAL_SYMBOL data
Rule 45    assignment -> array_data EQUAL_SYMBOL data
Rule 46    assignment -> method_invocation EQUAL_SYMBOL data
Rule 47    assignment -> self_assigment
Rule 48    assignment -> mult_assigment
Rule 49    self_assigment -> variable op_assigment data
Rule 50    op_assigment -> PLUS_EQUAL
Rule 51    op_assigment -> MINUS_EQUAL
Rule 52    op_assigment -> TIMES_EQUAL
Rule 53    op_assigment -> DIVIDE_EQUAL
Rule 54    op_assigment -> MOD_EQUAL
Rule 55    op_assigment -> POW_EQUAL
Rule 56    mult_assigment -> list_var EQUAL_SYMBOL args_method
Rule 57    list_var -> variable COMMA
Rule 58    list_var -> variable COMMA list_var
Rule 59    list_var -> variable
Rule 60    control_structure -> if
Rule 61    if -> IF expression expression END
Rule 62    if -> IF expression THEN expression END
Rule 63    if -> IF expression expression elsif END
Rule 64    if -> IF expression THEN expression elsif END
Rule 65    if -> IF expression expression else END
Rule 66    if -> IF expression THEN expression else END
Rule 67    if -> IF expression expression elsif else END
Rule 68    if -> IF expression THEN expression elsif else END
Rule 69    elseif -> <empty>
Rule 70    expression_operations -> opmate
Rule 71    expression_operations -> LPAREN opmate RPAREN
Rule 72    expression_operations -> expression_operations op expression_operations
Rule 73    expression_operations -> expression_operations op opmate
Rule 74    expression_operations -> LPAREN opmate RPAREN op expression_operations
Rule 75    expression_operations -> expression_operations op LPAREN opmate RPAREN
Rule 76    opmate -> data op data
Rule 77    op -> PLUS
Rule 78    op -> MINUS
Rule 79    op -> TIMES
Rule 80    op -> DIVIDE
Rule 81    op -> MOD
Rule 82    op -> EQUAL
Rule 83    op -> NOTEQUAL
Rule 84    op -> GREATERTHAN
Rule 85    op -> GREATERTHANEQUAL
Rule 86    op -> LESSERTHAN
Rule 87    op -> LESSERTHANEQUAL
Rule 88    data -> NUMBER
Rule 89    data -> STRING
Rule 90    data -> variable

Terminals, with rules where they appear

ALIAS                : 
AND                  : 
AND_EQUAL            : 
BEGIN                : 
BINARY_AND_OP        : 
BINARY_LEFT_EQUAL    : 
BINARY_LEFT_SHIFT_OP : 
BINARY_RIGHT_EQUAL   : 
BINARY_RIGHT_SHIFT_OP : 
BINARY_XOR_OP        : 
BREAK                : 
CASE                 : 
CASE_EQUALITY        : 
CLASS                : 
COMBINED_COMPARISON_OP : 
COMMA                : 32 35 43 57 58
COMPLEMENT_OP        : 
DEF                  : 
DEFINED              : 
DEFINED_OP           : 
DIVIDE               : 80
DIVIDE_EQUAL         : 53
DO                   : 
DOT                  : 39 40 41
DOUBLE_QUOTED        : 26 26 27 27
ELSE                 : 
ELSIF                : 
END                  : 61 62 63 64 65 66 67 68
ENSURE               : 
EQUAL                : 82
EQUAL_SYMBOL         : 44 45 46 56
EXPONENT_AND         : 
FALSE                : 
FOR                  : 
GREATERTHAN          : 84
GREATERTHANEQUAL     : 85
HASH_ROCKET          : 34 35
IDENTIFIER           : 26 27 27 28 30 36 39 39 40 40 41 41
IF                   : 61 62 63 64 65 66 67 68
IN                   : 
LBRACKET             : 29 30
LESSERTHAN           : 86
LESSERTHANEQUAL      : 87
LKEY                 : 28 33
LPAREN               : 36 37 38 39 40 71 74 75
MATCHED_STRINGS_OP   : 
MINUS                : 78
MINUS_EQUAL          : 51
MOD                  : 81
MODULE               : 
MOD_EQUAL            : 54
NEXT                 : 
NIL                  : 
NOT                  : 
NOTEQUAL             : 83
NOT_SYMBOL           : 
NUMBER               : 30 88
NUMBER_SIGN          : 28
OPPOSITE_MATCHED_STRINGS_OP : 
OPTIONAL_SYMBOL      : 
OR                   : 
OR_EQUAL             : 
OR_SYMBOL            : 
OVERLOAD_MINUS       : 
OVERLOAD_PLUS        : 
PLUS                 : 77
PLUS_EQUAL           : 50
POW                  : 
POW_EQUAL            : 55
PUTS                 : 
RANGE_EXCLUSIVE      : 
RANGE_INCLUSIVE      : 
RBRACKET             : 29 30
REDO                 : 
RESCUE               : 
RETRY                : 
RETURN               : 
RKEY                 : 28 33
RPAREN               : 36 37 38 39 40 71 74 75
SELF                 : 
SINGLE_AND_EQUAL     : 
SINGLE_OR_EQUAL      : 
STRING               : 24 89
SUPER                : 37 38
SYMBOL               : 
TERM                 : 
THEN                 : 62 64 66 68
TIMES                : 79
TIMES_EQUAL          : 52
TRUE                 : 
UNARY_OP             : 
UNDEF                : 
UNLESS               : 
UNTIL                : 
VAR_CLASS            : 20
VAR_CONSTANT         : 23
VAR_GLOBAL           : 18
VAR_INSTANCE         : 19
VAR_LOCAL            : 21
VAR_SYSTEM           : 22
WHEN                 : 
WHILE                : 
XOR_EQUAL            : 
YIELD                : 
_FILE_               : 
_LINE_               : 
error                : 

Nonterminals, with rules where they appear

Class                : 11
Method               : 14
Module               : 13
Singleton-class      : 12
Singleton-method     : 15
alias                : 16
args_array           : 29 32
args_hash            : 33 35
args_method          : 38 40 43 56
array                : 4
array_data           : 45
assignment           : 8
concat               : 26 27
control_structure    : 10
data                 : 31 32 34 34 35 35 42 43 44 45 46 49 76 76
definitions          : 11 12 13 14 15
else                 : 65 66 67 68
elseif               : 
elsif                : 63 64 67 68
expression           : 1 61 61 62 62 63 63 64 64 65 65 66 66 67 67 68 68
expression_operations : 9 72 72 73 74 75
function             : 
hash                 : 5
if                   : 60
list_var             : 56 58
method_invocation    : 6 46
mult_assigment       : 48
op                   : 72 73 74 75 76
op_assigment         : 49
opmate               : 70 71 73 74 75
program              : 0
self_assigment       : 47
string_concat        : 25
string_literals      : 2
super                : 7
undef                : 17
variable             : 44 49 57 58 59 90
variables            : 3

