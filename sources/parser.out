Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND_EQUAL
    BINARY_AND_OP
    BINARY_LEFT_EQUAL
    BINARY_RIGHT_EQUAL
    BINARY_RIGHT_SHIFT_OP
    BINARY_XOR_OP
    CASE
    CASE_EQUALITY
    COMBINED_COMPARISON_OP
    COMPLEMENT_OP
    DEFINED
    EXPONENT_AND
    FALSE
    MATCHED_STRINGS_OP
    NIL
    OPPOSITE_MATCHED_STRINGS_OP
    OPTIONAL_SYMBOL
    OR_EQUAL
    OVERLOAD_MINUS
    OVERLOAD_PLUS
    POW
    PUTS
    SELF
    SINGLE_AND_EQUAL
    SINGLE_OR_EQUAL
    SYMBOL
    TERM
    TRUE
    UNARY_OP
    WHEN
    XOR_EQUAL
    _FILE_
    _LINE_

Grammar

Rule 0     S' -> program
Rule 1     program -> expression
Rule 2     expression -> string_literals
Rule 3     expression -> prints
Rule 4     expression -> variable
Rule 5     expression -> array
Rule 6     expression -> hash
Rule 7     expression -> method_invocation
Rule 8     expression -> super
Rule 9     expression -> assignment
Rule 10    expression -> expression_operations
Rule 11    expression -> control_structure
Rule 12    expression -> class_definitions
Rule 13    expression -> singleton_class_definitions
Rule 14    expression -> module_definitions
Rule 15    expression -> method_definitions
Rule 16    expression -> singleton_method_definitions
Rule 17    expression -> alias
Rule 18    expression -> undef
Rule 19    expression -> defined
Rule 20    variable -> VAR_GLOBAL
Rule 21    variable -> VAR_INSTANCE
Rule 22    variable -> VAR_CLASS
Rule 23    variable -> VAR_LOCAL
Rule 24    variable -> VAR_SYSTEM
Rule 25    variable -> VAR_CONSTANT
Rule 26    string_literals -> STRING
Rule 27    string_literals -> string_concat
Rule 28    string_concat -> DOUBLE_QUOTED IDENTIFIER concat DOUBLE_QUOTED
Rule 29    string_concat -> DOUBLE_QUOTED IDENTIFIER concat IDENTIFIER DOUBLE_QUOTED
Rule 30    concat -> NUMBER_SIGN LKEY IDENTIFIER RKEY
Rule 31    prints -> PRINT expression
Rule 32    array -> LBRACKET args_array RBRACKET
Rule 33    array_data -> IDENTIFIER LBRACKET NUMBER RBRACKET
Rule 34    args_array -> data
Rule 35    args_array -> data COMMA args_array
Rule 36    hash -> LKEY args_hash RKEY
Rule 37    args_hash -> data HASH_ROCKET data
Rule 38    args_hash -> data HASH_ROCKET data COMMA args_hash
Rule 39    function -> IDENTIFIER LPAREN RPAREN
Rule 40    function -> IDENTIFIER LPAREN args_method RPAREN
Rule 41    super -> SUPER LPAREN RPAREN
Rule 42    super -> SUPER LPAREN args_method RPAREN
Rule 43    method_invocation -> IDENTIFIER DOT IDENTIFIER LPAREN RPAREN
Rule 44    method_invocation -> IDENTIFIER DOT IDENTIFIER LPAREN args_method RPAREN
Rule 45    method_invocation -> IDENTIFIER DOT IDENTIFIER
Rule 46    args_method -> data
Rule 47    args_method -> data COMMA args_method
Rule 48    assignment -> variable EQUAL_SYMBOL data
Rule 49    assignment -> array_data EQUAL_SYMBOL data
Rule 50    assignment -> method_invocation EQUAL_SYMBOL data
Rule 51    assignment -> self_assigment
Rule 52    assignment -> mult_assigment
Rule 53    self_assigment -> variable op_assigment data
Rule 54    op_assigment -> PLUS_EQUAL
Rule 55    op_assigment -> MINUS_EQUAL
Rule 56    op_assigment -> TIMES_EQUAL
Rule 57    op_assigment -> DIVIDE_EQUAL
Rule 58    op_assigment -> MOD_EQUAL
Rule 59    op_assigment -> POW_EQUAL
Rule 60    mult_assigment -> list_var EQUAL_SYMBOL args_method
Rule 61    list_var -> variable COMMA
Rule 62    list_var -> variable COMMA list_var
Rule 63    list_var -> variable
Rule 64    control_structure -> if
Rule 65    control_structure -> if_modifier
Rule 66    control_structure -> unless
Rule 67    control_structure -> unless_modifier
Rule 68    control_structure -> and
Rule 69    control_structure -> or
Rule 70    control_structure -> not
Rule 71    control_structure -> range_expressions
Rule 72    control_structure -> while
Rule 73    control_structure -> while_modifier
Rule 74    control_structure -> until
Rule 75    control_structure -> until_modifier
Rule 76    control_structure -> iterator
Rule 77    control_structure -> for
Rule 78    control_structure -> yield
Rule 79    control_structure -> begin_expression
Rule 80    control_structure -> retry
Rule 81    control_structure -> return
Rule 82    control_structure -> break
Rule 83    control_structure -> next
Rule 84    control_structure -> redo
Rule 85    control_structure -> begin
Rule 86    control_structure -> end
Rule 87    if -> IF expression expression END
Rule 88    if -> IF expression THEN expression END
Rule 89    if -> IF expression expression elsif END
Rule 90    if -> IF expression THEN expression elsif END
Rule 91    if -> IF expression expression else END
Rule 92    if -> IF expression THEN expression else END
Rule 93    if -> IF expression expression elsif else END
Rule 94    if -> IF expression THEN expression elsif else END
Rule 95    elsif -> ELSIF expression expression END
Rule 96    elsif -> ELSIF expression THEN expression END
Rule 97    else -> ELSE expression
Rule 98    if_modifier -> expression IF expression
Rule 99    unless -> UNLESS expression expression END
Rule 100   unless -> UNLESS expression THEN expression END
Rule 101   unless -> UNLESS expression THEN expression else END
Rule 102   unless_modifier -> expression UNLESS expression
Rule 103   and -> expression AND expression
Rule 104   or -> expression OR expression
Rule 105   not -> NOT expression
Rule 106   not -> NOT_SYMBOL expression
Rule 107   range_expressions -> expression RANGE_INCLUSIVE expression
Rule 108   range_expressions -> expression RANGE_EXCLUSIVE expression
Rule 109   while -> WHILE expression expression DO expression END
Rule 110   while_modifier -> expression WHILE expression
Rule 111   until -> UNTIL expression DO expression END
Rule 112   until_modifier -> expression UNTIL expression
Rule 113   iterator -> expression do OR_SYMBOL expression OR_SYMBOL expression END
Rule 114   iterator -> expression LKEY OR_SYMBOL expression OR_SYMBOL expression RKEY
Rule 115   for -> FOR expression IN expression DO expression END
Rule 116   yield -> YIELD LPAREN expression RPAREN
Rule 117   yield -> YIELD expression
Rule 118   begin_expression -> BEGIN expression RESCUE expression ENSURE expression END
Rule 119   begin_expression -> BEGIN expression RESCUE expression ELSE expression ENSURE expression END
Rule 120   retry -> RETRY
Rule 121   return -> RETURN
Rule 122   return -> RETURN expression
Rule 123   break -> BREAK
Rule 124   next -> NEXT
Rule 125   redo -> REDO
Rule 126   begin -> BEGIN LKEY expression RKEY
Rule 127   end -> END LKEY expression RKEY
Rule 128   class_definitions -> CLASS IDENTIFIER expression END
Rule 129   class_definitions -> CLASS IDENTIFIER LESSERTHAN SUPER expression END
Rule 130   singleton_class_definitions -> CLASS BINARY_LEFT_SHIFT_OP expression expression END
Rule 131   module_definitions -> MODULE IDENTIFIER expression END
Rule 132   method_definitions -> DEF function expression END
Rule 133   singleton_method_definitions -> DEF expression DOT IDENTIFIER expression END
Rule 134   singleton_method_definitions -> DEF expression DOT IDENTIFIER LPAREN args_method RPAREN expression END
Rule 135   alias -> ALIAS expression expression
Rule 136   undef -> UNDEF expression
Rule 137   defined -> DEFINED_OP expression
Rule 138   expression_operations -> opmate
Rule 139   expression_operations -> LPAREN opmate RPAREN
Rule 140   expression_operations -> expression_operations op expression_operations
Rule 141   expression_operations -> expression_operations op opmate
Rule 142   expression_operations -> LPAREN opmate RPAREN op expression_operations
Rule 143   expression_operations -> expression_operations op LPAREN opmate RPAREN
Rule 144   opmate -> data op data
Rule 145   op -> PLUS
Rule 146   op -> MINUS
Rule 147   op -> TIMES
Rule 148   op -> DIVIDE
Rule 149   op -> MOD
Rule 150   op -> EQUAL
Rule 151   op -> NOTEQUAL
Rule 152   op -> GREATERTHAN
Rule 153   op -> GREATERTHANEQUAL
Rule 154   op -> LESSERTHAN
Rule 155   op -> LESSERTHANEQUAL
Rule 156   data -> NUMBER
Rule 157   data -> STRING
